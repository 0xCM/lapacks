-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.CArray.Generic (
   gbsv,
   gbtf2,
   gbtrf,
   gbtrs,
   gehd2,
   gehrd,
   gelq2,
   gelqf,
   gels,
   geql2,
   geqlf,
   geqp3,
   geqr2,
   geqr2p,
   geqrf,
   geqrfp,
   gerq2,
   gerqf,
   gesv,
   getc2,
   getf2,
   getrf,
   getri,
   getrs,
   ggglm,
   gghrd,
   gglse,
   ggqrf,
   ggrqf,
   gtsv,
   gttrf,
   gttrs,
   gtts2,
   hbgst,
   hpgst,
   hpsv,
   hptrf,
   hptri,
   hptrs,
   ilalc,
   ilalr,
   lacpy,
   lahr2,
   lapmr,
   lapmt,
   larf,
   larfb,
   larfg,
   larfgp,
   larft,
   larfx,
   larnv,
   larz,
   larzb,
   larzt,
   laset,
   laswp,
   lasyf,
   latrz,
   lauu2,
   lauum,
   pbstf,
   pbsv,
   pbtf2,
   pbtrf,
   pbtrs,
   pftrf,
   pftri,
   pftrs,
   posv,
   potf2,
   potrf,
   potri,
   potrs,
   ppsv,
   pptrf,
   pptri,
   pptrs,
   spsv,
   sptrf,
   sptri,
   sptrs,
   syconv,
   sysv,
   syswapr,
   sytf2,
   sytrf,
   sytri,
   sytri2,
   sytri2x,
   sytrs,
   sytrs2,
   tbtrs,
   tfsm,
   tftri,
   tfttp,
   tfttr,
   tgevc,
   tptri,
   tptrs,
   tpttf,
   tpttr,
   trti2,
   trtri,
   trtrs,
   trttp,
   tzrzf,
   ung2l,
   ung2r,
   ungbr,
   unghr,
   ungl2,
   unglq,
   ungql,
   ungqr,
   ungr2,
   ungrq,
   ungtr,
   unm2l,
   unm2r,
   unmbr,
   unmhr,
   unml2,
   unmlq,
   unmql,
   unmqr,
   unmr2,
   unmr3,
   unmrq,
   unmrz,
   unmtr,
   upgtr,
   upmtr,
   ) where

import qualified Numeric.LAPACK.CArray.ComplexDouble as Z
import qualified Numeric.LAPACK.CArray.ComplexFloat as C
import qualified Numeric.LAPACK.CArray.Double as D
import qualified Numeric.LAPACK.CArray.Float as S
import qualified Numeric.Netlib.Class as Class

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.C.Types (CInt)



newtype GBSV a = GBSV {getGBSV :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbsv :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbsv = getGBSV $ Class.switchFloating (GBSV S.gbsv) (GBSV D.gbsv) (GBSV C.gbsv) (GBSV Z.gbsv)


newtype GBTF2 a = GBTF2 {getGBTF2 :: Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbtf2 :: Class.Floating a => Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbtf2 = getGBTF2 $ Class.switchFloating (GBTF2 S.gbtf2) (GBTF2 D.gbtf2) (GBTF2 C.gbtf2) (GBTF2 Z.gbtf2)


newtype GBTRF a = GBTRF {getGBTRF :: Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbtrf :: Class.Floating a => Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbtrf = getGBTRF $ Class.switchFloating (GBTRF S.gbtrf) (GBTRF D.gbtrf) (GBTRF C.gbtrf) (GBTRF Z.gbtrf)


newtype GBTRS a = GBTRS {getGBTRS :: Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

gbtrs :: Class.Floating a => Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
gbtrs = getGBTRS $ Class.switchFloating (GBTRS S.gbtrs) (GBTRS D.gbtrs) (GBTRS C.gbtrs) (GBTRS Z.gbtrs)


newtype GEHD2 a = GEHD2 {getGEHD2 :: Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gehd2 :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gehd2 = getGEHD2 $ Class.switchFloating (GEHD2 S.gehd2) (GEHD2 D.gehd2) (GEHD2 C.gehd2) (GEHD2 Z.gehd2)


newtype GEHRD a = GEHRD {getGEHRD :: Int -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gehrd :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gehrd = getGEHRD $ Class.switchFloating (GEHRD S.gehrd) (GEHRD D.gehrd) (GEHRD C.gehrd) (GEHRD Z.gehrd)


newtype GELQ2 a = GELQ2 {getGELQ2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gelq2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gelq2 = getGELQ2 $ Class.switchFloating (GELQ2 S.gelq2) (GELQ2 D.gelq2) (GELQ2 C.gelq2) (GELQ2 Z.gelq2)


newtype GELQF a = GELQF {getGELQF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gelqf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gelqf = getGELQF $ Class.switchFloating (GELQF S.gelqf) (GELQF D.gelqf) (GELQF C.gelqf) (GELQF Z.gelqf)


newtype GELS a = GELS {getGELS :: Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

gels :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int)
gels = getGELS $ Class.switchFloating (GELS S.gels) (GELS D.gels) (GELS C.gels) (GELS Z.gels)


newtype GEQL2 a = GEQL2 {getGEQL2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geql2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geql2 = getGEQL2 $ Class.switchFloating (GEQL2 S.geql2) (GEQL2 D.geql2) (GEQL2 C.geql2) (GEQL2 Z.geql2)


newtype GEQLF a = GEQLF {getGEQLF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqlf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqlf = getGEQLF $ Class.switchFloating (GEQLF S.geqlf) (GEQLF D.geqlf) (GEQLF C.geqlf) (GEQLF Z.geqlf)


newtype GEQP3 a = GEQP3 {getGEQP3 :: Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IO (CArray Int a, Int)}

geqp3 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IO (CArray Int a, Int)
geqp3 = getGEQP3 $ Class.switchFloating (GEQP3 S.geqp3) (GEQP3 D.geqp3) (GEQP3 C.geqp3) (GEQP3 Z.geqp3)


newtype GEQR2 a = GEQR2 {getGEQR2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geqr2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geqr2 = getGEQR2 $ Class.switchFloating (GEQR2 S.geqr2) (GEQR2 D.geqr2) (GEQR2 C.geqr2) (GEQR2 Z.geqr2)


newtype GEQR2P a = GEQR2P {getGEQR2P :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geqr2p :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geqr2p = getGEQR2P $ Class.switchFloating (GEQR2P S.geqr2p) (GEQR2P D.geqr2p) (GEQR2P C.geqr2p) (GEQR2P Z.geqr2p)


newtype GEQRF a = GEQRF {getGEQRF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqrf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqrf = getGEQRF $ Class.switchFloating (GEQRF S.geqrf) (GEQRF D.geqrf) (GEQRF C.geqrf) (GEQRF Z.geqrf)


newtype GEQRFP a = GEQRFP {getGEQRFP :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqrfp :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqrfp = getGEQRFP $ Class.switchFloating (GEQRFP S.geqrfp) (GEQRFP D.geqrfp) (GEQRFP C.geqrfp) (GEQRFP Z.geqrfp)


newtype GERQ2 a = GERQ2 {getGERQ2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gerq2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gerq2 = getGERQ2 $ Class.switchFloating (GERQ2 S.gerq2) (GERQ2 D.gerq2) (GERQ2 C.gerq2) (GERQ2 Z.gerq2)


newtype GERQF a = GERQF {getGERQF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gerqf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gerqf = getGERQF $ Class.switchFloating (GERQF S.gerqf) (GERQF D.gerqf) (GERQF C.gerqf) (GERQF Z.gerqf)


newtype GESV a = GESV {getGESV :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gesv :: Class.Floating a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gesv = getGESV $ Class.switchFloating (GESV S.gesv) (GESV D.gesv) (GESV C.gesv) (GESV Z.gesv)


newtype GETC2 a = GETC2 {getGETC2 :: IOCArray (Int,Int) a -> IO (CArray Int CInt, CArray Int CInt, Int)}

getc2 :: Class.Floating a => IOCArray (Int,Int) a -> IO (CArray Int CInt, CArray Int CInt, Int)
getc2 = getGETC2 $ Class.switchFloating (GETC2 S.getc2) (GETC2 D.getc2) (GETC2 C.getc2) (GETC2 Z.getc2)


newtype GETF2 a = GETF2 {getGETF2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

getf2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
getf2 = getGETF2 $ Class.switchFloating (GETF2 S.getf2) (GETF2 D.getf2) (GETF2 C.getf2) (GETF2 Z.getf2)


newtype GETRF a = GETRF {getGETRF :: Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

getrf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
getrf = getGETRF $ Class.switchFloating (GETRF S.getrf) (GETRF D.getrf) (GETRF C.getrf) (GETRF Z.getrf)


newtype GETRI a = GETRI {getGETRI :: IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)}

getri :: Class.Floating a => IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)
getri = getGETRI $ Class.switchFloating (GETRI S.getri) (GETRI D.getri) (GETRI C.getri) (GETRI Z.getri)


newtype GETRS a = GETRS {getGETRS :: Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

getrs :: Class.Floating a => Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
getrs = getGETRS $ Class.switchFloating (GETRS S.getrs) (GETRS D.getrs) (GETRS C.getrs) (GETRS Z.getrs)


newtype GGGLM a = GGGLM {getGGGLM :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggglm :: Class.Floating a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggglm = getGGGLM $ Class.switchFloating (GGGLM S.ggglm) (GGGLM D.ggglm) (GGGLM C.ggglm) (GGGLM Z.ggglm)


newtype GGHRD a = GGHRD {getGGHRD :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

gghrd :: Class.Floating a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
gghrd = getGGHRD $ Class.switchFloating (GGHRD S.gghrd) (GGHRD D.gghrd) (GGHRD C.gghrd) (GGHRD Z.gghrd)


newtype GGLSE a = GGLSE {getGGLSE :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, Int)}

gglse :: Class.Floating a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, Int)
gglse = getGGLSE $ Class.switchFloating (GGLSE S.gglse) (GGLSE D.gglse) (GGLSE C.gglse) (GGLSE Z.gglse)


newtype GGQRF a = GGQRF {getGGQRF :: Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggqrf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggqrf = getGGQRF $ Class.switchFloating (GGQRF S.ggqrf) (GGQRF D.ggqrf) (GGQRF C.ggqrf) (GGQRF Z.ggqrf)


newtype GGRQF a = GGRQF {getGGRQF :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggrqf :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggrqf = getGGRQF $ Class.switchFloating (GGRQF S.ggrqf) (GGRQF D.ggrqf) (GGRQF C.ggrqf) (GGRQF Z.ggrqf)


newtype GTSV a = GTSV {getGTSV :: IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

gtsv :: Class.Floating a => IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
gtsv = getGTSV $ Class.switchFloating (GTSV S.gtsv) (GTSV D.gtsv) (GTSV C.gtsv) (GTSV Z.gtsv)


newtype GTTRF a = GTTRF {getGTTRF :: IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a, CArray Int CInt, Int)}

gttrf :: Class.Floating a => IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a, CArray Int CInt, Int)
gttrf = getGTTRF $ Class.switchFloating (GTTRF S.gttrf) (GTTRF D.gttrf) (GTTRF C.gttrf) (GTTRF Z.gttrf)


newtype GTTRS a = GTTRS {getGTTRS :: Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

gttrs :: Class.Floating a => Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
gttrs = getGTTRS $ Class.switchFloating (GTTRS S.gttrs) (GTTRS D.gttrs) (GTTRS C.gttrs) (GTTRS Z.gttrs)


newtype GTTS2 a = GTTS2 {getGTTS2 :: Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO ()}

gtts2 :: Class.Floating a => Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO ()
gtts2 = getGTTS2 $ Class.switchFloating (GTTS2 S.gtts2) (GTTS2 D.gtts2) (GTTS2 C.gtts2) (GTTS2 Z.gtts2)


newtype HBGST a = HBGST {getHBGST :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, Int)}

hbgst :: Class.Floating a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, Int)
hbgst = getHBGST $ Class.switchFloating (HBGST S.sbgst) (HBGST D.sbgst) (HBGST C.hbgst) (HBGST Z.hbgst)


newtype HPGST a = HPGST {getHPGST :: Int -> Char -> Int -> IOCArray Int a -> CArray Int a -> IO (Int)}

hpgst :: Class.Floating a => Int -> Char -> Int -> IOCArray Int a -> CArray Int a -> IO (Int)
hpgst = getHPGST $ Class.switchFloating (HPGST S.spgst) (HPGST D.spgst) (HPGST C.hpgst) (HPGST Z.hpgst)


newtype HPSV a = HPSV {getHPSV :: Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

hpsv :: Class.Floating a => Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
hpsv = getHPSV $ Class.switchFloating (HPSV S.spsv) (HPSV D.spsv) (HPSV C.hpsv) (HPSV Z.hpsv)


newtype HPTRF a = HPTRF {getHPTRF :: Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)}

hptrf :: Class.Floating a => Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)
hptrf = getHPTRF $ Class.switchFloating (HPTRF S.sptrf) (HPTRF D.sptrf) (HPTRF C.hptrf) (HPTRF Z.hptrf)


newtype HPTRI a = HPTRI {getHPTRI :: Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)}

hptri :: Class.Floating a => Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)
hptri = getHPTRI $ Class.switchFloating (HPTRI S.sptri) (HPTRI D.sptri) (HPTRI C.hptri) (HPTRI Z.hptri)


newtype HPTRS a = HPTRS {getHPTRS :: Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

hptrs :: Class.Floating a => Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
hptrs = getHPTRS $ Class.switchFloating (HPTRS S.sptrs) (HPTRS D.sptrs) (HPTRS C.hptrs) (HPTRS Z.hptrs)


newtype ILALC a = ILALC {getILALC :: Int -> CArray (Int,Int) a -> IO CInt}

ilalc :: Class.Floating a => Int -> CArray (Int,Int) a -> IO CInt
ilalc = getILALC $ Class.switchFloating (ILALC S.ilalc) (ILALC D.ilalc) (ILALC C.ilalc) (ILALC Z.ilalc)


newtype ILALR a = ILALR {getILALR :: Int -> CArray (Int,Int) a -> IO CInt}

ilalr :: Class.Floating a => Int -> CArray (Int,Int) a -> IO CInt
ilalr = getILALR $ Class.switchFloating (ILALR S.ilalr) (ILALR D.ilalr) (ILALR C.ilalr) (ILALR Z.ilalr)


newtype LACPY a = LACPY {getLACPY :: Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a)}

lacpy :: Class.Floating a => Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a)
lacpy = getLACPY $ Class.switchFloating (LACPY S.lacpy) (LACPY D.lacpy) (LACPY C.lacpy) (LACPY Z.lacpy)


newtype LAHR2 a = LAHR2 {getLAHR2 :: Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)}

lahr2 :: Class.Floating a => Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)
lahr2 = getLAHR2 $ Class.switchFloating (LAHR2 S.lahr2) (LAHR2 D.lahr2) (LAHR2 C.lahr2) (LAHR2 Z.lahr2)


newtype LAPMR a = LAPMR {getLAPMR :: Bool -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()}

lapmr :: Class.Floating a => Bool -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()
lapmr = getLAPMR $ Class.switchFloating (LAPMR S.lapmr) (LAPMR D.lapmr) (LAPMR C.lapmr) (LAPMR Z.lapmr)


newtype LAPMT a = LAPMT {getLAPMT :: Bool -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()}

lapmt :: Class.Floating a => Bool -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()
lapmt = getLAPMT $ Class.switchFloating (LAPMT S.lapmt) (LAPMT D.lapmt) (LAPMT C.lapmt) (LAPMT Z.lapmt)


newtype LARF a = LARF {getLARF :: Char -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larf :: Class.Floating a => Char -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larf = getLARF $ Class.switchFloating (LARF S.larf) (LARF D.larf) (LARF C.larf) (LARF Z.larf)


newtype LARFB a = LARFB {getLARFB :: Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()}

larfb :: Class.Floating a => Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()
larfb = getLARFB $ Class.switchFloating (LARFB S.larfb) (LARFB D.larfb) (LARFB C.larfb) (LARFB Z.larfb)


newtype LARFG a = LARFG {getLARFG :: Int -> a -> IOCArray Int a -> Int -> IO (a, a)}

larfg :: Class.Floating a => Int -> a -> IOCArray Int a -> Int -> IO (a, a)
larfg = getLARFG $ Class.switchFloating (LARFG S.larfg) (LARFG D.larfg) (LARFG C.larfg) (LARFG Z.larfg)


newtype LARFGP a = LARFGP {getLARFGP :: Int -> a -> IOCArray Int a -> Int -> IO (a, a)}

larfgp :: Class.Floating a => Int -> a -> IOCArray Int a -> Int -> IO (a, a)
larfgp = getLARFGP $ Class.switchFloating (LARFGP S.larfgp) (LARFGP D.larfgp) (LARFGP C.larfgp) (LARFGP Z.larfgp)


newtype LARFT a = LARFT {getLARFT :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)}

larft :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)
larft = getLARFT $ Class.switchFloating (LARFT S.larft) (LARFT D.larft) (LARFT C.larft) (LARFT Z.larft)


newtype LARFX a = LARFX {getLARFX :: Char -> Int -> CArray Int a -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larfx :: Class.Floating a => Char -> Int -> CArray Int a -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larfx = getLARFX $ Class.switchFloating (LARFX S.larfx) (LARFX D.larfx) (LARFX C.larfx) (LARFX Z.larfx)


newtype LARNV a = LARNV {getLARNV :: Int -> IOCArray Int CInt -> Int -> IO (CArray Int a)}

larnv :: Class.Floating a => Int -> IOCArray Int CInt -> Int -> IO (CArray Int a)
larnv = getLARNV $ Class.switchFloating (LARNV S.larnv) (LARNV D.larnv) (LARNV C.larnv) (LARNV Z.larnv)


newtype LARZ a = LARZ {getLARZ :: Char -> Int -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larz :: Class.Floating a => Char -> Int -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larz = getLARZ $ Class.switchFloating (LARZ S.larz) (LARZ D.larz) (LARZ C.larz) (LARZ Z.larz)


newtype LARZB a = LARZB {getLARZB :: Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()}

larzb :: Class.Floating a => Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()
larzb = getLARZB $ Class.switchFloating (LARZB S.larzb) (LARZB D.larzb) (LARZB C.larzb) (LARZB Z.larzb)


newtype LARZT a = LARZT {getLARZT :: Char -> Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)}

larzt :: Class.Floating a => Char -> Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)
larzt = getLARZT $ Class.switchFloating (LARZT S.larzt) (LARZT D.larzt) (LARZT C.larzt) (LARZT Z.larzt)


newtype LASET a = LASET {getLASET :: Char -> Int -> Int -> a -> a -> Int -> IO (CArray (Int,Int) a)}

laset :: Class.Floating a => Char -> Int -> Int -> a -> a -> Int -> IO (CArray (Int,Int) a)
laset = getLASET $ Class.switchFloating (LASET S.laset) (LASET D.laset) (LASET C.laset) (LASET Z.laset)


newtype LASWP a = LASWP {getLASWP :: IOCArray (Int,Int) a -> Int -> Int -> CArray Int CInt -> Int -> IO ()}

laswp :: Class.Floating a => IOCArray (Int,Int) a -> Int -> Int -> CArray Int CInt -> Int -> IO ()
laswp = getLASWP $ Class.switchFloating (LASWP S.laswp) (LASWP D.laswp) (LASWP C.laswp) (LASWP Z.laswp)


newtype LASYF a = LASYF {getLASYF :: Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) a, Int)}

lasyf :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) a, Int)
lasyf = getLASYF $ Class.switchFloating (LASYF S.lasyf) (LASYF D.lasyf) (LASYF C.lasyf) (LASYF Z.lasyf)


newtype LATRZ a = LATRZ {getLATRZ :: Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a)}

latrz :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a)
latrz = getLATRZ $ Class.switchFloating (LATRZ S.latrz) (LATRZ D.latrz) (LATRZ C.latrz) (LATRZ Z.latrz)


newtype LAUU2 a = LAUU2 {getLAUU2 :: Char -> IOCArray (Int,Int) a -> IO (Int)}

lauu2 :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (Int)
lauu2 = getLAUU2 $ Class.switchFloating (LAUU2 S.lauu2) (LAUU2 D.lauu2) (LAUU2 C.lauu2) (LAUU2 Z.lauu2)


newtype LAUUM a = LAUUM {getLAUUM :: Char -> IOCArray (Int,Int) a -> IO (Int)}

lauum :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (Int)
lauum = getLAUUM $ Class.switchFloating (LAUUM S.lauum) (LAUUM D.lauum) (LAUUM C.lauum) (LAUUM Z.lauum)


newtype PBSTF a = PBSTF {getPBSTF :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbstf :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbstf = getPBSTF $ Class.switchFloating (PBSTF S.pbstf) (PBSTF D.pbstf) (PBSTF C.pbstf) (PBSTF Z.pbstf)


newtype PBSV a = PBSV {getPBSV :: Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

pbsv :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
pbsv = getPBSV $ Class.switchFloating (PBSV S.pbsv) (PBSV D.pbsv) (PBSV C.pbsv) (PBSV Z.pbsv)


newtype PBTF2 a = PBTF2 {getPBTF2 :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbtf2 :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbtf2 = getPBTF2 $ Class.switchFloating (PBTF2 S.pbtf2) (PBTF2 D.pbtf2) (PBTF2 C.pbtf2) (PBTF2 Z.pbtf2)


newtype PBTRF a = PBTRF {getPBTRF :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbtrf :: Class.Floating a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbtrf = getPBTRF $ Class.switchFloating (PBTRF S.pbtrf) (PBTRF D.pbtrf) (PBTRF C.pbtrf) (PBTRF Z.pbtrf)


newtype PBTRS a = PBTRS {getPBTRS :: Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

pbtrs :: Class.Floating a => Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
pbtrs = getPBTRS $ Class.switchFloating (PBTRS S.pbtrs) (PBTRS D.pbtrs) (PBTRS C.pbtrs) (PBTRS Z.pbtrs)


newtype PFTRF a = PFTRF {getPFTRF :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

pftrf :: Class.Floating a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
pftrf = getPFTRF $ Class.switchFloating (PFTRF S.pftrf) (PFTRF D.pftrf) (PFTRF C.pftrf) (PFTRF Z.pftrf)


newtype PFTRI a = PFTRI {getPFTRI :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

pftri :: Class.Floating a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
pftri = getPFTRI $ Class.switchFloating (PFTRI S.pftri) (PFTRI D.pftri) (PFTRI C.pftri) (PFTRI Z.pftri)


newtype PFTRS a = PFTRS {getPFTRS :: Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pftrs :: Class.Floating a => Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pftrs = getPFTRS $ Class.switchFloating (PFTRS S.pftrs) (PFTRS D.pftrs) (PFTRS C.pftrs) (PFTRS Z.pftrs)


newtype POSV a = POSV {getPOSV :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

posv :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
posv = getPOSV $ Class.switchFloating (POSV S.posv) (POSV D.posv) (POSV C.posv) (POSV Z.posv)


newtype POTF2 a = POTF2 {getPOTF2 :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potf2 :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (Int)
potf2 = getPOTF2 $ Class.switchFloating (POTF2 S.potf2) (POTF2 D.potf2) (POTF2 C.potf2) (POTF2 Z.potf2)


newtype POTRF a = POTRF {getPOTRF :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potrf :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (Int)
potrf = getPOTRF $ Class.switchFloating (POTRF S.potrf) (POTRF D.potrf) (POTRF C.potrf) (POTRF Z.potrf)


newtype POTRI a = POTRI {getPOTRI :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potri :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (Int)
potri = getPOTRI $ Class.switchFloating (POTRI S.potri) (POTRI D.potri) (POTRI C.potri) (POTRI Z.potri)


newtype POTRS a = POTRS {getPOTRS :: Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

potrs :: Class.Floating a => Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
potrs = getPOTRS $ Class.switchFloating (POTRS S.potrs) (POTRS D.potrs) (POTRS C.potrs) (POTRS Z.potrs)


newtype PPSV a = PPSV {getPPSV :: Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

ppsv :: Class.Floating a => Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
ppsv = getPPSV $ Class.switchFloating (PPSV S.ppsv) (PPSV D.ppsv) (PPSV C.ppsv) (PPSV Z.ppsv)


newtype PPTRF a = PPTRF {getPPTRF :: Char -> Int -> IOCArray Int a -> IO (Int)}

pptrf :: Class.Floating a => Char -> Int -> IOCArray Int a -> IO (Int)
pptrf = getPPTRF $ Class.switchFloating (PPTRF S.pptrf) (PPTRF D.pptrf) (PPTRF C.pptrf) (PPTRF Z.pptrf)


newtype PPTRI a = PPTRI {getPPTRI :: Char -> Int -> IOCArray Int a -> IO (Int)}

pptri :: Class.Floating a => Char -> Int -> IOCArray Int a -> IO (Int)
pptri = getPPTRI $ Class.switchFloating (PPTRI S.pptri) (PPTRI D.pptri) (PPTRI C.pptri) (PPTRI Z.pptri)


newtype PPTRS a = PPTRS {getPPTRS :: Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pptrs :: Class.Floating a => Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pptrs = getPPTRS $ Class.switchFloating (PPTRS S.pptrs) (PPTRS D.pptrs) (PPTRS C.pptrs) (PPTRS Z.pptrs)


newtype SPSV a = SPSV {getSPSV :: Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

spsv :: Class.Floating a => Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
spsv = getSPSV $ Class.switchFloating (SPSV S.spsv) (SPSV D.spsv) (SPSV C.spsv) (SPSV Z.spsv)


newtype SPTRF a = SPTRF {getSPTRF :: Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)}

sptrf :: Class.Floating a => Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)
sptrf = getSPTRF $ Class.switchFloating (SPTRF S.sptrf) (SPTRF D.sptrf) (SPTRF C.sptrf) (SPTRF Z.sptrf)


newtype SPTRI a = SPTRI {getSPTRI :: Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)}

sptri :: Class.Floating a => Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)
sptri = getSPTRI $ Class.switchFloating (SPTRI S.sptri) (SPTRI D.sptri) (SPTRI C.sptri) (SPTRI Z.sptri)


newtype SPTRS a = SPTRS {getSPTRS :: Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sptrs :: Class.Floating a => Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sptrs = getSPTRS $ Class.switchFloating (SPTRS S.sptrs) (SPTRS D.sptrs) (SPTRS C.sptrs) (SPTRS Z.sptrs)


newtype SYCONV a = SYCONV {getSYCONV :: Char -> Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (CArray Int a, Int)}

syconv :: Class.Floating a => Char -> Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (CArray Int a, Int)
syconv = getSYCONV $ Class.switchFloating (SYCONV S.syconv) (SYCONV D.syconv) (SYCONV C.syconv) (SYCONV Z.syconv)


newtype SYSV a = SYSV {getSYSV :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)}

sysv :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)
sysv = getSYSV $ Class.switchFloating (SYSV S.sysv) (SYSV D.sysv) (SYSV C.sysv) (SYSV Z.sysv)


newtype SYSWAPR a = SYSWAPR {getSYSWAPR :: Char -> IOCArray (Int,Int) a -> Int -> Int -> IO ()}

syswapr :: Class.Floating a => Char -> IOCArray (Int,Int) a -> Int -> Int -> IO ()
syswapr = getSYSWAPR $ Class.switchFloating (SYSWAPR S.syswapr) (SYSWAPR D.syswapr) (SYSWAPR C.syswapr) (SYSWAPR Z.syswapr)


newtype SYTF2 a = SYTF2 {getSYTF2 :: Char -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

sytf2 :: Class.Floating a => Char -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
sytf2 = getSYTF2 $ Class.switchFloating (SYTF2 S.sytf2) (SYTF2 D.sytf2) (SYTF2 C.sytf2) (SYTF2 Z.sytf2)


newtype SYTRF a = SYTRF {getSYTRF :: Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)}

sytrf :: Class.Floating a => Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)
sytrf = getSYTRF $ Class.switchFloating (SYTRF S.sytrf) (SYTRF D.sytrf) (SYTRF C.sytrf) (SYTRF Z.sytrf)


newtype SYTRI a = SYTRI {getSYTRI :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (Int)}

sytri :: Class.Floating a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (Int)
sytri = getSYTRI $ Class.switchFloating (SYTRI S.sytri) (SYTRI D.sytri) (SYTRI C.sytri) (SYTRI Z.sytri)


newtype SYTRI2 a = SYTRI2 {getSYTRI2 :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> Int -> IO (Int)}

sytri2 :: Class.Floating a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> Int -> IO (Int)
sytri2 = getSYTRI2 $ Class.switchFloating (SYTRI2 S.sytri2) (SYTRI2 D.sytri2) (SYTRI2 C.sytri2) (SYTRI2 Z.sytri2)


newtype SYTRI2X a = SYTRI2X {getSYTRI2X :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)}

sytri2x :: Class.Floating a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)
sytri2x = getSYTRI2X $ Class.switchFloating (SYTRI2X S.sytri2x) (SYTRI2X D.sytri2x) (SYTRI2X C.sytri2x) (SYTRI2X Z.sytri2x)


newtype SYTRS a = SYTRS {getSYTRS :: Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sytrs :: Class.Floating a => Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sytrs = getSYTRS $ Class.switchFloating (SYTRS S.sytrs) (SYTRS D.sytrs) (SYTRS C.sytrs) (SYTRS Z.sytrs)


newtype SYTRS2 a = SYTRS2 {getSYTRS2 :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sytrs2 :: Class.Floating a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sytrs2 = getSYTRS2 $ Class.switchFloating (SYTRS2 S.sytrs2) (SYTRS2 D.sytrs2) (SYTRS2 C.sytrs2) (SYTRS2 Z.sytrs2)


newtype TBTRS a = TBTRS {getTBTRS :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

tbtrs :: Class.Floating a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
tbtrs = getTBTRS $ Class.switchFloating (TBTRS S.tbtrs) (TBTRS D.tbtrs) (TBTRS C.tbtrs) (TBTRS Z.tbtrs)


newtype TFSM a = TFSM {getTFSM :: Char -> Char -> Char -> Char -> Char -> Int -> a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()}

tfsm :: Class.Floating a => Char -> Char -> Char -> Char -> Char -> Int -> a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()
tfsm = getTFSM $ Class.switchFloating (TFSM S.tfsm) (TFSM D.tfsm) (TFSM C.tfsm) (TFSM Z.tfsm)


newtype TFTRI a = TFTRI {getTFTRI :: Char -> Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

tftri :: Class.Floating a => Char -> Char -> Char -> Int -> IOCArray Int a -> IO (Int)
tftri = getTFTRI $ Class.switchFloating (TFTRI S.tftri) (TFTRI D.tftri) (TFTRI C.tftri) (TFTRI Z.tftri)


newtype TFTTP a = TFTTP {getTFTTP :: Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)}

tfttp :: Class.Floating a => Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)
tfttp = getTFTTP $ Class.switchFloating (TFTTP S.tfttp) (TFTTP D.tfttp) (TFTTP C.tfttp) (TFTTP Z.tfttp)


newtype TFTTR a = TFTTR {getTFTTR :: Char -> Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

tfttr :: Class.Floating a => Char -> Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
tfttr = getTFTTR $ Class.switchFloating (TFTTR S.tfttr) (TFTTR D.tfttr) (TFTTR C.tfttr) (TFTTR Z.tfttr)


newtype TGEVC a = TGEVC {getTGEVC :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)}

tgevc :: Class.Floating a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)
tgevc = getTGEVC $ Class.switchFloating (TGEVC S.tgevc) (TGEVC D.tgevc) (TGEVC C.tgevc) (TGEVC Z.tgevc)


newtype TPTRI a = TPTRI {getTPTRI :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

tptri :: Class.Floating a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
tptri = getTPTRI $ Class.switchFloating (TPTRI S.tptri) (TPTRI D.tptri) (TPTRI C.tptri) (TPTRI Z.tptri)


newtype TPTRS a = TPTRS {getTPTRS :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

tptrs :: Class.Floating a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
tptrs = getTPTRS $ Class.switchFloating (TPTRS S.tptrs) (TPTRS D.tptrs) (TPTRS C.tptrs) (TPTRS Z.tptrs)


newtype TPTTF a = TPTTF {getTPTTF :: Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)}

tpttf :: Class.Floating a => Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)
tpttf = getTPTTF $ Class.switchFloating (TPTTF S.tpttf) (TPTTF D.tpttf) (TPTTF C.tpttf) (TPTTF Z.tpttf)


newtype TPTTR a = TPTTR {getTPTTR :: Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

tpttr :: Class.Floating a => Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
tpttr = getTPTTR $ Class.switchFloating (TPTTR S.tpttr) (TPTTR D.tpttr) (TPTTR C.tpttr) (TPTTR Z.tpttr)


newtype TRTI2 a = TRTI2 {getTRTI2 :: Char -> Char -> IOCArray (Int,Int) a -> IO (Int)}

trti2 :: Class.Floating a => Char -> Char -> IOCArray (Int,Int) a -> IO (Int)
trti2 = getTRTI2 $ Class.switchFloating (TRTI2 S.trti2) (TRTI2 D.trti2) (TRTI2 C.trti2) (TRTI2 Z.trti2)


newtype TRTRI a = TRTRI {getTRTRI :: Char -> Char -> IOCArray (Int,Int) a -> IO (Int)}

trtri :: Class.Floating a => Char -> Char -> IOCArray (Int,Int) a -> IO (Int)
trtri = getTRTRI $ Class.switchFloating (TRTRI S.trtri) (TRTRI D.trtri) (TRTRI C.trtri) (TRTRI Z.trtri)


newtype TRTRS a = TRTRS {getTRTRS :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

trtrs :: Class.Floating a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
trtrs = getTRTRS $ Class.switchFloating (TRTRS S.trtrs) (TRTRS D.trtrs) (TRTRS C.trtrs) (TRTRS Z.trtrs)


newtype TRTTP a = TRTTP {getTRTTP :: Char -> CArray (Int,Int) a -> IO (CArray Int a, Int)}

trttp :: Class.Floating a => Char -> CArray (Int,Int) a -> IO (CArray Int a, Int)
trttp = getTRTTP $ Class.switchFloating (TRTTP S.trttp) (TRTTP D.trttp) (TRTTP C.trttp) (TRTTP Z.trttp)


newtype TZRZF a = TZRZF {getTZRZF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

tzrzf :: Class.Floating a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
tzrzf = getTZRZF $ Class.switchFloating (TZRZF S.tzrzf) (TZRZF D.tzrzf) (TZRZF C.tzrzf) (TZRZF Z.tzrzf)


newtype UNG2L a = UNG2L {getUNG2L :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

ung2l :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
ung2l = getUNG2L $ Class.switchFloating (UNG2L S.org2l) (UNG2L D.org2l) (UNG2L C.ung2l) (UNG2L Z.ung2l)


newtype UNG2R a = UNG2R {getUNG2R :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

ung2r :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
ung2r = getUNG2R $ Class.switchFloating (UNG2R S.org2r) (UNG2R D.org2r) (UNG2R C.ung2r) (UNG2R Z.ung2r)


newtype UNGBR a = UNGBR {getUNGBR :: Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

ungbr :: Class.Floating a => Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
ungbr = getUNGBR $ Class.switchFloating (UNGBR S.orgbr) (UNGBR D.orgbr) (UNGBR C.ungbr) (UNGBR Z.ungbr)


newtype UNGHR a = UNGHR {getUNGHR :: Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

unghr :: Class.Floating a => Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
unghr = getUNGHR $ Class.switchFloating (UNGHR S.orghr) (UNGHR D.orghr) (UNGHR C.unghr) (UNGHR Z.unghr)


newtype UNGL2 a = UNGL2 {getUNGL2 :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

ungl2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
ungl2 = getUNGL2 $ Class.switchFloating (UNGL2 S.orgl2) (UNGL2 D.orgl2) (UNGL2 C.ungl2) (UNGL2 Z.ungl2)


newtype UNGLQ a = UNGLQ {getUNGLQ :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

unglq :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
unglq = getUNGLQ $ Class.switchFloating (UNGLQ S.orglq) (UNGLQ D.orglq) (UNGLQ C.unglq) (UNGLQ Z.unglq)


newtype UNGQL a = UNGQL {getUNGQL :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

ungql :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
ungql = getUNGQL $ Class.switchFloating (UNGQL S.orgql) (UNGQL D.orgql) (UNGQL C.ungql) (UNGQL Z.ungql)


newtype UNGQR a = UNGQR {getUNGQR :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

ungqr :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
ungqr = getUNGQR $ Class.switchFloating (UNGQR S.orgqr) (UNGQR D.orgqr) (UNGQR C.ungqr) (UNGQR Z.ungqr)


newtype UNGR2 a = UNGR2 {getUNGR2 :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

ungr2 :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
ungr2 = getUNGR2 $ Class.switchFloating (UNGR2 S.orgr2) (UNGR2 D.orgr2) (UNGR2 C.ungr2) (UNGR2 Z.ungr2)


newtype UNGRQ a = UNGRQ {getUNGRQ :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

ungrq :: Class.Floating a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
ungrq = getUNGRQ $ Class.switchFloating (UNGRQ S.orgrq) (UNGRQ D.orgrq) (UNGRQ C.ungrq) (UNGRQ Z.ungrq)


newtype UNGTR a = UNGTR {getUNGTR :: Char -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

ungtr :: Class.Floating a => Char -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
ungtr = getUNGTR $ Class.switchFloating (UNGTR S.orgtr) (UNGTR D.orgtr) (UNGTR C.ungtr) (UNGTR Z.ungtr)


newtype UNM2L a = UNM2L {getUNM2L :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unm2l :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unm2l = getUNM2L $ Class.switchFloating (UNM2L S.orm2l) (UNM2L D.orm2l) (UNM2L C.unm2l) (UNM2L Z.unm2l)


newtype UNM2R a = UNM2R {getUNM2R :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unm2r :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unm2r = getUNM2R $ Class.switchFloating (UNM2R S.orm2r) (UNM2R D.orm2r) (UNM2R C.unm2r) (UNM2R Z.unm2r)


newtype UNMBR a = UNMBR {getUNMBR :: Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmbr :: Class.Floating a => Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmbr = getUNMBR $ Class.switchFloating (UNMBR S.ormbr) (UNMBR D.ormbr) (UNMBR C.unmbr) (UNMBR Z.unmbr)


newtype UNMHR a = UNMHR {getUNMHR :: Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmhr :: Class.Floating a => Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmhr = getUNMHR $ Class.switchFloating (UNMHR S.ormhr) (UNMHR D.ormhr) (UNMHR C.unmhr) (UNMHR Z.unmhr)


newtype UNML2 a = UNML2 {getUNML2 :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unml2 :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unml2 = getUNML2 $ Class.switchFloating (UNML2 S.orml2) (UNML2 D.orml2) (UNML2 C.unml2) (UNML2 Z.unml2)


newtype UNMLQ a = UNMLQ {getUNMLQ :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmlq :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmlq = getUNMLQ $ Class.switchFloating (UNMLQ S.ormlq) (UNMLQ D.ormlq) (UNMLQ C.unmlq) (UNMLQ Z.unmlq)


newtype UNMQL a = UNMQL {getUNMQL :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmql :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmql = getUNMQL $ Class.switchFloating (UNMQL S.ormql) (UNMQL D.ormql) (UNMQL C.unmql) (UNMQL Z.unmql)


newtype UNMQR a = UNMQR {getUNMQR :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmqr :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmqr = getUNMQR $ Class.switchFloating (UNMQR S.ormqr) (UNMQR D.ormqr) (UNMQR C.unmqr) (UNMQR Z.unmqr)


newtype UNMR2 a = UNMR2 {getUNMR2 :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmr2 :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmr2 = getUNMR2 $ Class.switchFloating (UNMR2 S.ormr2) (UNMR2 D.ormr2) (UNMR2 C.unmr2) (UNMR2 Z.unmr2)


newtype UNMR3 a = UNMR3 {getUNMR3 :: Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmr3 :: Class.Floating a => Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmr3 = getUNMR3 $ Class.switchFloating (UNMR3 S.ormr3) (UNMR3 D.ormr3) (UNMR3 C.unmr3) (UNMR3 Z.unmr3)


newtype UNMRQ a = UNMRQ {getUNMRQ :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmrq :: Class.Floating a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmrq = getUNMRQ $ Class.switchFloating (UNMRQ S.ormrq) (UNMRQ D.ormrq) (UNMRQ C.unmrq) (UNMRQ Z.unmrq)


newtype UNMRZ a = UNMRZ {getUNMRZ :: Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmrz :: Class.Floating a => Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmrz = getUNMRZ $ Class.switchFloating (UNMRZ S.ormrz) (UNMRZ D.ormrz) (UNMRZ C.unmrz) (UNMRZ Z.unmrz)


newtype UNMTR a = UNMTR {getUNMTR :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

unmtr :: Class.Floating a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
unmtr = getUNMTR $ Class.switchFloating (UNMTR S.ormtr) (UNMTR D.ormtr) (UNMTR C.unmtr) (UNMTR Z.unmtr)


newtype UPGTR a = UPGTR {getUPGTR :: Char -> Int -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

upgtr :: Class.Floating a => Char -> Int -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
upgtr = getUPGTR $ Class.switchFloating (UPGTR S.opgtr) (UPGTR D.opgtr) (UPGTR C.upgtr) (UPGTR Z.upgtr)


newtype UPMTR a = UPMTR {getUPMTR :: Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

upmtr :: Class.Floating a => Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
upmtr = getUPMTR $ Class.switchFloating (UPMTR S.opmtr) (UPMTR D.opmtr) (UPMTR C.upmtr) (UPMTR Z.upmtr)
