-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.CArray.Complex (
   bbcsd,
   bdsqr,
   gbbrd,
   gbcon,
   gbequ,
   gbequb,
   gbrfs,
   gbsv,
   gbsvx,
   gbtf2,
   gbtrf,
   gbtrs,
   gebak,
   gebal,
   gebd2,
   gebrd,
   gecon,
   geequ,
   geequb,
   gees,
   geesx,
   geev,
   geevx,
   gehd2,
   gehrd,
   gelq2,
   gelqf,
   gels,
   gelsd,
   gelss,
   gelsy,
   geql2,
   geqlf,
   geqp3,
   geqr2,
   geqr2p,
   geqrf,
   geqrfp,
   gerfs,
   gerq2,
   gerqf,
   gesc2,
   gesdd,
   gesv,
   gesvd,
   gesvx,
   getc2,
   getf2,
   getrf,
   getri,
   getrs,
   ggbak,
   ggbal,
   gges,
   ggesx,
   ggev,
   ggevx,
   ggglm,
   gghrd,
   gglse,
   ggqrf,
   ggrqf,
   gtcon,
   gtrfs,
   gtsv,
   gtsvx,
   gttrf,
   gttrs,
   gtts2,
   hbev,
   hbevd,
   hbevx,
   hbgst,
   hbgv,
   hbgvd,
   hbgvx,
   hbtrd,
   hecon,
   heequb,
   heev,
   heevd,
   heevr,
   heevx,
   hegs2,
   hegst,
   hegv,
   hegvd,
   hegvx,
   herfs,
   hesv,
   hesvx,
   heswapr,
   hetd2,
   hetf2,
   hetrd,
   hetrf,
   hetri,
   hetri2,
   hetri2x,
   hetrs,
   hetrs2,
   hfrk,
   hgeqz,
   hpcon,
   hpev,
   hpevd,
   hpevx,
   hpgst,
   hpgv,
   hpgvd,
   hpgvx,
   hprfs,
   hpsv,
   hpsvx,
   hptrd,
   hptrf,
   hptri,
   hptrs,
   hsein,
   hseqr,
   ilalc,
   ilalr,
   imax1,
   labrd,
   lacgv,
   lacn2,
   lacon,
   lacp2,
   lacpy,
   lacrm,
   lacrt,
   laed0,
   laed7,
   laed8,
   laein,
   laesy,
   laev2,
   lags2,
   lagtm,
   lahef,
   lahqr,
   lahr2,
   laic1,
   lals0,
   lalsa,
   lalsd,
   langb,
   lange,
   langt,
   lanhb,
   lanhe,
   lanhf,
   lanhp,
   lanhs,
   lanht,
   lansb,
   lansp,
   lansy,
   lantb,
   lantp,
   lantr,
   lapll,
   lapmr,
   lapmt,
   laqgb,
   laqge,
   laqhb,
   laqhe,
   laqhp,
   laqp2,
   laqps,
   laqr0,
   laqr1,
   laqr2,
   laqr3,
   laqr4,
   laqr5,
   laqsb,
   laqsp,
   laqsy,
   lar1v,
   lar2v,
   larcm,
   larf,
   larfb,
   larfg,
   larfgp,
   larft,
   larfx,
   largv,
   larnv,
   larrv,
   lartg,
   lartv,
   larz,
   larzb,
   larzt,
   lascl,
   laset,
   lasr,
   lassq,
   laswp,
   lasyf,
   latbs,
   latdf,
   latps,
   latrd,
   latrs,
   latrz,
   lauu2,
   lauum,
   pbcon,
   pbequ,
   pbrfs,
   pbstf,
   pbsv,
   pbsvx,
   pbtf2,
   pbtrf,
   pbtrs,
   pftrf,
   pftri,
   pftrs,
   pocon,
   poequ,
   poequb,
   porfs,
   posv,
   posvx,
   potf2,
   potrf,
   potri,
   potrs,
   ppcon,
   ppequ,
   pprfs,
   ppsv,
   ppsvx,
   pptrf,
   pptri,
   pptrs,
   pstf2,
   pstrf,
   ptcon,
   pteqr,
   ptrfs,
   ptsv,
   ptsvx,
   pttrf,
   pttrs,
   ptts2,
   rot,
   rscl,
   spcon,
   spmv,
   spr,
   sprfs,
   spsv,
   spsvx,
   sptrf,
   sptri,
   sptrs,
   stedc,
   stegr,
   stein,
   stemr,
   steqr,
   sum1,
   sycon,
   syconv,
   syequb,
   symv,
   syr,
   syrfs,
   sysv,
   sysvx,
   syswapr,
   sytf2,
   sytrf,
   sytri,
   sytri2,
   sytri2x,
   sytrs,
   sytrs2,
   tbcon,
   tbrfs,
   tbtrs,
   tfsm,
   tftri,
   tfttp,
   tfttr,
   tgevc,
   tgex2,
   tgexc,
   tgsen,
   tgsja,
   tgsna,
   tgsy2,
   tgsyl,
   tpcon,
   tprfs,
   tptri,
   tptrs,
   tpttf,
   tpttr,
   trcon,
   trevc,
   trexc,
   trrfs,
   trsen,
   trsna,
   trsyl,
   trti2,
   trtri,
   trtrs,
   trttf,
   trttp,
   tzrzf,
   unbdb,
   uncsd,
   ung2l,
   ung2r,
   ungbr,
   unghr,
   ungl2,
   unglq,
   ungql,
   ungqr,
   ungr2,
   ungrq,
   ungtr,
   unm2l,
   unm2r,
   unmbr,
   unmhr,
   unml2,
   unmlq,
   unmql,
   unmqr,
   unmr2,
   unmr3,
   unmrq,
   unmrz,
   unmtr,
   upgtr,
   upmtr,
   ) where

import qualified Numeric.LAPACK.CArray.ComplexDouble as Z
import qualified Numeric.LAPACK.CArray.ComplexFloat as C
import qualified Numeric.Netlib.Class as Class

import Data.Complex (Complex)

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.C.Types (CInt)



newtype BBCSD a = BBCSD {getBBCSD :: Char -> Char -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)}

bbcsd :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)
bbcsd = getBBCSD $ Class.switchReal (BBCSD C.bbcsd) (BBCSD Z.bbcsd)


newtype BDSQR a = BDSQR {getBDSQR :: Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

bdsqr :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
bdsqr = getBDSQR $ Class.switchReal (BDSQR C.bdsqr) (BDSQR Z.bdsqr)


newtype GBBRD a = GBBRD {getGBBRD :: Char -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

gbbrd :: Class.Real a => Char -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
gbbrd = getGBBRD $ Class.switchReal (GBBRD C.gbbrd) (GBBRD Z.gbbrd)


newtype GBCON a = GBCON {getGBCON :: Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

gbcon :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
gbcon = getGBCON $ Class.switchReal (GBCON C.gbcon) (GBCON Z.gbcon)


newtype GBEQU a = GBEQU {getGBEQU :: Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

gbequ :: Class.Real a => Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)
gbequ = getGBEQU $ Class.switchReal (GBEQU C.gbequ) (GBEQU Z.gbequ)


newtype GBEQUB a = GBEQUB {getGBEQUB :: Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

gbequb :: Class.Real a => Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)
gbequb = getGBEQUB $ Class.switchReal (GBEQUB C.gbequb) (GBEQUB Z.gbequb)


newtype GBRFS a = GBRFS {getGBRFS :: Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

gbrfs :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
gbrfs = getGBRFS $ Class.switchReal (GBRFS C.gbrfs) (GBRFS Z.gbrfs)


newtype GBSV a = GBSV {getGBSV :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

gbsv :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
gbsv = getGBSV $ Class.switchReal (GBSV C.gbsv) (GBSV Z.gbsv)


newtype GBSVX a = GBSVX {getGBSVX :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

gbsvx :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
gbsvx = getGBSVX $ Class.switchReal (GBSVX C.gbsvx) (GBSVX Z.gbsvx)


newtype GBTF2 a = GBTF2 {getGBTF2 :: Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

gbtf2 :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
gbtf2 = getGBTF2 $ Class.switchReal (GBTF2 C.gbtf2) (GBTF2 Z.gbtf2)


newtype GBTRF a = GBTRF {getGBTRF :: Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

gbtrf :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
gbtrf = getGBTRF $ Class.switchReal (GBTRF C.gbtrf) (GBTRF Z.gbtrf)


newtype GBTRS a = GBTRS {getGBTRS :: Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

gbtrs :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
gbtrs = getGBTRS $ Class.switchReal (GBTRS C.gbtrs) (GBTRS Z.gbtrs)


newtype GEBAK a = GEBAK {getGEBAK :: Char -> Char -> Int -> Int -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

gebak :: Class.Real a => Char -> Char -> Int -> Int -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)
gebak = getGEBAK $ Class.switchReal (GEBAK C.gebak) (GEBAK Z.gebak)


newtype GEBAL a = GEBAL {getGEBAL :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int, CArray Int a, Int)}

gebal :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int, CArray Int a, Int)
gebal = getGEBAL $ Class.switchReal (GEBAL C.gebal) (GEBAL Z.gebal)


newtype GEBD2 a = GEBD2 {getGEBD2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), Int)}

gebd2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), Int)
gebd2 = getGEBD2 $ Class.switchReal (GEBD2 C.gebd2) (GEBD2 Z.gebd2)


newtype GEBRD a = GEBRD {getGEBRD :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), Int)}

gebrd :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), Int)
gebrd = getGEBRD $ Class.switchReal (GEBRD C.gebrd) (GEBRD Z.gebrd)


newtype GECON a = GECON {getGECON :: Char -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)}

gecon :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)
gecon = getGECON $ Class.switchReal (GECON C.gecon) (GECON Z.gecon)


newtype GEEQU a = GEEQU {getGEEQU :: Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

geequ :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)
geequ = getGEEQU $ Class.switchReal (GEEQU C.geequ) (GEEQU Z.geequ)


newtype GEEQUB a = GEEQUB {getGEEQUB :: Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

geequb :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, a, a, a, Int)
geequb = getGEEQUB $ Class.switchReal (GEEQUB C.geequb) (GEEQUB Z.geequb)


newtype GEES a = GEES {getGEES :: Char -> Char -> FunPtr (Ptr (Complex a) -> IO Bool) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), Int)}

gees :: Class.Real a => Char -> Char -> FunPtr (Ptr (Complex a) -> IO Bool) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), Int)
gees = getGEES $ Class.switchReal (GEES C.gees) (GEES Z.gees)


newtype GEESX a = GEESX {getGEESX :: Char -> Char -> FunPtr (Ptr (Complex a) -> IO Bool) -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), a, a, Int)}

geesx :: Class.Real a => Char -> Char -> FunPtr (Ptr (Complex a) -> IO Bool) -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), a, a, Int)
geesx = getGEESX $ Class.switchReal (GEESX C.geesx) (GEESX Z.geesx)


newtype GEEV a = GEEV {getGEEV :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

geev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
geev = getGEEV $ Class.switchReal (GEEV C.geev) (GEEV Z.geev)


newtype GEEVX a = GEEVX {getGEEVX :: Char -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int, Int, CArray Int a, a, CArray Int a, CArray Int a, Int)}

geevx :: Class.Real a => Char -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int, Int, CArray Int a, a, CArray Int a, CArray Int a, Int)
geevx = getGEEVX $ Class.switchReal (GEEVX C.geevx) (GEEVX Z.geevx)


newtype GEHD2 a = GEHD2 {getGEHD2 :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

gehd2 :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
gehd2 = getGEHD2 $ Class.switchReal (GEHD2 C.gehd2) (GEHD2 Z.gehd2)


newtype GEHRD a = GEHRD {getGEHRD :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

gehrd :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
gehrd = getGEHRD $ Class.switchReal (GEHRD C.gehrd) (GEHRD Z.gehrd)


newtype GELQ2 a = GELQ2 {getGELQ2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

gelq2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
gelq2 = getGELQ2 $ Class.switchReal (GELQ2 C.gelq2) (GELQ2 Z.gelq2)


newtype GELQF a = GELQF {getGELQF :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

gelqf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
gelqf = getGELQF $ Class.switchReal (GELQF C.gelqf) (GELQF Z.gelqf)


newtype GELS a = GELS {getGELS :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

gels :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
gels = getGELS $ Class.switchReal (GELS C.gels) (GELS Z.gels)


newtype GELSD a = GELSD {getGELSD :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> Int -> Int -> Int -> IO (CArray Int a, Int, Int)}

gelsd :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> Int -> Int -> Int -> IO (CArray Int a, Int, Int)
gelsd = getGELSD $ Class.switchReal (GELSD C.gelsd) (GELSD Z.gelsd)


newtype GELSS a = GELSS {getGELSS :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> Int -> IO (CArray Int a, Int, Int)}

gelss :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> Int -> IO (CArray Int a, Int, Int)
gelss = getGELSS $ Class.switchReal (GELSS C.gelss) (GELSS Z.gelss)


newtype GELSY a = GELSY {getGELSY :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> a -> Int -> IO (Int, Int)}

gelsy :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> a -> Int -> IO (Int, Int)
gelsy = getGELSY $ Class.switchReal (GELSY C.gelsy) (GELSY Z.gelsy)


newtype GEQL2 a = GEQL2 {getGEQL2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

geql2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
geql2 = getGEQL2 $ Class.switchReal (GEQL2 C.geql2) (GEQL2 Z.geql2)


newtype GEQLF a = GEQLF {getGEQLF :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

geqlf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
geqlf = getGEQLF $ Class.switchReal (GEQLF C.geqlf) (GEQLF Z.geqlf)


newtype GEQP3 a = GEQP3 {getGEQP3 :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Int -> IO (CArray Int (Complex a), Int)}

geqp3 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Int -> IO (CArray Int (Complex a), Int)
geqp3 = getGEQP3 $ Class.switchReal (GEQP3 C.geqp3) (GEQP3 Z.geqp3)


newtype GEQR2 a = GEQR2 {getGEQR2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

geqr2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
geqr2 = getGEQR2 $ Class.switchReal (GEQR2 C.geqr2) (GEQR2 Z.geqr2)


newtype GEQR2P a = GEQR2P {getGEQR2P :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

geqr2p :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
geqr2p = getGEQR2P $ Class.switchReal (GEQR2P C.geqr2p) (GEQR2P Z.geqr2p)


newtype GEQRF a = GEQRF {getGEQRF :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

geqrf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
geqrf = getGEQRF $ Class.switchReal (GEQRF C.geqrf) (GEQRF Z.geqrf)


newtype GEQRFP a = GEQRFP {getGEQRFP :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

geqrfp :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
geqrfp = getGEQRFP $ Class.switchReal (GEQRFP C.geqrfp) (GEQRFP Z.geqrfp)


newtype GERFS a = GERFS {getGERFS :: Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

gerfs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
gerfs = getGERFS $ Class.switchReal (GERFS C.gerfs) (GERFS Z.gerfs)


newtype GERQ2 a = GERQ2 {getGERQ2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

gerq2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
gerq2 = getGERQ2 $ Class.switchReal (GERQ2 C.gerq2) (GERQ2 Z.gerq2)


newtype GERQF a = GERQF {getGERQF :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

gerqf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
gerqf = getGERQF $ Class.switchReal (GERQF C.gerqf) (GERQF Z.gerqf)


newtype GESC2 a = GESC2 {getGESC2 :: CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> CArray Int CInt -> CArray Int CInt -> IO (a)}

gesc2 :: Class.Real a => CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> CArray Int CInt -> CArray Int CInt -> IO (a)
gesc2 = getGESC2 $ Class.switchReal (GESC2 C.gesc2) (GESC2 Z.gesc2)


newtype GESDD a = GESDD {getGESDD :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

gesdd :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
gesdd = getGESDD $ Class.switchReal (GESDD C.gesdd) (GESDD Z.gesdd)


newtype GESV a = GESV {getGESV :: IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

gesv :: Class.Real a => IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
gesv = getGESV $ Class.switchReal (GESV C.gesv) (GESV Z.gesv)


newtype GESVD a = GESVD {getGESVD :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

gesvd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
gesvd = getGESVD $ Class.switchReal (GESVD C.gesvd) (GESVD Z.gesvd)


newtype GESVX a = GESVX {getGESVX :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

gesvx :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
gesvx = getGESVX $ Class.switchReal (GESVX C.gesvx) (GESVX Z.gesvx)


newtype GETC2 a = GETC2 {getGETC2 :: IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, CArray Int CInt, Int)}

getc2 :: Class.Real a => IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, CArray Int CInt, Int)
getc2 = getGETC2 $ Class.switchReal (GETC2 C.getc2) (GETC2 Z.getc2)


newtype GETF2 a = GETF2 {getGETF2 :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

getf2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
getf2 = getGETF2 $ Class.switchReal (GETF2 C.getf2) (GETF2 Z.getf2)


newtype GETRF a = GETRF {getGETRF :: Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

getrf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
getrf = getGETRF $ Class.switchReal (GETRF C.getrf) (GETRF Z.getrf)


newtype GETRI a = GETRI {getGETRI :: IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)}

getri :: Class.Real a => IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)
getri = getGETRI $ Class.switchReal (GETRI C.getri) (GETRI Z.getri)


newtype GETRS a = GETRS {getGETRS :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

getrs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
getrs = getGETRS $ Class.switchReal (GETRS C.getrs) (GETRS Z.getrs)


newtype GGBAK a = GGBAK {getGGBAK :: Char -> Char -> Int -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

ggbak :: Class.Real a => Char -> Char -> Int -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)
ggbak = getGGBAK $ Class.switchReal (GGBAK C.ggbak) (GGBAK Z.ggbak)


newtype GGBAL a = GGBAL {getGGBAL :: Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, Int, CArray Int a, CArray Int a, Int)}

ggbal :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, Int, CArray Int a, CArray Int a, Int)
ggbal = getGGBAL $ Class.switchReal (GGBAL C.ggbal) (GGBAL Z.ggbal)


newtype GGES a = GGES {getGGES :: Char -> Char -> Char -> FunPtr (Ptr (Complex a) -> Ptr (Complex a) -> IO Bool) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

gges :: Class.Real a => Char -> Char -> Char -> FunPtr (Ptr (Complex a) -> Ptr (Complex a) -> IO Bool) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
gges = getGGES $ Class.switchReal (GGES C.gges) (GGES Z.gges)


newtype GGESX a = GGESX {getGGESX :: Char -> Char -> Char -> FunPtr (Ptr (Complex a) -> Ptr (Complex a) -> IO Bool) -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray Int a, CArray Int a, Int)}

ggesx :: Class.Real a => Char -> Char -> Char -> FunPtr (Ptr (Complex a) -> Ptr (Complex a) -> IO Bool) -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (Int, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray Int a, CArray Int a, Int)
ggesx = getGGESX $ Class.switchReal (GGESX C.ggesx) (GGESX Z.ggesx)


newtype GGEV a = GGEV {getGGEV :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

ggev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
ggev = getGGEV $ Class.switchReal (GGEV C.ggev) (GGEV Z.ggev)


newtype GGEVX a = GGEVX {getGGEVX :: Char -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int, Int, CArray Int a, CArray Int a, a, a, CArray Int a, CArray Int a, Int)}

ggevx :: Class.Real a => Char -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int, Int, CArray Int a, CArray Int a, a, a, CArray Int a, CArray Int a, Int)
ggevx = getGGEVX $ Class.switchReal (GGEVX C.ggevx) (GGEVX Z.ggevx)


newtype GGGLM a = GGGLM {getGGGLM :: IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)}

ggglm :: Class.Real a => IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)
ggglm = getGGGLM $ Class.switchReal (GGGLM C.ggglm) (GGGLM Z.ggglm)


newtype GGHRD a = GGHRD {getGGHRD :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

gghrd :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
gghrd = getGGHRD $ Class.switchReal (GGHRD C.gghrd) (GGHRD Z.gghrd)


newtype GGLSE a = GGLSE {getGGLSE :: IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

gglse :: Class.Real a => IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
gglse = getGGLSE $ Class.switchReal (GGLSE C.gglse) (GGLSE Z.gglse)


newtype GGQRF a = GGQRF {getGGQRF :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)}

ggqrf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)
ggqrf = getGGQRF $ Class.switchReal (GGQRF C.ggqrf) (GGQRF Z.ggqrf)


newtype GGRQF a = GGRQF {getGGRQF :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)}

ggrqf :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)
ggrqf = getGGRQF $ Class.switchReal (GGRQF C.ggrqf) (GGRQF Z.ggrqf)


newtype GTCON a = GTCON {getGTCON :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

gtcon :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
gtcon = getGTCON $ Class.switchReal (GTCON C.gtcon) (GTCON Z.gtcon)


newtype GTRFS a = GTRFS {getGTRFS :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

gtrfs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
gtrfs = getGTRFS $ Class.switchReal (GTRFS C.gtrfs) (GTRFS Z.gtrfs)


newtype GTSV a = GTSV {getGTSV :: IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

gtsv :: Class.Real a => IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
gtsv = getGTSV $ Class.switchReal (GTSV C.gtsv) (GTSV Z.gtsv)


newtype GTSVX a = GTSVX {getGTSVX :: Char -> Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

gtsvx :: Class.Real a => Char -> Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
gtsvx = getGTSVX $ Class.switchReal (GTSVX C.gtsvx) (GTSVX Z.gtsvx)


newtype GTTRF a = GTTRF {getGTTRF :: IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IO (CArray Int (Complex a), CArray Int CInt, Int)}

gttrf :: Class.Real a => IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IO (CArray Int (Complex a), CArray Int CInt, Int)
gttrf = getGTTRF $ Class.switchReal (GTTRF C.gttrf) (GTTRF Z.gttrf)


newtype GTTRS a = GTTRS {getGTTRS :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

gttrs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
gttrs = getGTTRS $ Class.switchReal (GTTRS C.gttrs) (GTTRS Z.gttrs)


newtype GTTS2 a = GTTS2 {getGTTS2 :: Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO ()}

gtts2 :: Class.Real a => Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO ()
gtts2 = getGTTS2 $ Class.switchReal (GTTS2 C.gtts2) (GTTS2 Z.gtts2)


newtype HBEV a = HBEV {getHBEV :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hbev :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hbev = getHBEV $ Class.switchReal (HBEV C.hbev) (HBEV Z.hbev)


newtype HBEVD a = HBEVD {getHBEVD :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hbevd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hbevd = getHBEVD $ Class.switchReal (HBEVD C.hbevd) (HBEVD Z.hbevd)


newtype HBEVX a = HBEVX {getHBEVX :: Char -> Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) (Complex a), Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

hbevx :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) (Complex a), Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
hbevx = getHBEVX $ Class.switchReal (HBEVX C.hbevx) (HBEVX Z.hbevx)


newtype HBGST a = HBGST {getHBGST :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

hbgst :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)
hbgst = getHBGST $ Class.switchReal (HBGST C.hbgst) (HBGST Z.hbgst)


newtype HBGV a = HBGV {getHBGV :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hbgv :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hbgv = getHBGV $ Class.switchReal (HBGV C.hbgv) (HBGV Z.hbgv)


newtype HBGVD a = HBGVD {getHBGVD :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hbgvd :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hbgvd = getHBGVD $ Class.switchReal (HBGVD C.hbgvd) (HBGVD Z.hbgvd)


newtype HBGVX a = HBGVX {getHBGVX :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> a -> a -> Int -> Int -> a -> Int -> IO (CArray (Int,Int) (Complex a), Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

hbgvx :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> a -> a -> Int -> Int -> a -> Int -> IO (CArray (Int,Int) (Complex a), Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
hbgvx = getHBGVX $ Class.switchReal (HBGVX C.hbgvx) (HBGVX Z.hbgvx)


newtype HBTRD a = HBTRD {getHBTRD :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

hbtrd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
hbtrd = getHBTRD $ Class.switchReal (HBTRD C.hbtrd) (HBTRD Z.hbtrd)


newtype HECON a = HECON {getHECON :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

hecon :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
hecon = getHECON $ Class.switchReal (HECON C.hecon) (HECON Z.hecon)


newtype HEEQUB a = HEEQUB {getHEEQUB :: Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)}

heequb :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)
heequb = getHEEQUB $ Class.switchReal (HEEQUB C.heequb) (HEEQUB Z.heequb)


newtype HEEV a = HEEV {getHEEV :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, Int)}

heev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, Int)
heev = getHEEV $ Class.switchReal (HEEV C.heev) (HEEV Z.heev)


newtype HEEVD a = HEEVD {getHEEVD :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, Int)}

heevd :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, Int)
heevd = getHEEVD $ Class.switchReal (HEEVD C.heevd) (HEEVD Z.heevd)


newtype HEEVR a = HEEVR {getHEEVR :: Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

heevr :: Class.Real a => Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
heevr = getHEEVR $ Class.switchReal (HEEVR C.heevr) (HEEVR Z.heevr)


newtype HEEVX a = HEEVX {getHEEVX :: Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

heevx :: Class.Real a => Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
heevx = getHEEVX $ Class.switchReal (HEEVX C.heevx) (HEEVX Z.heevx)


newtype HEGS2 a = HEGS2 {getHEGS2 :: Int -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

hegs2 :: Class.Real a => Int -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
hegs2 = getHEGS2 $ Class.switchReal (HEGS2 C.hegs2) (HEGS2 Z.hegs2)


newtype HEGST a = HEGST {getHEGST :: Int -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

hegst :: Class.Real a => Int -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
hegst = getHEGST $ Class.switchReal (HEGST C.hegst) (HEGST Z.hegst)


newtype HEGV a = HEGV {getHEGV :: Int -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, Int)}

hegv :: Class.Real a => Int -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, Int)
hegv = getHEGV $ Class.switchReal (HEGV C.hegv) (HEGV Z.hegv)


newtype HEGVD a = HEGVD {getHEGVD :: Int -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int a, Int)}

hegvd :: Class.Real a => Int -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray Int a, Int)
hegvd = getHEGVD $ Class.switchReal (HEGVD C.hegvd) (HEGVD Z.hegvd)


newtype HEGVX a = HEGVX {getHEGVX :: Int -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

hegvx :: Class.Real a => Int -> Char -> Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
hegvx = getHEGVX $ Class.switchReal (HEGVX C.hegvx) (HEGVX Z.hegvx)


newtype HERFS a = HERFS {getHERFS :: Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

herfs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
herfs = getHERFS $ Class.switchReal (HERFS C.herfs) (HERFS Z.herfs)


newtype HESV a = HESV {getHESV :: Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)}

hesv :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)
hesv = getHESV $ Class.switchReal (HESV C.hesv) (HESV Z.hesv)


newtype HESVX a = HESVX {getHESVX :: Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

hesvx :: Class.Real a => Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
hesvx = getHESVX $ Class.switchReal (HESVX C.hesvx) (HESVX Z.hesvx)


newtype HESWAPR a = HESWAPR {getHESWAPR :: Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO ()}

heswapr :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO ()
heswapr = getHESWAPR $ Class.switchReal (HESWAPR C.heswapr) (HESWAPR Z.heswapr)


newtype HETD2 a = HETD2 {getHETD2 :: Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)}

hetd2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)
hetd2 = getHETD2 $ Class.switchReal (HETD2 C.hetd2) (HETD2 Z.hetd2)


newtype HETF2 a = HETF2 {getHETF2 :: Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

hetf2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
hetf2 = getHETF2 $ Class.switchReal (HETF2 C.hetf2) (HETF2 Z.hetf2)


newtype HETRD a = HETRD {getHETRD :: Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)}

hetrd :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)
hetrd = getHETRD $ Class.switchReal (HETRD C.hetrd) (HETRD Z.hetrd)


newtype HETRF a = HETRF {getHETRF :: Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)}

hetrf :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)
hetrf = getHETRF $ Class.switchReal (HETRF C.hetrf) (HETRF Z.hetrf)


newtype HETRI a = HETRI {getHETRI :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (Int)}

hetri :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (Int)
hetri = getHETRI $ Class.switchReal (HETRI C.hetri) (HETRI Z.hetri)


newtype HETRI2 a = HETRI2 {getHETRI2 :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> Int -> IO (Int)}

hetri2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> Int -> IO (Int)
hetri2 = getHETRI2 $ Class.switchReal (HETRI2 C.hetri2) (HETRI2 Z.hetri2)


newtype HETRI2X a = HETRI2X {getHETRI2X :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)}

hetri2x :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)
hetri2x = getHETRI2X $ Class.switchReal (HETRI2X C.hetri2x) (HETRI2X Z.hetri2x)


newtype HETRS a = HETRS {getHETRS :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

hetrs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
hetrs = getHETRS $ Class.switchReal (HETRS C.hetrs) (HETRS Z.hetrs)


newtype HETRS2 a = HETRS2 {getHETRS2 :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

hetrs2 :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
hetrs2 = getHETRS2 $ Class.switchReal (HETRS2 C.hetrs2) (HETRS2 Z.hetrs2)


newtype HFRK a = HFRK {getHFRK :: Char -> Char -> Char -> Int -> Int -> a -> CArray (Int,Int) (Complex a) -> a -> IOCArray Int (Complex a) -> IO ()}

hfrk :: Class.Real a => Char -> Char -> Char -> Int -> Int -> a -> CArray (Int,Int) (Complex a) -> a -> IOCArray Int (Complex a) -> IO ()
hfrk = getHFRK $ Class.switchReal (HFRK C.hfrk) (HFRK Z.hfrk)


newtype HGEQZ a = HGEQZ {getHGEQZ :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)}

hgeqz :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int)
hgeqz = getHGEQZ $ Class.switchReal (HGEQZ C.hgeqz) (HGEQZ Z.hgeqz)


newtype HPCON a = HPCON {getHPCON :: Char -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

hpcon :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
hpcon = getHPCON $ Class.switchReal (HPCON C.hpcon) (HPCON Z.hpcon)


newtype HPEV a = HPEV {getHPEV :: Char -> Char -> Int -> IOCArray Int (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hpev :: Class.Real a => Char -> Char -> Int -> IOCArray Int (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hpev = getHPEV $ Class.switchReal (HPEV C.hpev) (HPEV Z.hpev)


newtype HPEVD a = HPEVD {getHPEVD :: Char -> Char -> Int -> IOCArray Int (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hpevd :: Class.Real a => Char -> Char -> Int -> IOCArray Int (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hpevd = getHPEVD $ Class.switchReal (HPEVD C.hpevd) (HPEVD Z.hpevd)


newtype HPEVX a = HPEVX {getHPEVX :: Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

hpevx :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
hpevx = getHPEVX $ Class.switchReal (HPEVX C.hpevx) (HPEVX Z.hpevx)


newtype HPGST a = HPGST {getHPGST :: Int -> Char -> Int -> IOCArray Int (Complex a) -> CArray Int (Complex a) -> IO (Int)}

hpgst :: Class.Real a => Int -> Char -> Int -> IOCArray Int (Complex a) -> CArray Int (Complex a) -> IO (Int)
hpgst = getHPGST $ Class.switchReal (HPGST C.hpgst) (HPGST Z.hpgst)


newtype HPGV a = HPGV {getHPGV :: Int -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hpgv :: Class.Real a => Int -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hpgv = getHPGV $ Class.switchReal (HPGV C.hpgv) (HPGV Z.hpgv)


newtype HPGVD a = HPGVD {getHPGVD :: Int -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)}

hpgvd :: Class.Real a => Int -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), Int)
hpgvd = getHPGVD $ Class.switchReal (HPGVD C.hpgvd) (HPGVD Z.hpgvd)


newtype HPGVX a = HPGVX {getHPGVX :: Int -> Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> a -> a -> Int -> Int -> a -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

hpgvx :: Class.Real a => Int -> Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> a -> a -> Int -> Int -> a -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
hpgvx = getHPGVX $ Class.switchReal (HPGVX C.hpgvx) (HPGVX Z.hpgvx)


newtype HPRFS a = HPRFS {getHPRFS :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

hprfs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
hprfs = getHPRFS $ Class.switchReal (HPRFS C.hprfs) (HPRFS Z.hprfs)


newtype HPSV a = HPSV {getHPSV :: Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

hpsv :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
hpsv = getHPSV $ Class.switchReal (HPSV C.hpsv) (HPSV Z.hpsv)


newtype HPSVX a = HPSVX {getHPSVX :: Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

hpsvx :: Class.Real a => Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
hpsvx = getHPSVX $ Class.switchReal (HPSVX C.hpsvx) (HPSVX Z.hpsvx)


newtype HPTRD a = HPTRD {getHPTRD :: Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)}

hptrd :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), Int)
hptrd = getHPTRD $ Class.switchReal (HPTRD C.hptrd) (HPTRD Z.hptrd)


newtype HPTRF a = HPTRF {getHPTRF :: Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int CInt, Int)}

hptrf :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int CInt, Int)
hptrf = getHPTRF $ Class.switchReal (HPTRF C.hptrf) (HPTRF Z.hptrf)


newtype HPTRI a = HPTRI {getHPTRI :: Char -> IOCArray Int (Complex a) -> CArray Int CInt -> IO (Int)}

hptri :: Class.Real a => Char -> IOCArray Int (Complex a) -> CArray Int CInt -> IO (Int)
hptri = getHPTRI $ Class.switchReal (HPTRI C.hptri) (HPTRI Z.hptri)


newtype HPTRS a = HPTRS {getHPTRS :: Char -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

hptrs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
hptrs = getHPTRS $ Class.switchReal (HPTRS C.hptrs) (HPTRS Z.hptrs)


newtype HSEIN a = HSEIN {getHSEIN :: Char -> Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, CArray Int CInt, CArray Int CInt, Int)}

hsein :: Class.Real a => Char -> Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, CArray Int CInt, CArray Int CInt, Int)
hsein = getHSEIN $ Class.switchReal (HSEIN C.hsein) (HSEIN Z.hsein)


newtype HSEQR a = HSEQR {getHSEQR :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

hseqr :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
hseqr = getHSEQR $ Class.switchReal (HSEQR C.hseqr) (HSEQR Z.hseqr)


newtype ILALC a = ILALC {getILALC :: Int -> CArray (Int,Int) (Complex a) -> IO CInt}

ilalc :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> IO CInt
ilalc = getILALC $ Class.switchReal (ILALC C.ilalc) (ILALC Z.ilalc)


newtype ILALR a = ILALR {getILALR :: Int -> CArray (Int,Int) (Complex a) -> IO CInt}

ilalr :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> IO CInt
ilalr = getILALR $ Class.switchReal (ILALR C.ilalr) (ILALR Z.ilalr)


newtype IMAX1 a = IMAX1 {getIMAX1 :: CArray Int (Complex a) -> Int -> IO CInt}

imax1 :: Class.Real a => CArray Int (Complex a) -> Int -> IO CInt
imax1 = getIMAX1 $ Class.switchReal (IMAX1 C.imax1) (IMAX1 Z.imax1)


newtype LABRD a = LABRD {getLABRD :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))}

labrd :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))
labrd = getLABRD $ Class.switchReal (LABRD C.labrd) (LABRD Z.labrd)


newtype LACGV a = LACGV {getLACGV :: Int -> IOCArray Int (Complex a) -> Int -> IO ()}

lacgv :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IO ()
lacgv = getLACGV $ Class.switchReal (LACGV C.lacgv) (LACGV Z.lacgv)


newtype LACN2 a = LACN2 {getLACN2 :: IOCArray Int (Complex a) -> a -> Int -> IOCArray Int CInt -> IO (CArray Int (Complex a), a, Int)}

lacn2 :: Class.Real a => IOCArray Int (Complex a) -> a -> Int -> IOCArray Int CInt -> IO (CArray Int (Complex a), a, Int)
lacn2 = getLACN2 $ Class.switchReal (LACN2 C.lacn2) (LACN2 Z.lacn2)


newtype LACON a = LACON {getLACON :: IOCArray Int (Complex a) -> a -> Int -> IO (CArray Int (Complex a), a, Int)}

lacon :: Class.Real a => IOCArray Int (Complex a) -> a -> Int -> IO (CArray Int (Complex a), a, Int)
lacon = getLACON $ Class.switchReal (LACON C.lacon) (LACON Z.lacon)


newtype LACP2 a = LACP2 {getLACP2 :: Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) (Complex a))}

lacp2 :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) (Complex a))
lacp2 = getLACP2 $ Class.switchReal (LACP2 C.lacp2) (LACP2 Z.lacp2)


newtype LACPY a = LACPY {getLACPY :: Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))}

lacpy :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))
lacpy = getLACPY $ Class.switchReal (LACPY C.lacpy) (LACPY Z.lacpy)


newtype LACRM a = LACRM {getLACRM :: Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) (Complex a))}

lacrm :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) (Complex a))
lacrm = getLACRM $ Class.switchReal (LACRM C.lacrm) (LACRM Z.lacrm)


newtype LACRT a = LACRT {getLACRT :: IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> (Complex a) -> (Complex a) -> IO ()}

lacrt :: Class.Real a => IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> (Complex a) -> (Complex a) -> IO ()
lacrt = getLACRT $ Class.switchReal (LACRT C.lacrt) (LACRT Z.lacrt)


newtype LAED0 a = LAED0 {getLAED0 :: Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

laed0 :: Class.Real a => Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (CArray (Int,Int) (Complex a), Int)
laed0 = getLAED0 $ Class.switchReal (LAED0 C.laed0) (LAED0 Z.laed0)


newtype LAED7 a = LAED7 {getLAED7 :: Int -> Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> a -> IOCArray Int a -> IOCArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)}

laed7 :: Class.Real a => Int -> Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> a -> IOCArray Int a -> IOCArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)
laed7 = getLAED7 $ Class.switchReal (LAED7 C.laed7) (LAED7 Z.laed7)


newtype LAED8 a = LAED8 {getLAED8 :: Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int a -> a -> Int -> CArray Int a -> Int -> CArray Int CInt -> IO (Int, a, CArray Int a, CArray (Int,Int) (Complex a), CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, Int)}

laed8 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int a -> a -> Int -> CArray Int a -> Int -> CArray Int CInt -> IO (Int, a, CArray Int a, CArray (Int,Int) (Complex a), CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, Int)
laed8 = getLAED8 $ Class.switchReal (LAED8 C.laed8) (LAED8 Z.laed8)


newtype LAEIN a = LAEIN {getLAEIN :: Bool -> Bool -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray Int (Complex a) -> Int -> a -> a -> IO (CArray (Int,Int) (Complex a), Int)}

laein :: Class.Real a => Bool -> Bool -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray Int (Complex a) -> Int -> a -> a -> IO (CArray (Int,Int) (Complex a), Int)
laein = getLAEIN $ Class.switchReal (LAEIN C.laein) (LAEIN Z.laein)


newtype LAESY a = LAESY {getLAESY :: (Complex a) -> (Complex a) -> (Complex a) -> IO ((Complex a), (Complex a), (Complex a), (Complex a), (Complex a))}

laesy :: Class.Real a => (Complex a) -> (Complex a) -> (Complex a) -> IO ((Complex a), (Complex a), (Complex a), (Complex a), (Complex a))
laesy = getLAESY $ Class.switchReal (LAESY C.laesy) (LAESY Z.laesy)


newtype LAEV2 a = LAEV2 {getLAEV2 :: (Complex a) -> (Complex a) -> (Complex a) -> IO (a, a, a, (Complex a))}

laev2 :: Class.Real a => (Complex a) -> (Complex a) -> (Complex a) -> IO (a, a, a, (Complex a))
laev2 = getLAEV2 $ Class.switchReal (LAEV2 C.laev2) (LAEV2 Z.laev2)


newtype LAGS2 a = LAGS2 {getLAGS2 :: Bool -> a -> (Complex a) -> a -> a -> (Complex a) -> a -> IO (a, (Complex a), a, (Complex a), a, (Complex a))}

lags2 :: Class.Real a => Bool -> a -> (Complex a) -> a -> a -> (Complex a) -> a -> IO (a, (Complex a), a, (Complex a), a, (Complex a))
lags2 = getLAGS2 $ Class.switchReal (LAGS2 C.lags2) (LAGS2 Z.lags2)


newtype LAGTM a = LAGTM {getLAGTM :: Char -> a -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()}

lagtm :: Class.Real a => Char -> a -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()
lagtm = getLAGTM $ Class.switchReal (LAGTM C.lagtm) (LAGTM Z.lagtm)


newtype LAHEF a = LAHEF {getLAHEF :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) (Complex a), Int)}

lahef :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) (Complex a), Int)
lahef = getLAHEF $ Class.switchReal (LAHEF C.lahef) (LAHEF Z.lahef)


newtype LAHQR a = LAHQR {getLAHQR :: Bool -> Bool -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

lahqr :: Class.Real a => Bool -> Bool -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
lahqr = getLAHQR $ Class.switchReal (LAHQR C.lahqr) (LAHQR Z.lahqr)


newtype LAHR2 a = LAHR2 {getLAHR2 :: Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))}

lahr2 :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))
lahr2 = getLAHR2 $ Class.switchReal (LAHR2 C.lahr2) (LAHR2 Z.lahr2)


newtype LAIC1 a = LAIC1 {getLAIC1 :: Int -> CArray Int (Complex a) -> a -> CArray Int (Complex a) -> (Complex a) -> IO (a, (Complex a), (Complex a))}

laic1 :: Class.Real a => Int -> CArray Int (Complex a) -> a -> CArray Int (Complex a) -> (Complex a) -> IO (a, (Complex a), (Complex a))
laic1 = getLAIC1 $ Class.switchReal (LAIC1 C.laic1) (LAIC1 Z.laic1)


newtype LALS0 a = LALS0 {getLALS0 :: Int -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> CArray Int CInt -> Int -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int a -> CArray (Int,Int) a -> CArray Int a -> a -> a -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

lals0 :: Class.Real a => Int -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> CArray Int CInt -> Int -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int a -> CArray (Int,Int) a -> CArray Int a -> a -> a -> Int -> IO (CArray (Int,Int) (Complex a), Int)
lals0 = getLALS0 $ Class.switchReal (LALS0 C.lals0) (LALS0 Z.lals0)


newtype LALSA a = LALSA {getLALSA :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

lalsa :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) (Complex a), Int)
lalsa = getLALSA $ Class.switchReal (LALSA C.lalsa) (LALSA Z.lalsa)


newtype LALSD a = LALSD {getLALSD :: Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> a -> Int -> Int -> IO (Int, Int)}

lalsd :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> a -> Int -> Int -> IO (Int, Int)
lalsd = getLALSD $ Class.switchReal (LALSD C.lalsd) (LALSD Z.lalsd)


newtype LANGB a = LANGB {getLANGB :: Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

langb :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
langb = getLANGB $ Class.switchReal (LANGB C.langb) (LANGB Z.langb)


newtype LANGE a = LANGE {getLANGE :: Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lange :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
lange = getLANGE $ Class.switchReal (LANGE C.lange) (LANGE Z.lange)


newtype LANGT a = LANGT {getLANGT :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> IO a}

langt :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> IO a
langt = getLANGT $ Class.switchReal (LANGT C.langt) (LANGT Z.langt)


newtype LANHB a = LANHB {getLANHB :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lanhb :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
lanhb = getLANHB $ Class.switchReal (LANHB C.lanhb) (LANHB Z.lanhb)


newtype LANHE a = LANHE {getLANHE :: Char -> Char -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lanhe :: Class.Real a => Char -> Char -> CArray (Int,Int) (Complex a) -> Int -> IO a
lanhe = getLANHE $ Class.switchReal (LANHE C.lanhe) (LANHE Z.lanhe)


newtype LANHF a = LANHF {getLANHF :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a}

lanhf :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a
lanhf = getLANHF $ Class.switchReal (LANHF C.lanhf) (LANHF Z.lanhf)


newtype LANHP a = LANHP {getLANHP :: Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a}

lanhp :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a
lanhp = getLANHP $ Class.switchReal (LANHP C.lanhp) (LANHP Z.lanhp)


newtype LANHS a = LANHS {getLANHS :: Char -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lanhs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> Int -> IO a
lanhs = getLANHS $ Class.switchReal (LANHS C.lanhs) (LANHS Z.lanhs)


newtype LANHT a = LANHT {getLANHT :: Char -> CArray Int a -> CArray Int (Complex a) -> IO a}

lanht :: Class.Real a => Char -> CArray Int a -> CArray Int (Complex a) -> IO a
lanht = getLANHT $ Class.switchReal (LANHT C.lanht) (LANHT Z.lanht)


newtype LANSB a = LANSB {getLANSB :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lansb :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
lansb = getLANSB $ Class.switchReal (LANSB C.lansb) (LANSB Z.lansb)


newtype LANSP a = LANSP {getLANSP :: Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a}

lansp :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a
lansp = getLANSP $ Class.switchReal (LANSP C.lansp) (LANSP Z.lansp)


newtype LANSY a = LANSY {getLANSY :: Char -> Char -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lansy :: Class.Real a => Char -> Char -> CArray (Int,Int) (Complex a) -> Int -> IO a
lansy = getLANSY $ Class.switchReal (LANSY C.lansy) (LANSY Z.lansy)


newtype LANTB a = LANTB {getLANTB :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lantb :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
lantb = getLANTB $ Class.switchReal (LANTB C.lantb) (LANTB Z.lantb)


newtype LANTP a = LANTP {getLANTP :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a}

lantp :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO a
lantp = getLANTP $ Class.switchReal (LANTP C.lantp) (LANTP Z.lantp)


newtype LANTR a = LANTR {getLANTR :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a}

lantr :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> Int -> IO a
lantr = getLANTR $ Class.switchReal (LANTR C.lantr) (LANTR Z.lantr)


newtype LAPLL a = LAPLL {getLAPLL :: Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO (a)}

lapll :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO (a)
lapll = getLAPLL $ Class.switchReal (LAPLL C.lapll) (LAPLL Z.lapll)


newtype LAPMR a = LAPMR {getLAPMR :: Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IO ()}

lapmr :: Class.Real a => Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IO ()
lapmr = getLAPMR $ Class.switchReal (LAPMR C.lapmr) (LAPMR Z.lapmr)


newtype LAPMT a = LAPMT {getLAPMT :: Bool -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IO ()}

lapmt :: Class.Real a => Bool -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IO ()
lapmt = getLAPMT $ Class.switchReal (LAPMT C.lapmt) (LAPMT Z.lapmt)


newtype LAQGB a = LAQGB {getLAQGB :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)}

laqgb :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)
laqgb = getLAQGB $ Class.switchReal (LAQGB C.laqgb) (LAQGB Z.laqgb)


newtype LAQGE a = LAQGE {getLAQGE :: IOCArray (Int,Int) (Complex a) -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)}

laqge :: Class.Real a => IOCArray (Int,Int) (Complex a) -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)
laqge = getLAQGE $ Class.switchReal (LAQGE C.laqge) (LAQGE Z.laqge)


newtype LAQHB a = LAQHB {getLAQHB :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> a -> a -> IO (CArray Int a, Char)}

laqhb :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> a -> a -> IO (CArray Int a, Char)
laqhb = getLAQHB $ Class.switchReal (LAQHB C.laqhb) (LAQHB Z.laqhb)


newtype LAQHE a = LAQHE {getLAQHE :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)}

laqhe :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)
laqhe = getLAQHE $ Class.switchReal (LAQHE C.laqhe) (LAQHE Z.laqhe)


newtype LAQHP a = LAQHP {getLAQHP :: Char -> IOCArray Int (Complex a) -> CArray Int a -> a -> a -> IO (Char)}

laqhp :: Class.Real a => Char -> IOCArray Int (Complex a) -> CArray Int a -> a -> a -> IO (Char)
laqhp = getLAQHP $ Class.switchReal (LAQHP C.laqhp) (LAQHP Z.laqhp)


newtype LAQP2 a = LAQP2 {getLAQP2 :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int (Complex a))}

laqp2 :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int (Complex a))
laqp2 = getLAQP2 $ Class.switchReal (LAQP2 C.laqp2) (LAQP2 Z.laqp2)


newtype LAQPS a = LAQPS {getLAQPS :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, CArray Int (Complex a))}

laqps :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, CArray Int (Complex a))
laqps = getLAQPS $ Class.switchReal (LAQPS C.laqps) (LAQPS Z.laqps)


newtype LAQR0 a = LAQR0 {getLAQR0 :: Bool -> Bool -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), Int)}

laqr0 :: Class.Real a => Bool -> Bool -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), Int)
laqr0 = getLAQR0 $ Class.switchReal (LAQR0 C.laqr0) (LAQR0 Z.laqr0)


newtype LAQR1 a = LAQR1 {getLAQR1 :: CArray (Int,Int) (Complex a) -> (Complex a) -> (Complex a) -> IO (CArray Int (Complex a))}

laqr1 :: Class.Real a => CArray (Int,Int) (Complex a) -> (Complex a) -> (Complex a) -> IO (CArray Int (Complex a))
laqr1 = getLAQR1 $ Class.switchReal (LAQR1 C.laqr1) (LAQR1 Z.laqr1)


newtype LAQR2 a = LAQR2 {getLAQR2 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))}

laqr2 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))
laqr2 = getLAQR2 $ Class.switchReal (LAQR2 C.laqr2) (LAQR2 Z.laqr2)


newtype LAQR3 a = LAQR3 {getLAQR3 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))}

laqr3 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))
laqr3 = getLAQR3 $ Class.switchReal (LAQR3 C.laqr3) (LAQR3 Z.laqr3)


newtype LAQR4 a = LAQR4 {getLAQR4 :: Bool -> Bool -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), Int)}

laqr4 :: Class.Real a => Bool -> Bool -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), Int)
laqr4 = getLAQR4 $ Class.switchReal (LAQR4 C.laqr4) (LAQR4 Z.laqr4)


newtype LAQR5 a = LAQR5 {getLAQR5 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))}

laqr5 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a))
laqr5 = getLAQR5 $ Class.switchReal (LAQR5 C.laqr5) (LAQR5 Z.laqr5)


newtype LAQSB a = LAQSB {getLAQSB :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)}

laqsb :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)
laqsb = getLAQSB $ Class.switchReal (LAQSB C.laqsb) (LAQSB Z.laqsb)


newtype LAQSP a = LAQSP {getLAQSP :: Char -> IOCArray Int (Complex a) -> CArray Int a -> a -> a -> IO (Char)}

laqsp :: Class.Real a => Char -> IOCArray Int (Complex a) -> CArray Int a -> a -> a -> IO (Char)
laqsp = getLAQSP $ Class.switchReal (LAQSP C.laqsp) (LAQSP Z.laqsp)


newtype LAQSY a = LAQSY {getLAQSY :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)}

laqsy :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int a -> a -> a -> IO (Char)
laqsy = getLAQSY $ Class.switchReal (LAQSY C.laqsy) (LAQSY Z.laqsy)


newtype LAR1V a = LAR1V {getLAR1V :: Int -> Int -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> a -> IOCArray Int (Complex a) -> Bool -> Int -> IO (Int, a, a, Int, CArray Int CInt, a, a, a)}

lar1v :: Class.Real a => Int -> Int -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> a -> IOCArray Int (Complex a) -> Bool -> Int -> IO (Int, a, a, Int, CArray Int CInt, a, a, a)
lar1v = getLAR1V $ Class.switchReal (LAR1V C.lar1v) (LAR1V Z.lar1v)


newtype LAR2V a = LAR2V {getLAR2V :: Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> CArray Int a -> CArray Int (Complex a) -> Int -> IO ()}

lar2v :: Class.Real a => Int -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> CArray Int a -> CArray Int (Complex a) -> Int -> IO ()
lar2v = getLAR2V $ Class.switchReal (LAR2V C.lar2v) (LAR2V Z.lar2v)


newtype LARCM a = LARCM {getLARCM :: CArray (Int,Int) a -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))}

larcm :: Class.Real a => CArray (Int,Int) a -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))
larcm = getLARCM $ Class.switchReal (LARCM C.larcm) (LARCM Z.larcm)


newtype LARF a = LARF {getLARF :: Char -> Int -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()}

larf :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()
larf = getLARF $ Class.switchReal (LARF C.larf) (LARF Z.larf)


newtype LARFB a = LARFB {getLARFB :: Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()}

larfb :: Class.Real a => Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()
larfb = getLARFB $ Class.switchReal (LARFB C.larfb) (LARFB Z.larfb)


newtype LARFG a = LARFG {getLARFG :: Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ((Complex a), (Complex a))}

larfg :: Class.Real a => Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ((Complex a), (Complex a))
larfg = getLARFG $ Class.switchReal (LARFG C.larfg) (LARFG Z.larfg)


newtype LARFGP a = LARFGP {getLARFGP :: Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ((Complex a), (Complex a))}

larfgp :: Class.Real a => Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ((Complex a), (Complex a))
larfgp = getLARFGP $ Class.switchReal (LARFGP C.larfgp) (LARFGP Z.larfgp)


newtype LARFT a = LARFT {getLARFT :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))}

larft :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))
larft = getLARFT $ Class.switchReal (LARFT C.larft) (LARFT Z.larft)


newtype LARFX a = LARFX {getLARFX :: Char -> Int -> CArray Int (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()}

larfx :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()
larfx = getLARFX $ Class.switchReal (LARFX C.larfx) (LARFX Z.larfx)


newtype LARGV a = LARGV {getLARGV :: Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> Int -> IO (CArray Int a)}

largv :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> Int -> IO (CArray Int a)
largv = getLARGV $ Class.switchReal (LARGV C.largv) (LARGV Z.largv)


newtype LARNV a = LARNV {getLARNV :: Int -> IOCArray Int CInt -> Int -> IO (CArray Int (Complex a))}

larnv :: Class.Real a => Int -> IOCArray Int CInt -> Int -> IO (CArray Int (Complex a))
larnv = getLARNV $ Class.switchReal (LARNV C.larnv) (LARNV Z.larnv)


newtype LARRV a = LARRV {getLARRV :: a -> a -> IOCArray Int a -> IOCArray Int a -> a -> CArray Int CInt -> Int -> Int -> Int -> a -> a -> a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> CArray Int a -> Int -> IO (CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

larrv :: Class.Real a => a -> a -> IOCArray Int a -> IOCArray Int a -> a -> CArray Int CInt -> Int -> Int -> Int -> a -> a -> a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> CArray Int a -> Int -> IO (CArray (Int,Int) (Complex a), CArray Int CInt, Int)
larrv = getLARRV $ Class.switchReal (LARRV C.larrv) (LARRV Z.larrv)


newtype LARTG a = LARTG {getLARTG :: (Complex a) -> (Complex a) -> IO (a, (Complex a), (Complex a))}

lartg :: Class.Real a => (Complex a) -> (Complex a) -> IO (a, (Complex a), (Complex a))
lartg = getLARTG $ Class.switchReal (LARTG C.lartg) (LARTG Z.lartg)


newtype LARTV a = LARTV {getLARTV :: Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> CArray Int a -> CArray Int (Complex a) -> Int -> IO ()}

lartv :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> CArray Int a -> CArray Int (Complex a) -> Int -> IO ()
lartv = getLARTV $ Class.switchReal (LARTV C.lartv) (LARTV Z.lartv)


newtype LARZ a = LARZ {getLARZ :: Char -> Int -> Int -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()}

larz :: Class.Real a => Char -> Int -> Int -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()
larz = getLARZ $ Class.switchReal (LARZ C.larz) (LARZ Z.larz)


newtype LARZB a = LARZB {getLARZB :: Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()}

larzb :: Class.Real a => Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO ()
larzb = getLARZB $ Class.switchReal (LARZB C.larzb) (LARZB Z.larzb)


newtype LARZT a = LARZT {getLARZT :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))}

larzt :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))
larzt = getLARZT $ Class.switchReal (LARZT C.larzt) (LARZT Z.larzt)


newtype LASCL a = LASCL {getLASCL :: Char -> Int -> Int -> a -> a -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

lascl :: Class.Real a => Char -> Int -> Int -> a -> a -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)
lascl = getLASCL $ Class.switchReal (LASCL C.lascl) (LASCL Z.lascl)


newtype LASET a = LASET {getLASET :: Char -> Int -> Int -> (Complex a) -> (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))}

laset :: Class.Real a => Char -> Int -> Int -> (Complex a) -> (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a))
laset = getLASET $ Class.switchReal (LASET C.laset) (LASET Z.laset)


newtype LASR a = LASR {getLASR :: Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO ()}

lasr :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) (Complex a) -> IO ()
lasr = getLASR $ Class.switchReal (LASR C.lasr) (LASR Z.lasr)


newtype LASSQ a = LASSQ {getLASSQ :: CArray Int (Complex a) -> Int -> a -> a -> IO (a, a)}

lassq :: Class.Real a => CArray Int (Complex a) -> Int -> a -> a -> IO (a, a)
lassq = getLASSQ $ Class.switchReal (LASSQ C.lassq) (LASSQ Z.lassq)


newtype LASWP a = LASWP {getLASWP :: IOCArray (Int,Int) (Complex a) -> Int -> Int -> CArray Int CInt -> Int -> IO ()}

laswp :: Class.Real a => IOCArray (Int,Int) (Complex a) -> Int -> Int -> CArray Int CInt -> Int -> IO ()
laswp = getLASWP $ Class.switchReal (LASWP C.laswp) (LASWP Z.laswp)


newtype LASYF a = LASYF {getLASYF :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) (Complex a), Int)}

lasyf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) (Complex a), Int)
lasyf = getLASYF $ Class.switchReal (LASYF C.lasyf) (LASYF Z.lasyf)


newtype LATBS a = LATBS {getLATBS :: Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)}

latbs :: Class.Real a => Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)
latbs = getLATBS $ Class.switchReal (LATBS C.latbs) (LATBS Z.latbs)


newtype LATDF a = LATDF {getLATDF :: Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> a -> a -> CArray Int CInt -> CArray Int CInt -> IO (a, a)}

latdf :: Class.Real a => Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> a -> a -> CArray Int CInt -> CArray Int CInt -> IO (a, a)
latdf = getLATDF $ Class.switchReal (LATDF C.latdf) (LATDF Z.latdf)


newtype LATPS a = LATPS {getLATPS :: Char -> Char -> Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)}

latps :: Class.Real a => Char -> Char -> Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)
latps = getLATPS $ Class.switchReal (LATPS C.latps) (LATPS Z.latps)


newtype LATRD a = LATRD {getLATRD :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int (Complex a), CArray (Int,Int) (Complex a))}

latrd :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int (Complex a), CArray (Int,Int) (Complex a))
latrd = getLATRD $ Class.switchReal (LATRD C.latrd) (LATRD Z.latrd)


newtype LATRS a = LATRS {getLATRS :: Char -> Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)}

latrs :: Class.Real a => Char -> Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int a -> IO (a, Int)
latrs = getLATRS $ Class.switchReal (LATRS C.latrs) (LATRS Z.latrs)


newtype LATRZ a = LATRZ {getLATRZ :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a))}

latrz :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a))
latrz = getLATRZ $ Class.switchReal (LATRZ C.latrz) (LATRZ Z.latrz)


newtype LAUU2 a = LAUU2 {getLAUU2 :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

lauu2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
lauu2 = getLAUU2 $ Class.switchReal (LAUU2 C.lauu2) (LAUU2 Z.lauu2)


newtype LAUUM a = LAUUM {getLAUUM :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

lauum :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
lauum = getLAUUM $ Class.switchReal (LAUUM C.lauum) (LAUUM Z.lauum)


newtype PBCON a = PBCON {getPBCON :: Char -> Int -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)}

pbcon :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)
pbcon = getPBCON $ Class.switchReal (PBCON C.pbcon) (PBCON Z.pbcon)


newtype PBEQU a = PBEQU {getPBEQU :: Char -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)}

pbequ :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)
pbequ = getPBEQU $ Class.switchReal (PBEQU C.pbequ) (PBEQU Z.pbequ)


newtype PBRFS a = PBRFS {getPBRFS :: Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

pbrfs :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
pbrfs = getPBRFS $ Class.switchReal (PBRFS C.pbrfs) (PBRFS Z.pbrfs)


newtype PBSTF a = PBSTF {getPBSTF :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pbstf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pbstf = getPBSTF $ Class.switchReal (PBSTF C.pbstf) (PBSTF Z.pbstf)


newtype PBSV a = PBSV {getPBSV :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pbsv :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pbsv = getPBSV $ Class.switchReal (PBSV C.pbsv) (PBSV Z.pbsv)


newtype PBSVX a = PBSVX {getPBSVX :: Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

pbsvx :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
pbsvx = getPBSVX $ Class.switchReal (PBSVX C.pbsvx) (PBSVX Z.pbsvx)


newtype PBTF2 a = PBTF2 {getPBTF2 :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pbtf2 :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pbtf2 = getPBTF2 $ Class.switchReal (PBTF2 C.pbtf2) (PBTF2 Z.pbtf2)


newtype PBTRF a = PBTRF {getPBTRF :: Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pbtrf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pbtrf = getPBTRF $ Class.switchReal (PBTRF C.pbtrf) (PBTRF Z.pbtrf)


newtype PBTRS a = PBTRS {getPBTRS :: Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pbtrs :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pbtrs = getPBTRS $ Class.switchReal (PBTRS C.pbtrs) (PBTRS Z.pbtrs)


newtype PFTRF a = PFTRF {getPFTRF :: Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

pftrf :: Class.Real a => Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
pftrf = getPFTRF $ Class.switchReal (PFTRF C.pftrf) (PFTRF Z.pftrf)


newtype PFTRI a = PFTRI {getPFTRI :: Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

pftri :: Class.Real a => Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
pftri = getPFTRI $ Class.switchReal (PFTRI C.pftri) (PFTRI Z.pftri)


newtype PFTRS a = PFTRS {getPFTRS :: Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pftrs :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pftrs = getPFTRS $ Class.switchReal (PFTRS C.pftrs) (PFTRS Z.pftrs)


newtype POCON a = POCON {getPOCON :: Char -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)}

pocon :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> a -> IO (a, Int)
pocon = getPOCON $ Class.switchReal (POCON C.pocon) (POCON Z.pocon)


newtype POEQU a = POEQU {getPOEQU :: CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)}

poequ :: Class.Real a => CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)
poequ = getPOEQU $ Class.switchReal (POEQU C.poequ) (POEQU Z.poequ)


newtype POEQUB a = POEQUB {getPOEQUB :: CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)}

poequb :: Class.Real a => CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)
poequb = getPOEQUB $ Class.switchReal (POEQUB C.poequb) (POEQUB Z.poequb)


newtype PORFS a = PORFS {getPORFS :: Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

porfs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
porfs = getPORFS $ Class.switchReal (PORFS C.porfs) (PORFS Z.porfs)


newtype POSV a = POSV {getPOSV :: Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

posv :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
posv = getPOSV $ Class.switchReal (POSV C.posv) (POSV Z.posv)


newtype POSVX a = POSVX {getPOSVX :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

posvx :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
posvx = getPOSVX $ Class.switchReal (POSVX C.posvx) (POSVX Z.posvx)


newtype POTF2 a = POTF2 {getPOTF2 :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

potf2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
potf2 = getPOTF2 $ Class.switchReal (POTF2 C.potf2) (POTF2 Z.potf2)


newtype POTRF a = POTRF {getPOTRF :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

potrf :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
potrf = getPOTRF $ Class.switchReal (POTRF C.potrf) (POTRF Z.potrf)


newtype POTRI a = POTRI {getPOTRI :: Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

potri :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
potri = getPOTRI $ Class.switchReal (POTRI C.potri) (POTRI Z.potri)


newtype POTRS a = POTRS {getPOTRS :: Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

potrs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
potrs = getPOTRS $ Class.switchReal (POTRS C.potrs) (POTRS Z.potrs)


newtype PPCON a = PPCON {getPPCON :: Char -> Int -> CArray Int (Complex a) -> a -> IO (a, Int)}

ppcon :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> a -> IO (a, Int)
ppcon = getPPCON $ Class.switchReal (PPCON C.ppcon) (PPCON Z.ppcon)


newtype PPEQU a = PPEQU {getPPEQU :: Char -> Int -> CArray Int (Complex a) -> IO (CArray Int a, a, a, Int)}

ppequ :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> IO (CArray Int a, a, a, Int)
ppequ = getPPEQU $ Class.switchReal (PPEQU C.ppequ) (PPEQU Z.ppequ)


newtype PPRFS a = PPRFS {getPPRFS :: Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

pprfs :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
pprfs = getPPRFS $ Class.switchReal (PPRFS C.pprfs) (PPRFS Z.pprfs)


newtype PPSV a = PPSV {getPPSV :: Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

ppsv :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
ppsv = getPPSV $ Class.switchReal (PPSV C.ppsv) (PPSV Z.ppsv)


newtype PPSVX a = PPSVX {getPPSVX :: Char -> Char -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

ppsvx :: Class.Real a => Char -> Char -> IOCArray Int (Complex a) -> IOCArray Int (Complex a) -> Char -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Char, CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
ppsvx = getPPSVX $ Class.switchReal (PPSVX C.ppsvx) (PPSVX Z.ppsvx)


newtype PPTRF a = PPTRF {getPPTRF :: Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

pptrf :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
pptrf = getPPTRF $ Class.switchReal (PPTRF C.pptrf) (PPTRF Z.pptrf)


newtype PPTRI a = PPTRI {getPPTRI :: Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

pptri :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
pptri = getPPTRI $ Class.switchReal (PPTRI C.pptri) (PPTRI Z.pptri)


newtype PPTRS a = PPTRS {getPPTRS :: Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pptrs :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pptrs = getPPTRS $ Class.switchReal (PPTRS C.pptrs) (PPTRS Z.pptrs)


newtype PSTF2 a = PSTF2 {getPSTF2 :: Char -> IOCArray (Int,Int) (Complex a) -> a -> IO (CArray Int CInt, Int, Int)}

pstf2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> a -> IO (CArray Int CInt, Int, Int)
pstf2 = getPSTF2 $ Class.switchReal (PSTF2 C.pstf2) (PSTF2 Z.pstf2)


newtype PSTRF a = PSTRF {getPSTRF :: Char -> IOCArray (Int,Int) (Complex a) -> a -> IO (CArray Int CInt, Int, Int)}

pstrf :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> a -> IO (CArray Int CInt, Int, Int)
pstrf = getPSTRF $ Class.switchReal (PSTRF C.pstrf) (PSTRF Z.pstrf)


newtype PTCON a = PTCON {getPTCON :: CArray Int a -> CArray Int (Complex a) -> a -> IO (a, Int)}

ptcon :: Class.Real a => CArray Int a -> CArray Int (Complex a) -> a -> IO (a, Int)
ptcon = getPTCON $ Class.switchReal (PTCON C.ptcon) (PTCON Z.ptcon)


newtype PTEQR a = PTEQR {getPTEQR :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pteqr :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pteqr = getPTEQR $ Class.switchReal (PTEQR C.pteqr) (PTEQR Z.pteqr)


newtype PTRFS a = PTRFS {getPTRFS :: Char -> CArray Int a -> CArray Int (Complex a) -> CArray Int a -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

ptrfs :: Class.Real a => Char -> CArray Int a -> CArray Int (Complex a) -> CArray Int a -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
ptrfs = getPTRFS $ Class.switchReal (PTRFS C.ptrfs) (PTRFS Z.ptrfs)


newtype PTSV a = PTSV {getPTSV :: IOCArray Int a -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

ptsv :: Class.Real a => IOCArray Int a -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
ptsv = getPTSV $ Class.switchReal (PTSV C.ptsv) (PTSV Z.ptsv)


newtype PTSVX a = PTSVX {getPTSVX :: Char -> CArray Int a -> CArray Int (Complex a) -> IOCArray Int a -> IOCArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

ptsvx :: Class.Real a => Char -> CArray Int a -> CArray Int (Complex a) -> IOCArray Int a -> IOCArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
ptsvx = getPTSVX $ Class.switchReal (PTSVX C.ptsvx) (PTSVX Z.ptsvx)


newtype PTTRF a = PTTRF {getPTTRF :: IOCArray Int a -> IOCArray Int (Complex a) -> IO (Int)}

pttrf :: Class.Real a => IOCArray Int a -> IOCArray Int (Complex a) -> IO (Int)
pttrf = getPTTRF $ Class.switchReal (PTTRF C.pttrf) (PTTRF Z.pttrf)


newtype PTTRS a = PTTRS {getPTTRS :: Char -> CArray Int a -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

pttrs :: Class.Real a => Char -> CArray Int a -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
pttrs = getPTTRS $ Class.switchReal (PTTRS C.pttrs) (PTTRS Z.pttrs)


newtype PTTS2 a = PTTS2 {getPTTS2 :: Int -> CArray Int a -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

ptts2 :: Class.Real a => Int -> CArray Int a -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
ptts2 = getPTTS2 $ Class.switchReal (PTTS2 C.ptts2) (PTTS2 Z.ptts2)


newtype ROT a = ROT {getROT :: IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> a -> (Complex a) -> IO ()}

rot :: Class.Real a => IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> a -> (Complex a) -> IO ()
rot = getROT $ Class.switchReal (ROT C.rot) (ROT Z.rot)


newtype RSCL a = RSCL {getRSCL :: Int -> a -> IOCArray Int (Complex a) -> Int -> IO ()}

rscl :: Class.Real a => Int -> a -> IOCArray Int (Complex a) -> Int -> IO ()
rscl = getRSCL $ Class.switchReal (RSCL C.rscl) (RSCL Z.rscl)


newtype SPCON a = SPCON {getSPCON :: Char -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

spcon :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
spcon = getSPCON $ Class.switchReal (SPCON C.spcon) (SPCON Z.spcon)


newtype SPMV a = SPMV {getSPMV :: Char -> Int -> (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

spmv :: Class.Real a => Char -> Int -> (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
spmv = getSPMV $ Class.switchReal (SPMV C.spmv) (SPMV Z.spmv)


newtype SPR a = SPR {getSPR :: Char -> Int -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()}

spr :: Class.Real a => Char -> Int -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()
spr = getSPR $ Class.switchReal (SPR C.spr) (SPR Z.spr)


newtype SPRFS a = SPRFS {getSPRFS :: Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

sprfs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
sprfs = getSPRFS $ Class.switchReal (SPRFS C.sprfs) (SPRFS Z.sprfs)


newtype SPSV a = SPSV {getSPSV :: Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

spsv :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
spsv = getSPSV $ Class.switchReal (SPSV C.spsv) (SPSV Z.spsv)


newtype SPSVX a = SPSVX {getSPSVX :: Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

spsvx :: Class.Real a => Char -> Char -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
spsvx = getSPSVX $ Class.switchReal (SPSVX C.spsvx) (SPSVX Z.spsvx)


newtype SPTRF a = SPTRF {getSPTRF :: Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int CInt, Int)}

sptrf :: Class.Real a => Char -> Int -> IOCArray Int (Complex a) -> IO (CArray Int CInt, Int)
sptrf = getSPTRF $ Class.switchReal (SPTRF C.sptrf) (SPTRF Z.sptrf)


newtype SPTRI a = SPTRI {getSPTRI :: Char -> IOCArray Int (Complex a) -> CArray Int CInt -> IO (Int)}

sptri :: Class.Real a => Char -> IOCArray Int (Complex a) -> CArray Int CInt -> IO (Int)
sptri = getSPTRI $ Class.switchReal (SPTRI C.sptri) (SPTRI Z.sptri)


newtype SPTRS a = SPTRS {getSPTRS :: Char -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

sptrs :: Class.Real a => Char -> CArray Int (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
sptrs = getSPTRS $ Class.switchReal (SPTRS C.sptrs) (SPTRS Z.sptrs)


newtype STEDC a = STEDC {getSTEDC :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (Int)}

stedc :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> IO (Int)
stedc = getSTEDC $ Class.switchReal (STEDC C.stedc) (STEDC Z.stedc)


newtype STEGR a = STEGR {getSTEGR :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

stegr :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Int)
stegr = getSTEGR $ Class.switchReal (STEGR C.stegr) (STEGR Z.stegr)


newtype STEIN a = STEIN {getSTEIN :: CArray Int a -> CArray Int a -> Int -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> Int -> IO (CArray (Int,Int) (Complex a), CArray Int CInt, Int)}

stein :: Class.Real a => CArray Int a -> CArray Int a -> Int -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> Int -> IO (CArray (Int,Int) (Complex a), CArray Int CInt, Int)
stein = getSTEIN $ Class.switchReal (STEIN C.stein) (STEIN Z.stein)


newtype STEMR a = STEMR {getSTEMR :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Bool, Int)}

stemr :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) (Complex a), CArray Int CInt, Bool, Int)
stemr = getSTEMR $ Class.switchReal (STEMR C.stemr) (STEMR Z.stemr)


newtype STEQR a = STEQR {getSTEQR :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

steqr :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) (Complex a) -> IO (Int)
steqr = getSTEQR $ Class.switchReal (STEQR C.steqr) (STEQR Z.steqr)


newtype SUM1 a = SUM1 {getSUM1 :: CArray Int (Complex a) -> Int -> IO a}

sum1 :: Class.Real a => CArray Int (Complex a) -> Int -> IO a
sum1 = getSUM1 $ Class.switchReal (SUM1 C.sum1) (SUM1 Z.sum1)


newtype SYCON a = SYCON {getSYCON :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)}

sycon :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> a -> IO (a, Int)
sycon = getSYCON $ Class.switchReal (SYCON C.sycon) (SYCON Z.sycon)


newtype SYCONV a = SYCONV {getSYCONV :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (CArray Int (Complex a), Int)}

syconv :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (CArray Int (Complex a), Int)
syconv = getSYCONV $ Class.switchReal (SYCONV C.syconv) (SYCONV Z.syconv)


newtype SYEQUB a = SYEQUB {getSYEQUB :: Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)}

syequb :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, a, a, Int)
syequb = getSYEQUB $ Class.switchReal (SYEQUB C.syequb) (SYEQUB Z.syequb)


newtype SYMV a = SYMV {getSYMV :: Char -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

symv :: Class.Real a => Char -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
symv = getSYMV $ Class.switchReal (SYMV C.symv) (SYMV Z.symv)


newtype SYR a = SYR {getSYR :: Char -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()}

syr :: Class.Real a => Char -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()
syr = getSYR $ Class.switchReal (SYR C.syr) (SYR Z.syr)


newtype SYRFS a = SYRFS {getSYRFS :: Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

syrfs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
syrfs = getSYRFS $ Class.switchReal (SYRFS C.syrfs) (SYRFS Z.syrfs)


newtype SYSV a = SYSV {getSYSV :: Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)}

sysv :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)
sysv = getSYSV $ Class.switchReal (SYSV C.sysv) (SYSV Z.sysv)


newtype SYSVX a = SYSVX {getSYSVX :: Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)}

sysvx :: Class.Real a => Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray Int CInt -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray (Int,Int) (Complex a), a, CArray Int a, CArray Int a, Int)
sysvx = getSYSVX $ Class.switchReal (SYSVX C.sysvx) (SYSVX Z.sysvx)


newtype SYSWAPR a = SYSWAPR {getSYSWAPR :: Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO ()}

syswapr :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO ()
syswapr = getSYSWAPR $ Class.switchReal (SYSWAPR C.syswapr) (SYSWAPR Z.syswapr)


newtype SYTF2 a = SYTF2 {getSYTF2 :: Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)}

sytf2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int CInt, Int)
sytf2 = getSYTF2 $ Class.switchReal (SYTF2 C.sytf2) (SYTF2 Z.sytf2)


newtype SYTRF a = SYTRF {getSYTRF :: Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)}

sytrf :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int CInt, Int)
sytrf = getSYTRF $ Class.switchReal (SYTRF C.sytrf) (SYTRF Z.sytrf)


newtype SYTRI a = SYTRI {getSYTRI :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (Int)}

sytri :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IO (Int)
sytri = getSYTRI $ Class.switchReal (SYTRI C.sytri) (SYTRI Z.sytri)


newtype SYTRI2 a = SYTRI2 {getSYTRI2 :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> Int -> IO (Int)}

sytri2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> Int -> IO (Int)
sytri2 = getSYTRI2 $ Class.switchReal (SYTRI2 C.sytri2) (SYTRI2 Z.sytri2)


newtype SYTRI2X a = SYTRI2X {getSYTRI2X :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)}

sytri2x :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> Int -> IO (Int)
sytri2x = getSYTRI2X $ Class.switchReal (SYTRI2X C.sytri2x) (SYTRI2X Z.sytri2x)


newtype SYTRS a = SYTRS {getSYTRS :: Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

sytrs :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
sytrs = getSYTRS $ Class.switchReal (SYTRS C.sytrs) (SYTRS Z.sytrs)


newtype SYTRS2 a = SYTRS2 {getSYTRS2 :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

sytrs2 :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int CInt -> IOCArray (Int,Int) (Complex a) -> IO (Int)
sytrs2 = getSYTRS2 $ Class.switchReal (SYTRS2 C.sytrs2) (SYTRS2 Z.sytrs2)


newtype TBCON a = TBCON {getTBCON :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IO (a, Int)}

tbcon :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IO (a, Int)
tbcon = getTBCON $ Class.switchReal (TBCON C.tbcon) (TBCON Z.tbcon)


newtype TBRFS a = TBRFS {getTBRFS :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

tbrfs :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
tbrfs = getTBRFS $ Class.switchReal (TBRFS C.tbrfs) (TBRFS Z.tbrfs)


newtype TBTRS a = TBTRS {getTBTRS :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

tbtrs :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
tbtrs = getTBTRS $ Class.switchReal (TBTRS C.tbtrs) (TBTRS Z.tbtrs)


newtype TFSM a = TFSM {getTFSM :: Char -> Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

tfsm :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
tfsm = getTFSM $ Class.switchReal (TFSM C.tfsm) (TFSM Z.tfsm)


newtype TFTRI a = TFTRI {getTFTRI :: Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

tftri :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
tftri = getTFTRI $ Class.switchReal (TFTRI C.tftri) (TFTRI Z.tftri)


newtype TFTTP a = TFTTP {getTFTTP :: Char -> Char -> Int -> CArray Int (Complex a) -> IO (CArray Int (Complex a), Int)}

tfttp :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> IO (CArray Int (Complex a), Int)
tfttp = getTFTTP $ Class.switchReal (TFTTP C.tfttp) (TFTTP Z.tfttp)


newtype TFTTR a = TFTTR {getTFTTR :: Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

tfttr :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)
tfttr = getTFTTR $ Class.switchReal (TFTTR C.tfttr) (TFTTR Z.tfttr)


newtype TGEVC a = TGEVC {getTGEVC :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int)}

tgevc :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int)
tgevc = getTGEVC $ Class.switchReal (TGEVC C.tgevc) (TGEVC Z.tgevc)


newtype TGEX2 a = TGEX2 {getTGEX2 :: Bool -> Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

tgex2 :: Class.Real a => Bool -> Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
tgex2 = getTGEX2 $ Class.switchReal (TGEX2 C.tgex2) (TGEX2 Z.tgex2)


newtype TGEXC a = TGEXC {getTGEXC :: Bool -> Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, Int)}

tgexc :: Class.Real a => Bool -> Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int, Int)
tgexc = getTGEXC $ Class.switchReal (TGEXC C.tgexc) (TGEXC Z.tgexc)


newtype TGSEN a = TGSEN {getTGSEN :: Int -> Bool -> Bool -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int, a, a, CArray Int a, Int)}

tgsen :: Class.Real a => Int -> Bool -> Bool -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int (Complex a), CArray Int (Complex a), Int, a, a, CArray Int a, Int)
tgsen = getTGSEN $ Class.switchReal (TGSEN C.tgsen) (TGSEN Z.tgsen)


newtype TGSJA a = TGSJA {getTGSJA :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int, Int)}

tgsja :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int, Int)
tgsja = getTGSJA $ Class.switchReal (TGSJA C.tgsja) (TGSJA Z.tgsja)


newtype TGSNA a = TGSNA {getTGSNA :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)}

tgsna :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)
tgsna = getTGSNA $ Class.switchReal (TGSNA C.tgsna) (TGSNA Z.tgsna)


newtype TGSY2 a = TGSY2 {getTGSY2 :: Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> IO (a, a, a, Int)}

tgsy2 :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> a -> a -> IO (a, a, a, Int)
tgsy2 = getTGSY2 $ Class.switchReal (TGSY2 C.tgsy2) (TGSY2 Z.tgsy2)


newtype TGSYL a = TGSYL {getTGSYL :: Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (a, a, Int)}

tgsyl :: Class.Real a => Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (a, a, Int)
tgsyl = getTGSYL $ Class.switchReal (TGSYL C.tgsyl) (TGSYL Z.tgsyl)


newtype TPCON a = TPCON {getTPCON :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IO (a, Int)}

tpcon :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IO (a, Int)
tpcon = getTPCON $ Class.switchReal (TPCON C.tpcon) (TPCON Z.tpcon)


newtype TPRFS a = TPRFS {getTPRFS :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

tprfs :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
tprfs = getTPRFS $ Class.switchReal (TPRFS C.tprfs) (TPRFS Z.tprfs)


newtype TPTRI a = TPTRI {getTPTRI :: Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)}

tptri :: Class.Real a => Char -> Char -> Int -> IOCArray Int (Complex a) -> IO (Int)
tptri = getTPTRI $ Class.switchReal (TPTRI C.tptri) (TPTRI Z.tptri)


newtype TPTRS a = TPTRS {getTPTRS :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

tptrs :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
tptrs = getTPTRS $ Class.switchReal (TPTRS C.tptrs) (TPTRS Z.tptrs)


newtype TPTTF a = TPTTF {getTPTTF :: Char -> Char -> Int -> CArray Int (Complex a) -> IO (CArray Int (Complex a), Int)}

tpttf :: Class.Real a => Char -> Char -> Int -> CArray Int (Complex a) -> IO (CArray Int (Complex a), Int)
tpttf = getTPTTF $ Class.switchReal (TPTTF C.tpttf) (TPTTF Z.tpttf)


newtype TPTTR a = TPTTR {getTPTTR :: Char -> Int -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

tpttr :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)
tpttr = getTPTTR $ Class.switchReal (TPTTR C.tpttr) (TPTTR Z.tpttr)


newtype TRCON a = TRCON {getTRCON :: Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IO (a, Int)}

trcon :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IO (a, Int)
trcon = getTRCON $ Class.switchReal (TRCON C.trcon) (TRCON Z.trcon)


newtype TREVC a = TREVC {getTREVC :: Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int)}

trevc :: Class.Real a => Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int, Int)
trevc = getTREVC $ Class.switchReal (TREVC C.trevc) (TREVC Z.trevc)


newtype TREXC a = TREXC {getTREXC :: Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int)}

trexc :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> IO (Int)
trexc = getTREXC $ Class.switchReal (TREXC C.trexc) (TREXC Z.trexc)


newtype TRRFS a = TRRFS {getTRRFS :: Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)}

trrfs :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IO (CArray Int a, CArray Int a, Int)
trrfs = getTRRFS $ Class.switchReal (TRRFS C.trrfs) (TRRFS Z.trrfs)


newtype TRSEN a = TRSEN {getTRSEN :: Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int, a, a, Int)}

trsen :: Class.Real a => Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int, a, a, Int)
trsen = getTRSEN $ Class.switchReal (TRSEN C.trsen) (TRSEN Z.trsen)


newtype TRSNA a = TRSNA {getTRSNA :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)}

trsna :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)
trsna = getTRSNA $ Class.switchReal (TRSNA C.trsna) (TRSNA Z.trsna)


newtype TRSYL a = TRSYL {getTRSYL :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (a, Int)}

trsyl :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (a, Int)
trsyl = getTRSYL $ Class.switchReal (TRSYL C.trsyl) (TRSYL Z.trsyl)


newtype TRTI2 a = TRTI2 {getTRTI2 :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

trti2 :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
trti2 = getTRTI2 $ Class.switchReal (TRTI2 C.trti2) (TRTI2 Z.trti2)


newtype TRTRI a = TRTRI {getTRTRI :: Char -> Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

trtri :: Class.Real a => Char -> Char -> IOCArray (Int,Int) (Complex a) -> IO (Int)
trtri = getTRTRI $ Class.switchReal (TRTRI C.trtri) (TRTRI Z.trtri)


newtype TRTRS a = TRTRS {getTRTRS :: Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)}

trtrs :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO (Int)
trtrs = getTRTRS $ Class.switchReal (TRTRS C.trtrs) (TRTRS Z.trtrs)


newtype TRTTF a = TRTTF {getTRTTF :: Char -> Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

trttf :: Class.Real a => Char -> Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
trttf = getTRTTF $ Class.switchReal (TRTTF C.trttf) (TRTTF Z.trttf)


newtype TRTTP a = TRTTP {getTRTTP :: Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)}

trttp :: Class.Real a => Char -> CArray (Int,Int) (Complex a) -> IO (CArray Int (Complex a), Int)
trttp = getTRTTP $ Class.switchReal (TRTTP C.trttp) (TRTTP Z.trttp)


newtype TZRZF a = TZRZF {getTZRZF :: Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)}

tzrzf :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int (Complex a), Int)
tzrzf = getTZRZF $ Class.switchReal (TZRZF C.tzrzf) (TZRZF Z.tzrzf)


newtype UNBDB a = UNBDB {getUNBDB :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), CArray Int (Complex a), CArray Int (Complex a), Int)}

unbdb :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (CArray Int a, CArray Int a, CArray Int (Complex a), CArray Int (Complex a), CArray Int (Complex a), CArray Int (Complex a), Int)
unbdb = getUNBDB $ Class.switchReal (UNBDB C.unbdb) (UNBDB Z.unbdb)


newtype UNCSD a = UNCSD {getUNCSD :: Char -> Char -> Char -> Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)}

uncsd :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), CArray (Int,Int) (Complex a), Int)
uncsd = getUNCSD $ Class.switchReal (UNCSD C.uncsd) (UNCSD Z.uncsd)


newtype UNG2L a = UNG2L {getUNG2L :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)}

ung2l :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)
ung2l = getUNG2L $ Class.switchReal (UNG2L C.ung2l) (UNG2L Z.ung2l)


newtype UNG2R a = UNG2R {getUNG2R :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)}

ung2r :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)
ung2r = getUNG2R $ Class.switchReal (UNG2R C.ung2r) (UNG2R Z.ung2r)


newtype UNGBR a = UNGBR {getUNGBR :: Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

ungbr :: Class.Real a => Char -> Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
ungbr = getUNGBR $ Class.switchReal (UNGBR C.ungbr) (UNGBR Z.ungbr)


newtype UNGHR a = UNGHR {getUNGHR :: Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

unghr :: Class.Real a => Int -> Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
unghr = getUNGHR $ Class.switchReal (UNGHR C.unghr) (UNGHR Z.unghr)


newtype UNGL2 a = UNGL2 {getUNGL2 :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)}

ungl2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)
ungl2 = getUNGL2 $ Class.switchReal (UNGL2 C.ungl2) (UNGL2 Z.ungl2)


newtype UNGLQ a = UNGLQ {getUNGLQ :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

unglq :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
unglq = getUNGLQ $ Class.switchReal (UNGLQ C.unglq) (UNGLQ Z.unglq)


newtype UNGQL a = UNGQL {getUNGQL :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

ungql :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
ungql = getUNGQL $ Class.switchReal (UNGQL C.ungql) (UNGQL Z.ungql)


newtype UNGQR a = UNGQR {getUNGQR :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

ungqr :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
ungqr = getUNGQR $ Class.switchReal (UNGQR C.ungqr) (UNGQR Z.ungqr)


newtype UNGR2 a = UNGR2 {getUNGR2 :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)}

ungr2 :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IO (Int)
ungr2 = getUNGR2 $ Class.switchReal (UNGR2 C.ungr2) (UNGR2 Z.ungr2)


newtype UNGRQ a = UNGRQ {getUNGRQ :: Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

ungrq :: Class.Real a => Int -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
ungrq = getUNGRQ $ Class.switchReal (UNGRQ C.ungrq) (UNGRQ Z.ungrq)


newtype UNGTR a = UNGTR {getUNGTR :: Char -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)}

ungtr :: Class.Real a => Char -> IOCArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> IO (Int)
ungtr = getUNGTR $ Class.switchReal (UNGTR C.ungtr) (UNGTR Z.ungtr)


newtype UNM2L a = UNM2L {getUNM2L :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unm2l :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unm2l = getUNM2L $ Class.switchReal (UNM2L C.unm2l) (UNM2L Z.unm2l)


newtype UNM2R a = UNM2R {getUNM2R :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unm2r :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unm2r = getUNM2R $ Class.switchReal (UNM2R C.unm2r) (UNM2R Z.unm2r)


newtype UNMBR a = UNMBR {getUNMBR :: Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmbr :: Class.Real a => Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmbr = getUNMBR $ Class.switchReal (UNMBR C.unmbr) (UNMBR Z.unmbr)


newtype UNMHR a = UNMHR {getUNMHR :: Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmhr :: Class.Real a => Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmhr = getUNMHR $ Class.switchReal (UNMHR C.unmhr) (UNMHR Z.unmhr)


newtype UNML2 a = UNML2 {getUNML2 :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unml2 :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unml2 = getUNML2 $ Class.switchReal (UNML2 C.unml2) (UNML2 Z.unml2)


newtype UNMLQ a = UNMLQ {getUNMLQ :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmlq :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmlq = getUNMLQ $ Class.switchReal (UNMLQ C.unmlq) (UNMLQ Z.unmlq)


newtype UNMQL a = UNMQL {getUNMQL :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmql :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmql = getUNMQL $ Class.switchReal (UNMQL C.unmql) (UNMQL Z.unmql)


newtype UNMQR a = UNMQR {getUNMQR :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmqr :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmqr = getUNMQR $ Class.switchReal (UNMQR C.unmqr) (UNMQR Z.unmqr)


newtype UNMR2 a = UNMR2 {getUNMR2 :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmr2 :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmr2 = getUNMR2 $ Class.switchReal (UNMR2 C.unmr2) (UNMR2 Z.unmr2)


newtype UNMR3 a = UNMR3 {getUNMR3 :: Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmr3 :: Class.Real a => Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmr3 = getUNMR3 $ Class.switchReal (UNMR3 C.unmr3) (UNMR3 Z.unmr3)


newtype UNMRQ a = UNMRQ {getUNMRQ :: Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmrq :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmrq = getUNMRQ $ Class.switchReal (UNMRQ C.unmrq) (UNMRQ Z.unmrq)


newtype UNMRZ a = UNMRZ {getUNMRZ :: Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmrz :: Class.Real a => Char -> Char -> Int -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmrz = getUNMRZ $ Class.switchReal (UNMRZ C.unmrz) (UNMRZ Z.unmrz)


newtype UNMTR a = UNMTR {getUNMTR :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

unmtr :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
unmtr = getUNMTR $ Class.switchReal (UNMTR C.unmtr) (UNMTR Z.unmtr)


newtype UPGTR a = UPGTR {getUPGTR :: Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)}

upgtr :: Class.Real a => Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> IO (CArray (Int,Int) (Complex a), Int)
upgtr = getUPGTR $ Class.switchReal (UPGTR C.upgtr) (UPGTR Z.upgtr)


newtype UPMTR a = UPMTR {getUPMTR :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)}

upmtr :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> CArray Int (Complex a) -> IOCArray (Int,Int) (Complex a) -> Int -> IO (Int)
upmtr = getUPMTR $ Class.switchReal (UPMTR C.upmtr) (UPMTR Z.upmtr)
