-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.CArray.Real (
   bbcsd,
   bdsdc,
   bdsqr,
   disna,
   gbbrd,
   gbcon,
   gbequ,
   gbequb,
   gbrfs,
   gbsv,
   gbsvx,
   gbtf2,
   gbtrf,
   gbtrs,
   gebak,
   gebal,
   gebd2,
   gebrd,
   gecon,
   geequ,
   geequb,
   gees,
   geesx,
   geev,
   geevx,
   gehd2,
   gehrd,
   gejsv,
   gelq2,
   gelqf,
   gels,
   gelsd,
   gelss,
   gelsy,
   geql2,
   geqlf,
   geqp3,
   geqr2,
   geqr2p,
   geqrf,
   geqrfp,
   gerfs,
   gerq2,
   gerqf,
   gesc2,
   gesdd,
   gesv,
   gesvd,
   gesvj,
   gesvx,
   getc2,
   getf2,
   getrf,
   getri,
   getrs,
   ggbak,
   ggbal,
   gges,
   ggesx,
   ggev,
   ggevx,
   ggglm,
   gghrd,
   gglse,
   ggqrf,
   ggrqf,
   gsvj0,
   gsvj1,
   gtcon,
   gtrfs,
   gtsv,
   gtsvx,
   gttrf,
   gttrs,
   gtts2,
   sbev,
   sbevd,
   sbevx,
   sbgst,
   sbgv,
   sbgvd,
   sbgvx,
   sbtrd,
   syev,
   syevd,
   syevr,
   syevx,
   sygs2,
   sygst,
   sygv,
   sygvd,
   sygvx,
   sfrk,
   hgeqz,
   spev,
   spevd,
   spevx,
   spgst,
   spgv,
   spgvd,
   spgvx,
   sptrd,
   hsein,
   hseqr,
   ilalc,
   ilalr,
   isnan,
   labad,
   labrd,
   lacn2,
   lacon,
   lacpy,
   ladiv,
   lae2,
   laebz,
   laed0,
   laed1,
   laed2,
   laed3,
   laed4,
   laed5,
   laed6,
   laed7,
   laed8,
   laed9,
   laeda,
   laein,
   laev2,
   laexc,
   lag2,
   lags2,
   lagtf,
   lagtm,
   lagts,
   lagv2,
   lahqr,
   lahr2,
   laic1,
   laisnan,
   laln2,
   lals0,
   lalsa,
   lalsd,
   lamrg,
   laneg,
   langb,
   lange,
   langt,
   lanhs,
   lansb,
   lansf,
   lansp,
   lanst,
   lansy,
   lantb,
   lantp,
   lantr,
   lanv2,
   lapll,
   lapmr,
   lapmt,
   lapy2,
   lapy3,
   laqgb,
   laqge,
   laqp2,
   laqps,
   laqr0,
   laqr1,
   laqr2,
   laqr3,
   laqr4,
   laqr5,
   laqsb,
   laqsp,
   laqsy,
   laqtr,
   lar1v,
   lar2v,
   larf,
   larfb,
   larfg,
   larfgp,
   larft,
   larfx,
   largv,
   larnv,
   larra,
   larrb,
   larrc,
   larrd,
   larre,
   larrf,
   larrj,
   larrk,
   larrr,
   larrv,
   lartg,
   lartgp,
   lartgs,
   lartv,
   laruv,
   larz,
   larzb,
   larzt,
   las2,
   lascl,
   lasd0,
   lasd1,
   lasd2,
   lasd3,
   lasd4,
   lasd5,
   lasd6,
   lasd7,
   lasd8,
   lasda,
   lasdq,
   laset,
   lasq1,
   lasq2,
   lasq4,
   lasq5,
   lasq6,
   lasr,
   lasrt,
   lassq,
   lasv2,
   laswp,
   lasy2,
   lasyf,
   latbs,
   latdf,
   latps,
   latrd,
   latrs,
   latrz,
   lauu2,
   lauum,
   orbdb,
   orcsd,
   pbcon,
   pbequ,
   pbrfs,
   pbstf,
   pbsv,
   pbsvx,
   pbtf2,
   pbtrf,
   pbtrs,
   pftrf,
   pftri,
   pftrs,
   pocon,
   poequ,
   poequb,
   porfs,
   posv,
   posvx,
   potf2,
   potrf,
   potri,
   potrs,
   ppcon,
   ppequ,
   pprfs,
   ppsv,
   ppsvx,
   pptrf,
   pptri,
   pptrs,
   pstf2,
   pstrf,
   ptcon,
   pteqr,
   ptrfs,
   ptsv,
   ptsvx,
   pttrf,
   pttrs,
   ptts2,
   rscl,
   spcon,
   sprfs,
   spsv,
   spsvx,
   sptrf,
   sptri,
   sptrs,
   stebz,
   stedc,
   stegr,
   stein,
   stemr,
   steqr,
   sterf,
   stev,
   stevd,
   stevr,
   stevx,
   sycon,
   syconv,
   syequb,
   syrfs,
   sysv,
   sysvx,
   syswapr,
   sytd2,
   sytf2,
   sytrd,
   sytrf,
   sytri,
   sytri2,
   sytri2x,
   sytrs,
   sytrs2,
   tbcon,
   tbrfs,
   tbtrs,
   tfsm,
   tftri,
   tfttp,
   tfttr,
   tgevc,
   tgex2,
   tgexc,
   tgsen,
   tgsja,
   tgsna,
   tgsy2,
   tgsyl,
   tpcon,
   tprfs,
   tptri,
   tptrs,
   tpttf,
   tpttr,
   trcon,
   trevc,
   trexc,
   trrfs,
   trsen,
   trsna,
   trsyl,
   trti2,
   trtri,
   trtrs,
   trttf,
   trttp,
   tzrzf,
   org2l,
   org2r,
   orgbr,
   orghr,
   orgl2,
   orglq,
   orgql,
   orgqr,
   orgr2,
   orgrq,
   orgtr,
   orm2l,
   orm2r,
   ormbr,
   ormhr,
   orml2,
   ormlq,
   ormql,
   ormqr,
   ormr2,
   ormr3,
   ormrq,
   ormrz,
   ormtr,
   opgtr,
   opmtr,
   ) where

import qualified Numeric.LAPACK.CArray.Double as D
import qualified Numeric.LAPACK.CArray.Float as S
import qualified Numeric.Netlib.Class as Class

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.C.Types (CInt)



newtype BBCSD a = BBCSD {getBBCSD :: Char -> Char -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)}

bbcsd :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)
bbcsd = getBBCSD $ Class.switchReal (BBCSD S.bbcsd) (BBCSD D.bbcsd)


newtype BDSDC a = BDSDC {getBDSDC :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int CInt, Int)}

bdsdc :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int CInt, Int)
bdsdc = getBDSDC $ Class.switchReal (BDSDC S.bdsdc) (BDSDC D.bdsdc)


newtype BDSQR a = BDSQR {getBDSQR :: Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

bdsqr :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
bdsqr = getBDSQR $ Class.switchReal (BDSQR S.bdsqr) (BDSQR D.bdsqr)


newtype DISNA a = DISNA {getDISNA :: Char -> Int -> Int -> CArray Int a -> Int -> IO (CArray Int a, Int)}

disna :: Class.Real a => Char -> Int -> Int -> CArray Int a -> Int -> IO (CArray Int a, Int)
disna = getDISNA $ Class.switchReal (DISNA S.disna) (DISNA D.disna)


newtype GBBRD a = GBBRD {getGBBRD :: Char -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

gbbrd :: Class.Real a => Char -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
gbbrd = getGBBRD $ Class.switchReal (GBBRD S.gbbrd) (GBBRD D.gbbrd)


newtype GBCON a = GBCON {getGBCON :: Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> a -> IO (a, Int)}

gbcon :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> a -> IO (a, Int)
gbcon = getGBCON $ Class.switchReal (GBCON S.gbcon) (GBCON D.gbcon)


newtype GBEQU a = GBEQU {getGBEQU :: Int -> Int -> Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

gbequ :: Class.Real a => Int -> Int -> Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)
gbequ = getGBEQU $ Class.switchReal (GBEQU S.gbequ) (GBEQU D.gbequ)


newtype GBEQUB a = GBEQUB {getGBEQUB :: Int -> Int -> Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

gbequb :: Class.Real a => Int -> Int -> Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)
gbequb = getGBEQUB $ Class.switchReal (GBEQUB S.gbequb) (GBEQUB D.gbequb)


newtype GBRFS a = GBRFS {getGBRFS :: Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

gbrfs :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
gbrfs = getGBRFS $ Class.switchReal (GBRFS S.gbrfs) (GBRFS D.gbrfs)


newtype GBSV a = GBSV {getGBSV :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbsv :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbsv = getGBSV $ Class.switchReal (GBSV S.gbsv) (GBSV D.gbsv)


newtype GBSVX a = GBSVX {getGBSVX :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

gbsvx :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
gbsvx = getGBSVX $ Class.switchReal (GBSVX S.gbsvx) (GBSVX D.gbsvx)


newtype GBTF2 a = GBTF2 {getGBTF2 :: Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbtf2 :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbtf2 = getGBTF2 $ Class.switchReal (GBTF2 S.gbtf2) (GBTF2 D.gbtf2)


newtype GBTRF a = GBTRF {getGBTRF :: Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gbtrf :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gbtrf = getGBTRF $ Class.switchReal (GBTRF S.gbtrf) (GBTRF D.gbtrf)


newtype GBTRS a = GBTRS {getGBTRS :: Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

gbtrs :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
gbtrs = getGBTRS $ Class.switchReal (GBTRS S.gbtrs) (GBTRS D.gbtrs)


newtype GEBAK a = GEBAK {getGEBAK :: Char -> Char -> Int -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

gebak :: Class.Real a => Char -> Char -> Int -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
gebak = getGEBAK $ Class.switchReal (GEBAK S.gebak) (GEBAK D.gebak)


newtype GEBAL a = GEBAL {getGEBAL :: Char -> IOCArray (Int,Int) a -> IO (Int, Int, CArray Int a, Int)}

gebal :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int, Int, CArray Int a, Int)
gebal = getGEBAL $ Class.switchReal (GEBAL S.gebal) (GEBAL D.gebal)


newtype GEBD2 a = GEBD2 {getGEBD2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)}

gebd2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)
gebd2 = getGEBD2 $ Class.switchReal (GEBD2 S.gebd2) (GEBD2 D.gebd2)


newtype GEBRD a = GEBRD {getGEBRD :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)}

gebrd :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)
gebrd = getGEBRD $ Class.switchReal (GEBRD S.gebrd) (GEBRD D.gebrd)


newtype GECON a = GECON {getGECON :: Char -> CArray (Int,Int) a -> a -> IO (a, Int)}

gecon :: Class.Real a => Char -> CArray (Int,Int) a -> a -> IO (a, Int)
gecon = getGECON $ Class.switchReal (GECON S.gecon) (GECON D.gecon)


newtype GEEQU a = GEEQU {getGEEQU :: Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

geequ :: Class.Real a => Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)
geequ = getGEEQU $ Class.switchReal (GEEQU S.geequ) (GEEQU D.geequ)


newtype GEEQUB a = GEEQUB {getGEEQUB :: Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)}

geequb :: Class.Real a => Int -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, a, a, a, Int)
geequb = getGEEQUB $ Class.switchReal (GEEQUB S.geequb) (GEEQUB D.geequb)


newtype GEES a = GEES {getGEES :: Char -> Char -> FunPtr (Ptr a -> Ptr a -> IO Bool) -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, Int)}

gees :: Class.Real a => Char -> Char -> FunPtr (Ptr a -> Ptr a -> IO Bool) -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, Int)
gees = getGEES $ Class.switchReal (GEES S.gees) (GEES D.gees)


newtype GEESX a = GEESX {getGEESX :: Char -> Char -> FunPtr (Ptr a -> Ptr a -> IO Bool) -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, a, a, Int)}

geesx :: Class.Real a => Char -> Char -> FunPtr (Ptr a -> Ptr a -> IO Bool) -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, a, a, Int)
geesx = getGEESX $ Class.switchReal (GEESX S.geesx) (GEESX D.geesx)


newtype GEEV a = GEEV {getGEEV :: Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

geev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
geev = getGEEV $ Class.switchReal (GEEV S.geev) (GEEV D.geev)


newtype GEEVX a = GEEVX {getGEEVX :: Char -> Char -> Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int, Int, CArray Int a, a, CArray Int a, CArray Int a, Int)}

geevx :: Class.Real a => Char -> Char -> Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int, Int, CArray Int a, a, CArray Int a, CArray Int a, Int)
geevx = getGEEVX $ Class.switchReal (GEEVX S.geevx) (GEEVX D.geevx)


newtype GEHD2 a = GEHD2 {getGEHD2 :: Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gehd2 :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gehd2 = getGEHD2 $ Class.switchReal (GEHD2 S.gehd2) (GEHD2 D.gehd2)


newtype GEHRD a = GEHRD {getGEHRD :: Int -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gehrd :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gehrd = getGEHRD $ Class.switchReal (GEHRD S.gehrd) (GEHRD D.gehrd)


newtype GEJSV a = GEJSV {getGEJSV :: Char -> Char -> Char -> Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

gejsv :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
gejsv = getGEJSV $ Class.switchReal (GEJSV S.gejsv) (GEJSV D.gejsv)


newtype GELQ2 a = GELQ2 {getGELQ2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gelq2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gelq2 = getGELQ2 $ Class.switchReal (GELQ2 S.gelq2) (GELQ2 D.gelq2)


newtype GELQF a = GELQF {getGELQF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gelqf :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gelqf = getGELQF $ Class.switchReal (GELQF S.gelqf) (GELQF D.gelqf)


newtype GELS a = GELS {getGELS :: Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

gels :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int)
gels = getGELS $ Class.switchReal (GELS S.gels) (GELS D.gels)


newtype GELSD a = GELSD {getGELSD :: Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> Int -> Int -> IO (CArray Int a, Int, Int)}

gelsd :: Class.Real a => Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> Int -> Int -> IO (CArray Int a, Int, Int)
gelsd = getGELSD $ Class.switchReal (GELSD S.gelsd) (GELSD D.gelsd)


newtype GELSS a = GELSS {getGELSS :: Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> Int -> IO (CArray Int a, Int, Int)}

gelss :: Class.Real a => Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> Int -> IO (CArray Int a, Int, Int)
gelss = getGELSS $ Class.switchReal (GELSS S.gelss) (GELSS D.gelss)


newtype GELSY a = GELSY {getGELSY :: Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> Int -> IO (Int, Int)}

gelsy :: Class.Real a => Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> Int -> IO (Int, Int)
gelsy = getGELSY $ Class.switchReal (GELSY S.gelsy) (GELSY D.gelsy)


newtype GEQL2 a = GEQL2 {getGEQL2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geql2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geql2 = getGEQL2 $ Class.switchReal (GEQL2 S.geql2) (GEQL2 D.geql2)


newtype GEQLF a = GEQLF {getGEQLF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqlf :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqlf = getGEQLF $ Class.switchReal (GEQLF S.geqlf) (GEQLF D.geqlf)


newtype GEQP3 a = GEQP3 {getGEQP3 :: Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IO (CArray Int a, Int)}

geqp3 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IO (CArray Int a, Int)
geqp3 = getGEQP3 $ Class.switchReal (GEQP3 S.geqp3) (GEQP3 D.geqp3)


newtype GEQR2 a = GEQR2 {getGEQR2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geqr2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geqr2 = getGEQR2 $ Class.switchReal (GEQR2 S.geqr2) (GEQR2 D.geqr2)


newtype GEQR2P a = GEQR2P {getGEQR2P :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

geqr2p :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
geqr2p = getGEQR2P $ Class.switchReal (GEQR2P S.geqr2p) (GEQR2P D.geqr2p)


newtype GEQRF a = GEQRF {getGEQRF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqrf :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqrf = getGEQRF $ Class.switchReal (GEQRF S.geqrf) (GEQRF D.geqrf)


newtype GEQRFP a = GEQRFP {getGEQRFP :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

geqrfp :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
geqrfp = getGEQRFP $ Class.switchReal (GEQRFP S.geqrfp) (GEQRFP D.geqrfp)


newtype GERFS a = GERFS {getGERFS :: Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

gerfs :: Class.Real a => Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
gerfs = getGERFS $ Class.switchReal (GERFS S.gerfs) (GERFS D.gerfs)


newtype GERQ2 a = GERQ2 {getGERQ2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)}

gerq2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int a, Int)
gerq2 = getGERQ2 $ Class.switchReal (GERQ2 S.gerq2) (GERQ2 D.gerq2)


newtype GERQF a = GERQF {getGERQF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

gerqf :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
gerqf = getGERQF $ Class.switchReal (GERQF S.gerqf) (GERQF D.gerqf)


newtype GESC2 a = GESC2 {getGESC2 :: CArray (Int,Int) a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> IO (a)}

gesc2 :: Class.Real a => CArray (Int,Int) a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> IO (a)
gesc2 = getGESC2 $ Class.switchReal (GESC2 S.gesc2) (GESC2 D.gesc2)


newtype GESDD a = GESDD {getGESDD :: Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

gesdd :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
gesdd = getGESDD $ Class.switchReal (GESDD S.gesdd) (GESDD D.gesdd)


newtype GESV a = GESV {getGESV :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

gesv :: Class.Real a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
gesv = getGESV $ Class.switchReal (GESV S.gesv) (GESV D.gesv)


newtype GESVD a = GESVD {getGESVD :: Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

gesvd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
gesvd = getGESVD $ Class.switchReal (GESVD S.gesvd) (GESVD D.gesvd)


newtype GESVJ a = GESVJ {getGESVJ :: Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IO (CArray Int a, Int)}

gesvj :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IO (CArray Int a, Int)
gesvj = getGESVJ $ Class.switchReal (GESVJ S.gesvj) (GESVJ D.gesvj)


newtype GESVX a = GESVX {getGESVX :: Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

gesvx :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
gesvx = getGESVX $ Class.switchReal (GESVX S.gesvx) (GESVX D.gesvx)


newtype GETC2 a = GETC2 {getGETC2 :: IOCArray (Int,Int) a -> IO (CArray Int CInt, CArray Int CInt, Int)}

getc2 :: Class.Real a => IOCArray (Int,Int) a -> IO (CArray Int CInt, CArray Int CInt, Int)
getc2 = getGETC2 $ Class.switchReal (GETC2 S.getc2) (GETC2 D.getc2)


newtype GETF2 a = GETF2 {getGETF2 :: Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

getf2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
getf2 = getGETF2 $ Class.switchReal (GETF2 S.getf2) (GETF2 D.getf2)


newtype GETRF a = GETRF {getGETRF :: Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

getrf :: Class.Real a => Int -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
getrf = getGETRF $ Class.switchReal (GETRF S.getrf) (GETRF D.getrf)


newtype GETRI a = GETRI {getGETRI :: IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)}

getri :: Class.Real a => IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)
getri = getGETRI $ Class.switchReal (GETRI S.getri) (GETRI D.getri)


newtype GETRS a = GETRS {getGETRS :: Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

getrs :: Class.Real a => Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
getrs = getGETRS $ Class.switchReal (GETRS S.getrs) (GETRS D.getrs)


newtype GGBAK a = GGBAK {getGGBAK :: Char -> Char -> Int -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

ggbak :: Class.Real a => Char -> Char -> Int -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
ggbak = getGGBAK $ Class.switchReal (GGBAK S.ggbak) (GGBAK D.ggbak)


newtype GGBAL a = GGBAL {getGGBAL :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int, Int, CArray Int a, CArray Int a, Int)}

ggbal :: Class.Real a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (Int, Int, CArray Int a, CArray Int a, Int)
ggbal = getGGBAL $ Class.switchReal (GGBAL S.ggbal) (GGBAL D.ggbal)


newtype GGES a = GGES {getGGES :: Char -> Char -> Char -> FunPtr (Ptr a -> Ptr a -> Ptr a -> IO Bool) -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

gges :: Class.Real a => Char -> Char -> Char -> FunPtr (Ptr a -> Ptr a -> Ptr a -> IO Bool) -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
gges = getGGES $ Class.switchReal (GGES S.gges) (GGES D.gges)


newtype GGESX a = GGESX {getGGESX :: Char -> Char -> Char -> FunPtr (Ptr a -> Ptr a -> Ptr a -> IO Bool) -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int a, Int)}

ggesx :: Class.Real a => Char -> Char -> Char -> FunPtr (Ptr a -> Ptr a -> Ptr a -> IO Bool) -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int a, Int)
ggesx = getGGESX $ Class.switchReal (GGESX S.ggesx) (GGESX D.ggesx)


newtype GGEV a = GGEV {getGGEV :: Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

ggev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
ggev = getGGEV $ Class.switchReal (GGEV S.ggev) (GGEV D.ggev)


newtype GGEVX a = GGEVX {getGGEVX :: Char -> Char -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int, Int, CArray Int a, CArray Int a, a, a, CArray Int a, CArray Int a, Int)}

ggevx :: Class.Real a => Char -> Char -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int, Int, CArray Int a, CArray Int a, a, a, CArray Int a, CArray Int a, Int)
ggevx = getGGEVX $ Class.switchReal (GGEVX S.ggevx) (GGEVX D.ggevx)


newtype GGGLM a = GGGLM {getGGGLM :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggglm :: Class.Real a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggglm = getGGGLM $ Class.switchReal (GGGLM S.ggglm) (GGGLM D.ggglm)


newtype GGHRD a = GGHRD {getGGHRD :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

gghrd :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
gghrd = getGGHRD $ Class.switchReal (GGHRD S.gghrd) (GGHRD D.gghrd)


newtype GGLSE a = GGLSE {getGGLSE :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, Int)}

gglse :: Class.Real a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, Int)
gglse = getGGLSE $ Class.switchReal (GGLSE S.gglse) (GGLSE D.gglse)


newtype GGQRF a = GGQRF {getGGQRF :: Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggqrf :: Class.Real a => Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggqrf = getGGQRF $ Class.switchReal (GGQRF S.ggqrf) (GGQRF D.ggqrf)


newtype GGRQF a = GGRQF {getGGRQF :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)}

ggrqf :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)
ggrqf = getGGRQF $ Class.switchReal (GGRQF S.ggrqf) (GGRQF D.ggrqf)


newtype GSVJ0 a = GSVJ0 {getGSVJ0 :: Char -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IOCArray (Int,Int) a -> a -> a -> a -> Int -> Int -> IO (Int)}

gsvj0 :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IOCArray (Int,Int) a -> a -> a -> a -> Int -> Int -> IO (Int)
gsvj0 = getGSVJ0 $ Class.switchReal (GSVJ0 S.gsvj0) (GSVJ0 D.gsvj0)


newtype GSVJ1 a = GSVJ1 {getGSVJ1 :: Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IOCArray (Int,Int) a -> a -> a -> a -> Int -> Int -> IO (Int)}

gsvj1 :: Class.Real a => Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> Int -> IOCArray (Int,Int) a -> a -> a -> a -> Int -> Int -> IO (Int)
gsvj1 = getGSVJ1 $ Class.switchReal (GSVJ1 S.gsvj1) (GSVJ1 D.gsvj1)


newtype GTCON a = GTCON {getGTCON :: Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> a -> IO (a, Int)}

gtcon :: Class.Real a => Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> a -> IO (a, Int)
gtcon = getGTCON $ Class.switchReal (GTCON S.gtcon) (GTCON D.gtcon)


newtype GTRFS a = GTRFS {getGTRFS :: Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

gtrfs :: Class.Real a => Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
gtrfs = getGTRFS $ Class.switchReal (GTRFS S.gtrfs) (GTRFS D.gtrfs)


newtype GTSV a = GTSV {getGTSV :: IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

gtsv :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
gtsv = getGTSV $ Class.switchReal (GTSV S.gtsv) (GTSV D.gtsv)


newtype GTSVX a = GTSVX {getGTSVX :: Char -> Char -> CArray Int a -> CArray Int a -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

gtsvx :: Class.Real a => Char -> Char -> CArray Int a -> CArray Int a -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
gtsvx = getGTSVX $ Class.switchReal (GTSVX S.gtsvx) (GTSVX D.gtsvx)


newtype GTTRF a = GTTRF {getGTTRF :: IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a, CArray Int CInt, Int)}

gttrf :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a, CArray Int CInt, Int)
gttrf = getGTTRF $ Class.switchReal (GTTRF S.gttrf) (GTTRF D.gttrf)


newtype GTTRS a = GTTRS {getGTTRS :: Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

gttrs :: Class.Real a => Char -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
gttrs = getGTTRS $ Class.switchReal (GTTRS S.gttrs) (GTTRS D.gttrs)


newtype GTTS2 a = GTTS2 {getGTTS2 :: Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO ()}

gtts2 :: Class.Real a => Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO ()
gtts2 = getGTTS2 $ Class.switchReal (GTTS2 S.gtts2) (GTTS2 D.gtts2)


newtype SBEV a = SBEV {getSBEV :: Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

sbev :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
sbev = getSBEV $ Class.switchReal (SBEV S.sbev) (SBEV D.sbev)


newtype SBEVD a = SBEVD {getSBEVD :: Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

sbevd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
sbevd = getSBEVD $ Class.switchReal (SBEVD S.sbevd) (SBEVD D.sbevd)


newtype SBEVX a = SBEVX {getSBEVX :: Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) a, Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

sbevx :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray (Int,Int) a -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) a, Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
sbevx = getSBEVX $ Class.switchReal (SBEVX S.sbevx) (SBEVX D.sbevx)


newtype SBGST a = SBGST {getSBGST :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, Int)}

sbgst :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, Int)
sbgst = getSBGST $ Class.switchReal (SBGST S.sbgst) (SBGST D.sbgst)


newtype SBGV a = SBGV {getSBGV :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

sbgv :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
sbgv = getSBGV $ Class.switchReal (SBGV S.sbgv) (SBGV D.sbgv)


newtype SBGVD a = SBGVD {getSBGVD :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

sbgvd :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
sbgvd = getSBGVD $ Class.switchReal (SBGVD S.sbgvd) (SBGVD D.sbgvd)


newtype SBGVX a = SBGVX {getSBGVX :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) a, Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

sbgvx :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (CArray (Int,Int) a, Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
sbgvx = getSBGVX $ Class.switchReal (SBGVX S.sbgvx) (SBGVX D.sbgvx)


newtype SBTRD a = SBTRD {getSBTRD :: Char -> Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

sbtrd :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
sbtrd = getSBTRD $ Class.switchReal (SBTRD S.sbtrd) (SBTRD D.sbtrd)


newtype SYEV a = SYEV {getSYEV :: Char -> Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

syev :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
syev = getSYEV $ Class.switchReal (SYEV S.syev) (SYEV D.syev)


newtype SYEVD a = SYEVD {getSYEVD :: Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, Int)}

syevd :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray Int a, Int)
syevd = getSYEVD $ Class.switchReal (SYEVD S.syevd) (SYEVD D.syevd)


newtype SYEVR a = SYEVR {getSYEVR :: Char -> Char -> Char -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

syevr :: Class.Real a => Char -> Char -> Char -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
syevr = getSYEVR $ Class.switchReal (SYEVR S.syevr) (SYEVR D.syevr)


newtype SYEVX a = SYEVX {getSYEVX :: Char -> Char -> Char -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

syevx :: Class.Real a => Char -> Char -> Char -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
syevx = getSYEVX $ Class.switchReal (SYEVX S.syevx) (SYEVX D.syevx)


newtype SYGS2 a = SYGS2 {getSYGS2 :: Int -> Char -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> IO (Int)}

sygs2 :: Class.Real a => Int -> Char -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> IO (Int)
sygs2 = getSYGS2 $ Class.switchReal (SYGS2 S.sygs2) (SYGS2 D.sygs2)


newtype SYGST a = SYGST {getSYGST :: Int -> Char -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> IO (Int)}

sygst :: Class.Real a => Int -> Char -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> IO (Int)
sygst = getSYGST $ Class.switchReal (SYGST S.sygst) (SYGST D.sygst)


newtype SYGV a = SYGV {getSYGV :: Int -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

sygv :: Class.Real a => Int -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
sygv = getSYGV $ Class.switchReal (SYGV S.sygv) (SYGV D.sygv)


newtype SYGVD a = SYGVD {getSYGVD :: Int -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, Int)}

sygvd :: Class.Real a => Int -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, Int)
sygvd = getSYGVD $ Class.switchReal (SYGVD S.sygvd) (SYGVD D.sygvd)


newtype SYGVX a = SYGVX {getSYGVX :: Int -> Char -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

sygvx :: Class.Real a => Int -> Char -> Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
sygvx = getSYGVX $ Class.switchReal (SYGVX S.sygvx) (SYGVX D.sygvx)


newtype SFRK a = SFRK {getSFRK :: Char -> Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray Int a -> IO ()}

sfrk :: Class.Real a => Char -> Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray Int a -> IO ()
sfrk = getSFRK $ Class.switchReal (SFRK S.sfrk) (SFRK D.sfrk)


newtype HGEQZ a = HGEQZ {getHGEQZ :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int)}

hgeqz :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int)
hgeqz = getHGEQZ $ Class.switchReal (HGEQZ S.hgeqz) (HGEQZ D.hgeqz)


newtype SPEV a = SPEV {getSPEV :: Char -> Char -> Int -> IOCArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

spev :: Class.Real a => Char -> Char -> Int -> IOCArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
spev = getSPEV $ Class.switchReal (SPEV S.spev) (SPEV D.spev)


newtype SPEVD a = SPEVD {getSPEVD :: Char -> Char -> Int -> IOCArray Int a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

spevd :: Class.Real a => Char -> Char -> Int -> IOCArray Int a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
spevd = getSPEVD $ Class.switchReal (SPEVD S.spevd) (SPEVD D.spevd)


newtype SPEVX a = SPEVX {getSPEVX :: Char -> Char -> Char -> Int -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

spevx :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
spevx = getSPEVX $ Class.switchReal (SPEVX S.spevx) (SPEVX D.spevx)


newtype SPGST a = SPGST {getSPGST :: Int -> Char -> Int -> IOCArray Int a -> CArray Int a -> IO (Int)}

spgst :: Class.Real a => Int -> Char -> Int -> IOCArray Int a -> CArray Int a -> IO (Int)
spgst = getSPGST $ Class.switchReal (SPGST S.spgst) (SPGST D.spgst)


newtype SPGV a = SPGV {getSPGV :: Int -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

spgv :: Class.Real a => Int -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
spgv = getSPGV $ Class.switchReal (SPGV S.spgv) (SPGV D.spgv)


newtype SPGVD a = SPGVD {getSPGVD :: Int -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)}

spgvd :: Class.Real a => Int -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, Int)
spgvd = getSPGVD $ Class.switchReal (SPGVD S.spgvd) (SPGVD D.spgvd)


newtype SPGVX a = SPGVX {getSPGVX :: Int -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

spgvx :: Class.Real a => Int -> Char -> Char -> Char -> Int -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
spgvx = getSPGVX $ Class.switchReal (SPGVX S.spgvx) (SPGVX D.spgvx)


newtype SPTRD a = SPTRD {getSPTRD :: Char -> Int -> IOCArray Int a -> IO (CArray Int a, CArray Int a, CArray Int a, Int)}

sptrd :: Class.Real a => Char -> Int -> IOCArray Int a -> IO (CArray Int a, CArray Int a, CArray Int a, Int)
sptrd = getSPTRD $ Class.switchReal (SPTRD S.sptrd) (SPTRD D.sptrd)


newtype HSEIN a = HSEIN {getHSEIN :: Char -> Char -> Char -> IOCArray Int Bool -> CArray (Int,Int) a -> IOCArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, CArray Int CInt, CArray Int CInt, Int)}

hsein :: Class.Real a => Char -> Char -> Char -> IOCArray Int Bool -> CArray (Int,Int) a -> IOCArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, CArray Int CInt, CArray Int CInt, Int)
hsein = getHSEIN $ Class.switchReal (HSEIN S.hsein) (HSEIN D.hsein)


newtype HSEQR a = HSEQR {getHSEQR :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)}

hseqr :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, Int)
hseqr = getHSEQR $ Class.switchReal (HSEQR S.hseqr) (HSEQR D.hseqr)


newtype ILALC a = ILALC {getILALC :: Int -> CArray (Int,Int) a -> IO CInt}

ilalc :: Class.Real a => Int -> CArray (Int,Int) a -> IO CInt
ilalc = getILALC $ Class.switchReal (ILALC S.ilalc) (ILALC D.ilalc)


newtype ILALR a = ILALR {getILALR :: Int -> CArray (Int,Int) a -> IO CInt}

ilalr :: Class.Real a => Int -> CArray (Int,Int) a -> IO CInt
ilalr = getILALR $ Class.switchReal (ILALR S.ilalr) (ILALR D.ilalr)


newtype ISNAN a = ISNAN {getISNAN :: a -> IO Bool}

isnan :: Class.Real a => a -> IO Bool
isnan = getISNAN $ Class.switchReal (ISNAN S.isnan) (ISNAN D.isnan)


newtype LABAD a = LABAD {getLABAD :: a -> a -> IO (a, a)}

labad :: Class.Real a => a -> a -> IO (a, a)
labad = getLABAD $ Class.switchReal (LABAD S.labad) (LABAD D.labad)


newtype LABRD a = LABRD {getLABRD :: Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)}

labrd :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)
labrd = getLABRD $ Class.switchReal (LABRD S.labrd) (LABRD D.labrd)


newtype LACN2 a = LACN2 {getLACN2 :: IOCArray Int a -> a -> Int -> IOCArray Int CInt -> IO (CArray Int a, CArray Int CInt, a, Int)}

lacn2 :: Class.Real a => IOCArray Int a -> a -> Int -> IOCArray Int CInt -> IO (CArray Int a, CArray Int CInt, a, Int)
lacn2 = getLACN2 $ Class.switchReal (LACN2 S.lacn2) (LACN2 D.lacn2)


newtype LACON a = LACON {getLACON :: IOCArray Int a -> a -> Int -> IO (CArray Int a, CArray Int CInt, a, Int)}

lacon :: Class.Real a => IOCArray Int a -> a -> Int -> IO (CArray Int a, CArray Int CInt, a, Int)
lacon = getLACON $ Class.switchReal (LACON S.lacon) (LACON D.lacon)


newtype LACPY a = LACPY {getLACPY :: Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a)}

lacpy :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a)
lacpy = getLACPY $ Class.switchReal (LACPY S.lacpy) (LACPY D.lacpy)


newtype LADIV a = LADIV {getLADIV :: a -> a -> a -> a -> IO (a, a)}

ladiv :: Class.Real a => a -> a -> a -> a -> IO (a, a)
ladiv = getLADIV $ Class.switchReal (LADIV S.ladiv) (LADIV D.ladiv)


newtype LAE2 a = LAE2 {getLAE2 :: a -> a -> a -> IO (a, a)}

lae2 :: Class.Real a => a -> a -> a -> IO (a, a)
lae2 = getLAE2 $ Class.switchReal (LAE2 S.lae2) (LAE2 D.lae2)


newtype LAEBZ a = LAEBZ {getLAEBZ :: Int -> Int -> Int -> a -> a -> a -> CArray Int a -> CArray Int a -> CArray Int a -> IOCArray Int CInt -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray (Int,Int) CInt -> IO (Int, Int)}

laebz :: Class.Real a => Int -> Int -> Int -> a -> a -> a -> CArray Int a -> CArray Int a -> CArray Int a -> IOCArray Int CInt -> IOCArray (Int,Int) a -> IOCArray Int a -> IOCArray (Int,Int) CInt -> IO (Int, Int)
laebz = getLAEBZ $ Class.switchReal (LAEBZ S.laebz) (LAEBZ D.laebz)


newtype LAED0 a = LAED0 {getLAED0 :: Int -> Int -> IOCArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray (Int,Int) a, Int)}

laed0 :: Class.Real a => Int -> Int -> IOCArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (CArray (Int,Int) a, Int)
laed0 = getLAED0 $ Class.switchReal (LAED0 S.laed0) (LAED0 D.laed0)


newtype LAED1 a = LAED1 {getLAED1 :: IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> Int -> IO (Int)}

laed1 :: Class.Real a => IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> Int -> IO (Int)
laed1 = getLAED1 $ Class.switchReal (LAED1 S.laed1) (LAED1 D.laed1)


newtype LAED2 a = LAED2 {getLAED2 :: Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> CArray Int a -> IO (Int, a, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)}

laed2 :: Class.Real a => Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> a -> CArray Int a -> IO (Int, a, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)
laed2 = getLAED2 $ Class.switchReal (LAED2 S.laed2) (LAED2 D.laed2)


newtype LAED3 a = LAED3 {getLAED3 :: Int -> Int -> a -> IOCArray Int a -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> IOCArray Int a -> IO (CArray Int a, CArray (Int,Int) a, CArray Int a, Int)}

laed3 :: Class.Real a => Int -> Int -> a -> IOCArray Int a -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> IOCArray Int a -> IO (CArray Int a, CArray (Int,Int) a, CArray Int a, Int)
laed3 = getLAED3 $ Class.switchReal (LAED3 S.laed3) (LAED3 D.laed3)


newtype LAED4 a = LAED4 {getLAED4 :: Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a, Int)}

laed4 :: Class.Real a => Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a, Int)
laed4 = getLAED4 $ Class.switchReal (LAED4 S.laed4) (LAED4 D.laed4)


newtype LAED5 a = LAED5 {getLAED5 :: Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a)}

laed5 :: Class.Real a => Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a)
laed5 = getLAED5 $ Class.switchReal (LAED5 S.laed5) (LAED5 D.laed5)


newtype LAED6 a = LAED6 {getLAED6 :: Int -> Bool -> a -> CArray Int a -> CArray Int a -> a -> IO (a, Int)}

laed6 :: Class.Real a => Int -> Bool -> a -> CArray Int a -> CArray Int a -> a -> IO (a, Int)
laed6 = getLAED6 $ Class.switchReal (LAED6 S.laed6) (LAED6 D.laed6)


newtype LAED7 a = LAED7 {getLAED7 :: Int -> Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> a -> Int -> IOCArray Int a -> IOCArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> IO (CArray Int CInt, Int)}

laed7 :: Class.Real a => Int -> Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> a -> Int -> IOCArray Int a -> IOCArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> IO (CArray Int CInt, Int)
laed7 = getLAED7 $ Class.switchReal (LAED7 S.laed7) (LAED7 D.laed7)


newtype LAED8 a = LAED8 {getLAED8 :: Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> CArray Int CInt -> a -> Int -> CArray Int a -> Int -> IO (Int, a, CArray Int a, CArray (Int,Int) a, CArray Int a, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray Int CInt, CArray Int CInt, Int)}

laed8 :: Class.Real a => Int -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> CArray Int CInt -> a -> Int -> CArray Int a -> Int -> IO (Int, a, CArray Int a, CArray (Int,Int) a, CArray Int a, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray Int CInt, CArray Int CInt, Int)
laed8 = getLAED8 $ Class.switchReal (LAED8 S.laed8) (LAED8 D.laed8)


newtype LAED9 a = LAED9 {getLAED9 :: Int -> Int -> Int -> Int -> a -> CArray Int a -> CArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

laed9 :: Class.Real a => Int -> Int -> Int -> Int -> a -> CArray Int a -> CArray Int a -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
laed9 = getLAED9 $ Class.switchReal (LAED9 S.laed9) (LAED9 D.laed9)


newtype LAEDA a = LAEDA {getLAEDA :: Int -> Int -> Int -> Int -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int CInt -> IO (CArray Int a, CArray Int a, Int)}

laeda :: Class.Real a => Int -> Int -> Int -> Int -> CArray Int CInt -> CArray Int CInt -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int CInt -> IO (CArray Int a, CArray Int a, Int)
laeda = getLAEDA $ Class.switchReal (LAEDA S.laeda) (LAEDA D.laeda)


newtype LAEIN a = LAEIN {getLAEIN :: Bool -> Bool -> CArray (Int,Int) a -> a -> a -> IOCArray Int a -> IOCArray Int a -> Int -> a -> a -> a -> IO (CArray (Int,Int) a, Int)}

laein :: Class.Real a => Bool -> Bool -> CArray (Int,Int) a -> a -> a -> IOCArray Int a -> IOCArray Int a -> Int -> a -> a -> a -> IO (CArray (Int,Int) a, Int)
laein = getLAEIN $ Class.switchReal (LAEIN S.laein) (LAEIN D.laein)


newtype LAEV2 a = LAEV2 {getLAEV2 :: a -> a -> a -> IO (a, a, a, a)}

laev2 :: Class.Real a => a -> a -> a -> IO (a, a, a, a)
laev2 = getLAEV2 $ Class.switchReal (LAEV2 S.laev2) (LAEV2 D.laev2)


newtype LAEXC a = LAEXC {getLAEXC :: Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int)}

laexc :: Class.Real a => Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int)
laexc = getLAEXC $ Class.switchReal (LAEXC S.laexc) (LAEXC D.laexc)


newtype LAG2 a = LAG2 {getLAG2 :: CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IO (a, a, a, a, a)}

lag2 :: Class.Real a => CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IO (a, a, a, a, a)
lag2 = getLAG2 $ Class.switchReal (LAG2 S.lag2) (LAG2 D.lag2)


newtype LAGS2 a = LAGS2 {getLAGS2 :: Bool -> a -> a -> a -> a -> a -> a -> IO (a, a, a, a, a, a)}

lags2 :: Class.Real a => Bool -> a -> a -> a -> a -> a -> a -> IO (a, a, a, a, a, a)
lags2 = getLAGS2 $ Class.switchReal (LAGS2 S.lags2) (LAGS2 D.lags2)


newtype LAGTF a = LAGTF {getLAGTF :: IOCArray Int a -> a -> IOCArray Int a -> IOCArray Int a -> a -> IO (CArray Int a, CArray Int CInt, Int)}

lagtf :: Class.Real a => IOCArray Int a -> a -> IOCArray Int a -> IOCArray Int a -> a -> IO (CArray Int a, CArray Int CInt, Int)
lagtf = getLAGTF $ Class.switchReal (LAGTF S.lagtf) (LAGTF D.lagtf)


newtype LAGTM a = LAGTM {getLAGTM :: Char -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

lagtm :: Class.Real a => Char -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
lagtm = getLAGTM $ Class.switchReal (LAGTM S.lagtm) (LAGTM D.lagtm)


newtype LAGTS a = LAGTS {getLAGTS :: Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray Int a -> a -> IO (a, Int)}

lagts :: Class.Real a => Int -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int CInt -> IOCArray Int a -> a -> IO (a, Int)
lagts = getLAGTS $ Class.switchReal (LAGTS S.lagts) (LAGTS D.lagts)


newtype LAGV2 a = LAGV2 {getLAGV2 :: IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, a, a, a, a)}

lagv2 :: Class.Real a => IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, a, a, a, a)
lagv2 = getLAGV2 $ Class.switchReal (LAGV2 S.lagv2) (LAGV2 D.lagv2)


newtype LAHQR a = LAHQR {getLAHQR :: Bool -> Bool -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

lahqr :: Class.Real a => Bool -> Bool -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
lahqr = getLAHQR $ Class.switchReal (LAHQR S.lahqr) (LAHQR D.lahqr)


newtype LAHR2 a = LAHR2 {getLAHR2 :: Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)}

lahr2 :: Class.Real a => Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a)
lahr2 = getLAHR2 $ Class.switchReal (LAHR2 S.lahr2) (LAHR2 D.lahr2)


newtype LAIC1 a = LAIC1 {getLAIC1 :: Int -> CArray Int a -> a -> CArray Int a -> a -> IO (a, a, a)}

laic1 :: Class.Real a => Int -> CArray Int a -> a -> CArray Int a -> a -> IO (a, a, a)
laic1 = getLAIC1 $ Class.switchReal (LAIC1 S.laic1) (LAIC1 D.laic1)


newtype LAISNAN a = LAISNAN {getLAISNAN :: a -> a -> IO Bool}

laisnan :: Class.Real a => a -> a -> IO Bool
laisnan = getLAISNAN $ Class.switchReal (LAISNAN S.laisnan) (LAISNAN D.laisnan)


newtype LALN2 a = LALN2 {getLALN2 :: Bool -> a -> a -> CArray (Int,Int) a -> a -> a -> CArray (Int,Int) a -> a -> a -> Int -> IO (CArray (Int,Int) a, a, a, Int)}

laln2 :: Class.Real a => Bool -> a -> a -> CArray (Int,Int) a -> a -> a -> CArray (Int,Int) a -> a -> a -> Int -> IO (CArray (Int,Int) a, a, a, Int)
laln2 = getLALN2 $ Class.switchReal (LALN2 S.laln2) (LALN2 D.laln2)


newtype LALS0 a = LALS0 {getLALS0 :: Int -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> CArray Int CInt -> Int -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int a -> CArray (Int,Int) a -> CArray Int a -> a -> a -> IO (CArray (Int,Int) a, Int)}

lals0 :: Class.Real a => Int -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> CArray Int CInt -> Int -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int a -> CArray (Int,Int) a -> CArray Int a -> a -> a -> IO (CArray (Int,Int) a, Int)
lals0 = getLALS0 $ Class.switchReal (LALS0 S.lals0) (LALS0 D.lals0)


newtype LALSA a = LALSA {getLALSA :: Int -> IOCArray (Int,Int) a -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int a -> IO (CArray (Int,Int) a, Int)}

lalsa :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) CInt -> CArray (Int,Int) a -> CArray Int a -> CArray Int a -> IO (CArray (Int,Int) a, Int)
lalsa = getLALSA $ Class.switchReal (LALSA S.lalsa) (LALSA D.lalsa)


newtype LALSD a = LALSD {getLALSD :: Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> a -> Int -> Int -> IO (Int, Int)}

lalsd :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> a -> Int -> Int -> IO (Int, Int)
lalsd = getLALSD $ Class.switchReal (LALSD S.lalsd) (LALSD D.lalsd)


newtype LAMRG a = LAMRG {getLAMRG :: Int -> Int -> CArray Int a -> Int -> Int -> IO (CArray Int CInt)}

lamrg :: Class.Real a => Int -> Int -> CArray Int a -> Int -> Int -> IO (CArray Int CInt)
lamrg = getLAMRG $ Class.switchReal (LAMRG S.lamrg) (LAMRG D.lamrg)


newtype LANEG a = LANEG {getLANEG :: CArray Int a -> CArray Int a -> a -> a -> Int -> IO CInt}

laneg :: Class.Real a => CArray Int a -> CArray Int a -> a -> a -> Int -> IO CInt
laneg = getLANEG $ Class.switchReal (LANEG S.laneg) (LANEG D.laneg)


newtype LANGB a = LANGB {getLANGB :: Char -> Int -> Int -> CArray (Int,Int) a -> Int -> IO a}

langb :: Class.Real a => Char -> Int -> Int -> CArray (Int,Int) a -> Int -> IO a
langb = getLANGB $ Class.switchReal (LANGB S.langb) (LANGB D.langb)


newtype LANGE a = LANGE {getLANGE :: Char -> Int -> CArray (Int,Int) a -> Int -> IO a}

lange :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> Int -> IO a
lange = getLANGE $ Class.switchReal (LANGE S.lange) (LANGE D.lange)


newtype LANGT a = LANGT {getLANGT :: Char -> CArray Int a -> CArray Int a -> CArray Int a -> IO a}

langt :: Class.Real a => Char -> CArray Int a -> CArray Int a -> CArray Int a -> IO a
langt = getLANGT $ Class.switchReal (LANGT S.langt) (LANGT D.langt)


newtype LANHS a = LANHS {getLANHS :: Char -> CArray (Int,Int) a -> Int -> IO a}

lanhs :: Class.Real a => Char -> CArray (Int,Int) a -> Int -> IO a
lanhs = getLANHS $ Class.switchReal (LANHS S.lanhs) (LANHS D.lanhs)


newtype LANSB a = LANSB {getLANSB :: Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a}

lansb :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a
lansb = getLANSB $ Class.switchReal (LANSB S.lansb) (LANSB D.lansb)


newtype LANSF a = LANSF {getLANSF :: Char -> Char -> Char -> Int -> CArray Int a -> Int -> IO a}

lansf :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> Int -> IO a
lansf = getLANSF $ Class.switchReal (LANSF S.lansf) (LANSF D.lansf)


newtype LANSP a = LANSP {getLANSP :: Char -> Char -> Int -> CArray Int a -> Int -> IO a}

lansp :: Class.Real a => Char -> Char -> Int -> CArray Int a -> Int -> IO a
lansp = getLANSP $ Class.switchReal (LANSP S.lansp) (LANSP D.lansp)


newtype LANST a = LANST {getLANST :: Char -> CArray Int a -> CArray Int a -> IO a}

lanst :: Class.Real a => Char -> CArray Int a -> CArray Int a -> IO a
lanst = getLANST $ Class.switchReal (LANST S.lanst) (LANST D.lanst)


newtype LANSY a = LANSY {getLANSY :: Char -> Char -> CArray (Int,Int) a -> Int -> IO a}

lansy :: Class.Real a => Char -> Char -> CArray (Int,Int) a -> Int -> IO a
lansy = getLANSY $ Class.switchReal (LANSY S.lansy) (LANSY D.lansy)


newtype LANTB a = LANTB {getLANTB :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a}

lantb :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a
lantb = getLANTB $ Class.switchReal (LANTB S.lantb) (LANTB D.lantb)


newtype LANTP a = LANTP {getLANTP :: Char -> Char -> Char -> Int -> CArray Int a -> Int -> IO a}

lantp :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> Int -> IO a
lantp = getLANTP $ Class.switchReal (LANTP S.lantp) (LANTP D.lantp)


newtype LANTR a = LANTR {getLANTR :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a}

lantr :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> Int -> IO a
lantr = getLANTR $ Class.switchReal (LANTR S.lantr) (LANTR D.lantr)


newtype LANV2 a = LANV2 {getLANV2 :: a -> a -> a -> a -> IO (a, a, a, a, a, a, a, a, a, a)}

lanv2 :: Class.Real a => a -> a -> a -> a -> IO (a, a, a, a, a, a, a, a, a, a)
lanv2 = getLANV2 $ Class.switchReal (LANV2 S.lanv2) (LANV2 D.lanv2)


newtype LAPLL a = LAPLL {getLAPLL :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO (a)}

lapll :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO (a)
lapll = getLAPLL $ Class.switchReal (LAPLL S.lapll) (LAPLL D.lapll)


newtype LAPMR a = LAPMR {getLAPMR :: Bool -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()}

lapmr :: Class.Real a => Bool -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()
lapmr = getLAPMR $ Class.switchReal (LAPMR S.lapmr) (LAPMR D.lapmr)


newtype LAPMT a = LAPMT {getLAPMT :: Bool -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()}

lapmt :: Class.Real a => Bool -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO ()
lapmt = getLAPMT $ Class.switchReal (LAPMT S.lapmt) (LAPMT D.lapmt)


newtype LAPY2 a = LAPY2 {getLAPY2 :: a -> a -> IO a}

lapy2 :: Class.Real a => a -> a -> IO a
lapy2 = getLAPY2 $ Class.switchReal (LAPY2 S.lapy2) (LAPY2 D.lapy2)


newtype LAPY3 a = LAPY3 {getLAPY3 :: a -> a -> a -> IO a}

lapy3 :: Class.Real a => a -> a -> a -> IO a
lapy3 = getLAPY3 $ Class.switchReal (LAPY3 S.lapy3) (LAPY3 D.lapy3)


newtype LAQGB a = LAQGB {getLAQGB :: Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)}

laqgb :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)
laqgb = getLAQGB $ Class.switchReal (LAQGB S.laqgb) (LAQGB D.laqgb)


newtype LAQGE a = LAQGE {getLAQGE :: IOCArray (Int,Int) a -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)}

laqge :: Class.Real a => IOCArray (Int,Int) a -> CArray Int a -> CArray Int a -> a -> a -> a -> IO (Char)
laqge = getLAQGE $ Class.switchReal (LAQGE S.laqge) (LAQGE D.laqge)


newtype LAQP2 a = LAQP2 {getLAQP2 :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a)}

laqp2 :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IOCArray Int a -> IOCArray Int a -> IO (CArray Int a)
laqp2 = getLAQP2 $ Class.switchReal (LAQP2 S.laqp2) (LAQP2 D.laqp2)


newtype LAQPS a = LAQPS {getLAQPS :: Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int, CArray Int a)}

laqps :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IOCArray Int CInt -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int, CArray Int a)
laqps = getLAQPS $ Class.switchReal (LAQPS S.laqps) (LAQPS D.laqps)


newtype LAQR0 a = LAQR0 {getLAQR0 :: Bool -> Bool -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int)}

laqr0 :: Class.Real a => Bool -> Bool -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int)
laqr0 = getLAQR0 $ Class.switchReal (LAQR0 S.laqr0) (LAQR0 D.laqr0)


newtype LAQR1 a = LAQR1 {getLAQR1 :: CArray (Int,Int) a -> a -> a -> a -> a -> IO (CArray Int a)}

laqr1 :: Class.Real a => CArray (Int,Int) a -> a -> a -> a -> a -> IO (CArray Int a)
laqr1 = getLAQR1 $ Class.switchReal (LAQR1 S.laqr1) (LAQR1 D.laqr1)


newtype LAQR2 a = LAQR2 {getLAQR2 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)}

laqr2 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)
laqr2 = getLAQR2 $ Class.switchReal (LAQR2 S.laqr2) (LAQR2 D.laqr2)


newtype LAQR3 a = LAQR3 {getLAQR3 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)}

laqr3 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (Int, Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)
laqr3 = getLAQR3 $ Class.switchReal (LAQR3 S.laqr3) (LAQR3 D.laqr3)


newtype LAQR4 a = LAQR4 {getLAQR4 :: Bool -> Bool -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int)}

laqr4 :: Class.Real a => Bool -> Bool -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int)
laqr4 = getLAQR4 $ Class.switchReal (LAQR4 S.laqr4) (LAQR4 D.laqr4)


newtype LAQR5 a = LAQR5 {getLAQR5 :: Bool -> Bool -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)}

laqr5 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a)
laqr5 = getLAQR5 $ Class.switchReal (LAQR5 S.laqr5) (LAQR5 D.laqr5)


newtype LAQSB a = LAQSB {getLAQSB :: Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> a -> a -> IO (Char)}

laqsb :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> a -> a -> IO (Char)
laqsb = getLAQSB $ Class.switchReal (LAQSB S.laqsb) (LAQSB D.laqsb)


newtype LAQSP a = LAQSP {getLAQSP :: Char -> IOCArray Int a -> CArray Int a -> a -> a -> IO (Char)}

laqsp :: Class.Real a => Char -> IOCArray Int a -> CArray Int a -> a -> a -> IO (Char)
laqsp = getLAQSP $ Class.switchReal (LAQSP S.laqsp) (LAQSP D.laqsp)


newtype LAQSY a = LAQSY {getLAQSY :: Char -> IOCArray (Int,Int) a -> CArray Int a -> a -> a -> IO (Char)}

laqsy :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int a -> a -> a -> IO (Char)
laqsy = getLAQSY $ Class.switchReal (LAQSY S.laqsy) (LAQSY D.laqsy)


newtype LAQTR a = LAQTR {getLAQTR :: Bool -> Bool -> CArray (Int,Int) a -> CArray Int a -> a -> IOCArray Int a -> IO (a, Int)}

laqtr :: Class.Real a => Bool -> Bool -> CArray (Int,Int) a -> CArray Int a -> a -> IOCArray Int a -> IO (a, Int)
laqtr = getLAQTR $ Class.switchReal (LAQTR S.laqtr) (LAQTR D.laqtr)


newtype LAR1V a = LAR1V {getLAR1V :: Int -> Int -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> a -> IOCArray Int a -> Bool -> Int -> IO (Int, a, a, Int, CArray Int CInt, a, a, a)}

lar1v :: Class.Real a => Int -> Int -> a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> a -> IOCArray Int a -> Bool -> Int -> IO (Int, a, a, Int, CArray Int CInt, a, a, a)
lar1v = getLAR1V $ Class.switchReal (LAR1V S.lar1v) (LAR1V D.lar1v)


newtype LAR2V a = LAR2V {getLAR2V :: Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> Int -> CArray Int a -> CArray Int a -> Int -> IO ()}

lar2v :: Class.Real a => Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> Int -> CArray Int a -> CArray Int a -> Int -> IO ()
lar2v = getLAR2V $ Class.switchReal (LAR2V S.lar2v) (LAR2V D.lar2v)


newtype LARF a = LARF {getLARF :: Char -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larf :: Class.Real a => Char -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larf = getLARF $ Class.switchReal (LARF S.larf) (LARF D.larf)


newtype LARFB a = LARFB {getLARFB :: Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()}

larfb :: Class.Real a => Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()
larfb = getLARFB $ Class.switchReal (LARFB S.larfb) (LARFB D.larfb)


newtype LARFG a = LARFG {getLARFG :: Int -> a -> IOCArray Int a -> Int -> IO (a, a)}

larfg :: Class.Real a => Int -> a -> IOCArray Int a -> Int -> IO (a, a)
larfg = getLARFG $ Class.switchReal (LARFG S.larfg) (LARFG D.larfg)


newtype LARFGP a = LARFGP {getLARFGP :: Int -> a -> IOCArray Int a -> Int -> IO (a, a)}

larfgp :: Class.Real a => Int -> a -> IOCArray Int a -> Int -> IO (a, a)
larfgp = getLARFGP $ Class.switchReal (LARFGP S.larfgp) (LARFGP D.larfgp)


newtype LARFT a = LARFT {getLARFT :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)}

larft :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)
larft = getLARFT $ Class.switchReal (LARFT S.larft) (LARFT D.larft)


newtype LARFX a = LARFX {getLARFX :: Char -> Int -> CArray Int a -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larfx :: Class.Real a => Char -> Int -> CArray Int a -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larfx = getLARFX $ Class.switchReal (LARFX S.larfx) (LARFX D.larfx)


newtype LARGV a = LARGV {getLARGV :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> Int -> IO (CArray Int a)}

largv :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> Int -> IO (CArray Int a)
largv = getLARGV $ Class.switchReal (LARGV S.largv) (LARGV D.largv)


newtype LARNV a = LARNV {getLARNV :: Int -> IOCArray Int CInt -> Int -> IO (CArray Int a)}

larnv :: Class.Real a => Int -> IOCArray Int CInt -> Int -> IO (CArray Int a)
larnv = getLARNV $ Class.switchReal (LARNV S.larnv) (LARNV D.larnv)


newtype LARRA a = LARRA {getLARRA :: CArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> IO (Int, CArray Int CInt, Int)}

larra :: Class.Real a => CArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> IO (Int, CArray Int CInt, Int)
larra = getLARRA $ Class.switchReal (LARRA S.larra) (LARRA D.larra)


newtype LARRB a = LARRB {getLARRB :: CArray Int a -> CArray Int a -> Int -> Int -> a -> a -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> IO (Int)}

larrb :: Class.Real a => CArray Int a -> CArray Int a -> Int -> Int -> a -> a -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> IO (Int)
larrb = getLARRB $ Class.switchReal (LARRB S.larrb) (LARRB D.larrb)


newtype LARRC a = LARRC {getLARRC :: Char -> a -> a -> CArray Int a -> CArray Int a -> a -> IO (Int, Int, Int, Int)}

larrc :: Class.Real a => Char -> a -> a -> CArray Int a -> CArray Int a -> a -> IO (Int, Int, Int, Int)
larrc = getLARRC $ Class.switchReal (LARRC S.larrc) (LARRC D.larrc)


newtype LARRD a = LARRD {getLARRD :: Char -> Char -> a -> a -> Int -> Int -> CArray Int a -> a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> Int -> CArray Int CInt -> IO (Int, CArray Int a, CArray Int a, a, a, CArray Int CInt, CArray Int CInt, Int)}

larrd :: Class.Real a => Char -> Char -> a -> a -> Int -> Int -> CArray Int a -> a -> CArray Int a -> CArray Int a -> CArray Int a -> a -> Int -> CArray Int CInt -> IO (Int, CArray Int a, CArray Int a, a, a, CArray Int CInt, CArray Int CInt, Int)
larrd = getLARRD $ Class.switchReal (LARRD S.larrd) (LARRD D.larrd)


newtype LARRE a = LARRE {getLARRE :: Char -> a -> a -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> a -> IO (a, a, Int, CArray Int CInt, Int, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int a, a, Int)}

larre :: Class.Real a => Char -> a -> a -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> a -> IO (a, a, Int, CArray Int CInt, Int, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int a, a, Int)
larre = getLARRE $ Class.switchReal (LARRE S.larre) (LARRE D.larre)


newtype LARRF a = LARRF {getLARRF :: CArray Int a -> CArray Int a -> CArray Int a -> Int -> Int -> CArray Int a -> IOCArray Int a -> CArray Int a -> a -> a -> a -> a -> IO (a, CArray Int a, CArray Int a, Int)}

larrf :: Class.Real a => CArray Int a -> CArray Int a -> CArray Int a -> Int -> Int -> CArray Int a -> IOCArray Int a -> CArray Int a -> a -> a -> a -> a -> IO (a, CArray Int a, CArray Int a, Int)
larrf = getLARRF $ Class.switchReal (LARRF S.larrf) (LARRF D.larrf)


newtype LARRJ a = LARRJ {getLARRJ :: CArray Int a -> CArray Int a -> Int -> Int -> a -> Int -> IOCArray Int a -> IOCArray Int a -> a -> a -> IO (Int)}

larrj :: Class.Real a => CArray Int a -> CArray Int a -> Int -> Int -> a -> Int -> IOCArray Int a -> IOCArray Int a -> a -> a -> IO (Int)
larrj = getLARRJ $ Class.switchReal (LARRJ S.larrj) (LARRJ D.larrj)


newtype LARRK a = LARRK {getLARRK :: Int -> a -> a -> CArray Int a -> CArray Int a -> a -> a -> IO (a, a, Int)}

larrk :: Class.Real a => Int -> a -> a -> CArray Int a -> CArray Int a -> a -> a -> IO (a, a, Int)
larrk = getLARRK $ Class.switchReal (LARRK S.larrk) (LARRK D.larrk)


newtype LARRR a = LARRR {getLARRR :: CArray Int a -> IOCArray Int a -> IO (Int)}

larrr :: Class.Real a => CArray Int a -> IOCArray Int a -> IO (Int)
larrr = getLARRR $ Class.switchReal (LARRR S.larrr) (LARRR D.larrr)


newtype LARRV a = LARRV {getLARRV :: a -> a -> IOCArray Int a -> IOCArray Int a -> a -> CArray Int CInt -> Int -> Int -> Int -> a -> a -> a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> CArray Int a -> Int -> IO (CArray (Int,Int) a, CArray Int CInt, Int)}

larrv :: Class.Real a => a -> a -> IOCArray Int a -> IOCArray Int a -> a -> CArray Int CInt -> Int -> Int -> Int -> a -> a -> a -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray Int CInt -> CArray Int CInt -> CArray Int a -> Int -> IO (CArray (Int,Int) a, CArray Int CInt, Int)
larrv = getLARRV $ Class.switchReal (LARRV S.larrv) (LARRV D.larrv)


newtype LARTG a = LARTG {getLARTG :: a -> a -> IO (a, a, a)}

lartg :: Class.Real a => a -> a -> IO (a, a, a)
lartg = getLARTG $ Class.switchReal (LARTG S.lartg) (LARTG D.lartg)


newtype LARTGP a = LARTGP {getLARTGP :: a -> a -> IO (a, a, a)}

lartgp :: Class.Real a => a -> a -> IO (a, a, a)
lartgp = getLARTGP $ Class.switchReal (LARTGP S.lartgp) (LARTGP D.lartgp)


newtype LARTGS a = LARTGS {getLARTGS :: a -> a -> a -> IO (a, a)}

lartgs :: Class.Real a => a -> a -> a -> IO (a, a)
lartgs = getLARTGS $ Class.switchReal (LARTGS S.lartgs) (LARTGS D.lartgs)


newtype LARTV a = LARTV {getLARTV :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> CArray Int a -> CArray Int a -> Int -> IO ()}

lartv :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> CArray Int a -> CArray Int a -> Int -> IO ()
lartv = getLARTV $ Class.switchReal (LARTV S.lartv) (LARTV D.lartv)


newtype LARUV a = LARUV {getLARUV :: IOCArray Int CInt -> Int -> IO (CArray Int a)}

laruv :: Class.Real a => IOCArray Int CInt -> Int -> IO (CArray Int a)
laruv = getLARUV $ Class.switchReal (LARUV S.laruv) (LARUV D.laruv)


newtype LARZ a = LARZ {getLARZ :: Char -> Int -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()}

larz :: Class.Real a => Char -> Int -> Int -> CArray Int a -> Int -> a -> IOCArray (Int,Int) a -> Int -> IO ()
larz = getLARZ $ Class.switchReal (LARZ S.larz) (LARZ D.larz)


newtype LARZB a = LARZB {getLARZB :: Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()}

larzb :: Class.Real a => Char -> Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO ()
larzb = getLARZB $ Class.switchReal (LARZB S.larzb) (LARZB D.larzb)


newtype LARZT a = LARZT {getLARZT :: Char -> Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)}

larzt :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (CArray (Int,Int) a)
larzt = getLARZT $ Class.switchReal (LARZT S.larzt) (LARZT D.larzt)


newtype LAS2 a = LAS2 {getLAS2 :: a -> a -> a -> IO (a, a)}

las2 :: Class.Real a => a -> a -> a -> IO (a, a)
las2 = getLAS2 $ Class.switchReal (LAS2 S.las2) (LAS2 D.las2)


newtype LASCL a = LASCL {getLASCL :: Char -> Int -> Int -> a -> a -> Int -> IOCArray (Int,Int) a -> IO (Int)}

lascl :: Class.Real a => Char -> Int -> Int -> a -> a -> Int -> IOCArray (Int,Int) a -> IO (Int)
lascl = getLASCL $ Class.switchReal (LASCL S.lascl) (LASCL D.lascl)


newtype LASD0 a = LASD0 {getLASD0 :: Int -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, Int)}

lasd0 :: Class.Real a => Int -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, Int)
lasd0 = getLASD0 $ Class.switchReal (LASD0 S.lasd0) (LASD0 D.lasd0)


newtype LASD1 a = LASD1 {getLASD1 :: Int -> Int -> Int -> IOCArray Int a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO (a, a, Int)}

lasd1 :: Class.Real a => Int -> Int -> Int -> IOCArray Int a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> IO (a, a, Int)
lasd1 = getLASD1 $ Class.switchReal (LASD1 S.lasd1) (LASD1 D.lasd1)


newtype LASD2 a = LASD2 {getLASD2 :: Int -> Int -> Int -> IOCArray Int a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray Int CInt -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)}

lasd2 :: Class.Real a => Int -> Int -> Int -> IOCArray Int a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IOCArray Int CInt -> IO (Int, CArray Int a, CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)
lasd2 = getLASD2 $ Class.switchReal (LASD2 S.lasd2) (LASD2 D.lasd2)


newtype LASD3 a = LASD3 {getLASD3 :: Int -> Int -> Int -> Int -> IOCArray Int a -> Int -> CArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int CInt -> CArray Int CInt -> IOCArray Int a -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

lasd3 :: Class.Real a => Int -> Int -> Int -> Int -> IOCArray Int a -> Int -> CArray (Int,Int) a -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int CInt -> CArray Int CInt -> IOCArray Int a -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
lasd3 = getLASD3 $ Class.switchReal (LASD3 S.lasd3) (LASD3 D.lasd3)


newtype LASD4 a = LASD4 {getLASD4 :: Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a, Int)}

lasd4 :: Class.Real a => Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a, Int)
lasd4 = getLASD4 $ Class.switchReal (LASD4 S.lasd4) (LASD4 D.lasd4)


newtype LASD5 a = LASD5 {getLASD5 :: Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a)}

lasd5 :: Class.Real a => Int -> CArray Int a -> CArray Int a -> a -> IO (CArray Int a, a)
lasd5 = getLASD5 $ Class.switchReal (LASD5 S.lasd5) (LASD5 D.lasd5)


newtype LASD6 a = LASD6 {getLASD6 :: Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> IOCArray Int CInt -> Int -> Int -> Int -> IO (a, a, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int a, CArray Int a, Int, a, a, Int)}

lasd6 :: Class.Real a => Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> IOCArray Int CInt -> Int -> Int -> Int -> IO (a, a, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int a, CArray Int a, CArray Int a, Int, a, a, Int)
lasd6 = getLASD6 $ Class.switchReal (LASD6 S.lasd6) (LASD6 D.lasd6)


newtype LASD7 a = LASD7 {getLASD7 :: Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> CArray Int CInt -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, a, a, Int)}

lasd7 :: Class.Real a => Int -> Int -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> a -> a -> CArray Int CInt -> Int -> Int -> IO (Int, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) a, a, a, Int)
lasd7 = getLASD7 $ Class.switchReal (LASD7 S.lasd7) (LASD7 D.lasd7)


newtype LASD8 a = LASD8 {getLASD8 :: Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> IOCArray Int a -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, Int)}

lasd8 :: Class.Real a => Int -> IOCArray Int a -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> IOCArray Int a -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a, Int)
lasd8 = getLASD8 $ Class.switchReal (LASD8 S.lasd8) (LASD8 D.lasd8)


newtype LASDA a = LASDA {getLASDA :: Int -> Int -> Int -> IOCArray Int a -> CArray Int a -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray (Int,Int) CInt, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray Int a, CArray Int a, Int)}

lasda :: Class.Real a => Int -> Int -> Int -> IOCArray Int a -> CArray Int a -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray Int CInt, CArray (Int,Int) CInt, CArray (Int,Int) CInt, CArray (Int,Int) a, CArray Int a, CArray Int a, Int)
lasda = getLASDA $ Class.switchReal (LASDA S.lasda) (LASDA D.lasda)


newtype LASDQ a = LASDQ {getLASDQ :: Char -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

lasdq :: Class.Real a => Char -> Int -> Int -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
lasdq = getLASDQ $ Class.switchReal (LASDQ S.lasdq) (LASDQ D.lasdq)


newtype LASET a = LASET {getLASET :: Char -> Int -> Int -> a -> a -> Int -> IO (CArray (Int,Int) a)}

laset :: Class.Real a => Char -> Int -> Int -> a -> a -> Int -> IO (CArray (Int,Int) a)
laset = getLASET $ Class.switchReal (LASET S.laset) (LASET D.laset)


newtype LASQ1 a = LASQ1 {getLASQ1 :: IOCArray Int a -> IOCArray Int a -> IO (Int)}

lasq1 :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IO (Int)
lasq1 = getLASQ1 $ Class.switchReal (LASQ1 S.lasq1) (LASQ1 D.lasq1)


newtype LASQ2 a = LASQ2 {getLASQ2 :: Int -> IOCArray Int a -> IO (Int)}

lasq2 :: Class.Real a => Int -> IOCArray Int a -> IO (Int)
lasq2 = getLASQ2 $ Class.switchReal (LASQ2 S.lasq2) (LASQ2 D.lasq2)


newtype LASQ4 a = LASQ4 {getLASQ4 :: Int -> Int -> CArray Int a -> Int -> Int -> a -> a -> a -> a -> a -> a -> a -> IO (a, Int, a)}

lasq4 :: Class.Real a => Int -> Int -> CArray Int a -> Int -> Int -> a -> a -> a -> a -> a -> a -> a -> IO (a, Int, a)
lasq4 = getLASQ4 $ Class.switchReal (LASQ4 S.lasq4) (LASQ4 D.lasq4)


newtype LASQ5 a = LASQ5 {getLASQ5 :: Int -> Int -> CArray Int a -> Int -> a -> a -> Bool -> a -> IO (a, a, a, a, a, a)}

lasq5 :: Class.Real a => Int -> Int -> CArray Int a -> Int -> a -> a -> Bool -> a -> IO (a, a, a, a, a, a)
lasq5 = getLASQ5 $ Class.switchReal (LASQ5 S.lasq5) (LASQ5 D.lasq5)


newtype LASQ6 a = LASQ6 {getLASQ6 :: Int -> Int -> CArray Int a -> Int -> IO (a, a, a, a, a, a)}

lasq6 :: Class.Real a => Int -> Int -> CArray Int a -> Int -> IO (a, a, a, a, a, a)
lasq6 = getLASQ6 $ Class.switchReal (LASQ6 S.lasq6) (LASQ6 D.lasq6)


newtype LASR a = LASR {getLASR :: Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()}

lasr :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()
lasr = getLASR $ Class.switchReal (LASR S.lasr) (LASR D.lasr)


newtype LASRT a = LASRT {getLASRT :: Char -> IOCArray Int a -> IO (Int)}

lasrt :: Class.Real a => Char -> IOCArray Int a -> IO (Int)
lasrt = getLASRT $ Class.switchReal (LASRT S.lasrt) (LASRT D.lasrt)


newtype LASSQ a = LASSQ {getLASSQ :: CArray Int a -> Int -> a -> a -> IO (a, a)}

lassq :: Class.Real a => CArray Int a -> Int -> a -> a -> IO (a, a)
lassq = getLASSQ $ Class.switchReal (LASSQ S.lassq) (LASSQ D.lassq)


newtype LASV2 a = LASV2 {getLASV2 :: a -> a -> a -> IO (a, a, a, a, a, a)}

lasv2 :: Class.Real a => a -> a -> a -> IO (a, a, a, a, a, a)
lasv2 = getLASV2 $ Class.switchReal (LASV2 S.lasv2) (LASV2 D.lasv2)


newtype LASWP a = LASWP {getLASWP :: IOCArray (Int,Int) a -> Int -> Int -> CArray Int CInt -> Int -> IO ()}

laswp :: Class.Real a => IOCArray (Int,Int) a -> Int -> Int -> CArray Int CInt -> Int -> IO ()
laswp = getLASWP $ Class.switchReal (LASWP S.laswp) (LASWP D.laswp)


newtype LASY2 a = LASY2 {getLASY2 :: Bool -> Bool -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (a, CArray (Int,Int) a, a, Int)}

lasy2 :: Class.Real a => Bool -> Bool -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> IO (a, CArray (Int,Int) a, a, Int)
lasy2 = getLASY2 $ Class.switchReal (LASY2 S.lasy2) (LASY2 D.lasy2)


newtype LASYF a = LASYF {getLASYF :: Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) a, Int)}

lasyf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (Int, CArray Int CInt, CArray (Int,Int) a, Int)
lasyf = getLASYF $ Class.switchReal (LASYF S.lasyf) (LASYF D.lasyf)


newtype LATBS a = LATBS {getLATBS :: Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)}

latbs :: Class.Real a => Char -> Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)
latbs = getLATBS $ Class.switchReal (LATBS S.latbs) (LATBS D.latbs)


newtype LATDF a = LATDF {getLATDF :: Int -> CArray (Int,Int) a -> IOCArray Int a -> a -> a -> CArray Int CInt -> CArray Int CInt -> IO (a, a)}

latdf :: Class.Real a => Int -> CArray (Int,Int) a -> IOCArray Int a -> a -> a -> CArray Int CInt -> CArray Int CInt -> IO (a, a)
latdf = getLATDF $ Class.switchReal (LATDF S.latdf) (LATDF D.latdf)


newtype LATPS a = LATPS {getLATPS :: Char -> Char -> Char -> Char -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)}

latps :: Class.Real a => Char -> Char -> Char -> Char -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)
latps = getLATPS $ Class.switchReal (LATPS S.latps) (LATPS D.latps)


newtype LATRD a = LATRD {getLATRD :: Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a)}

latrd :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray (Int,Int) a)
latrd = getLATRD $ Class.switchReal (LATRD S.latrd) (LATRD D.latrd)


newtype LATRS a = LATRS {getLATRS :: Char -> Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)}

latrs :: Class.Real a => Char -> Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> IOCArray Int a -> IO (a, Int)
latrs = getLATRS $ Class.switchReal (LATRS S.latrs) (LATRS D.latrs)


newtype LATRZ a = LATRZ {getLATRZ :: Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a)}

latrz :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> IO (CArray Int a)
latrz = getLATRZ $ Class.switchReal (LATRZ S.latrz) (LATRZ D.latrz)


newtype LAUU2 a = LAUU2 {getLAUU2 :: Char -> IOCArray (Int,Int) a -> IO (Int)}

lauu2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int)
lauu2 = getLAUU2 $ Class.switchReal (LAUU2 S.lauu2) (LAUU2 D.lauu2)


newtype LAUUM a = LAUUM {getLAUUM :: Char -> IOCArray (Int,Int) a -> IO (Int)}

lauum :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int)
lauum = getLAUUM $ Class.switchReal (LAUUM S.lauum) (LAUUM D.lauum)


newtype ORBDB a = ORBDB {getORBDB :: Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)}

orbdb :: Class.Real a => Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, CArray Int a, Int)
orbdb = getORBDB $ Class.switchReal (ORBDB S.orbdb) (ORBDB D.orbdb)


newtype ORCSD a = ORCSD {getORCSD :: Char -> Char -> Char -> Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, Int)}

orcsd :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> Int -> Int -> IO (CArray Int a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, CArray (Int,Int) a, Int)
orcsd = getORCSD $ Class.switchReal (ORCSD S.orcsd) (ORCSD D.orcsd)


newtype PBCON a = PBCON {getPBCON :: Char -> Int -> CArray (Int,Int) a -> a -> IO (a, Int)}

pbcon :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> a -> IO (a, Int)
pbcon = getPBCON $ Class.switchReal (PBCON S.pbcon) (PBCON D.pbcon)


newtype PBEQU a = PBEQU {getPBEQU :: Char -> Int -> CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)}

pbequ :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)
pbequ = getPBEQU $ Class.switchReal (PBEQU S.pbequ) (PBEQU D.pbequ)


newtype PBRFS a = PBRFS {getPBRFS :: Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

pbrfs :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
pbrfs = getPBRFS $ Class.switchReal (PBRFS S.pbrfs) (PBRFS D.pbrfs)


newtype PBSTF a = PBSTF {getPBSTF :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbstf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbstf = getPBSTF $ Class.switchReal (PBSTF S.pbstf) (PBSTF D.pbstf)


newtype PBSV a = PBSV {getPBSV :: Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

pbsv :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
pbsv = getPBSV $ Class.switchReal (PBSV S.pbsv) (PBSV D.pbsv)


newtype PBSVX a = PBSVX {getPBSVX :: Char -> Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

pbsvx :: Class.Real a => Char -> Char -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
pbsvx = getPBSVX $ Class.switchReal (PBSVX S.pbsvx) (PBSVX D.pbsvx)


newtype PBTF2 a = PBTF2 {getPBTF2 :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbtf2 :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbtf2 = getPBTF2 $ Class.switchReal (PBTF2 S.pbtf2) (PBTF2 D.pbtf2)


newtype PBTRF a = PBTRF {getPBTRF :: Char -> Int -> IOCArray (Int,Int) a -> IO (Int)}

pbtrf :: Class.Real a => Char -> Int -> IOCArray (Int,Int) a -> IO (Int)
pbtrf = getPBTRF $ Class.switchReal (PBTRF S.pbtrf) (PBTRF D.pbtrf)


newtype PBTRS a = PBTRS {getPBTRS :: Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

pbtrs :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
pbtrs = getPBTRS $ Class.switchReal (PBTRS S.pbtrs) (PBTRS D.pbtrs)


newtype PFTRF a = PFTRF {getPFTRF :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

pftrf :: Class.Real a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
pftrf = getPFTRF $ Class.switchReal (PFTRF S.pftrf) (PFTRF D.pftrf)


newtype PFTRI a = PFTRI {getPFTRI :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

pftri :: Class.Real a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
pftri = getPFTRI $ Class.switchReal (PFTRI S.pftri) (PFTRI D.pftri)


newtype PFTRS a = PFTRS {getPFTRS :: Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pftrs :: Class.Real a => Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pftrs = getPFTRS $ Class.switchReal (PFTRS S.pftrs) (PFTRS D.pftrs)


newtype POCON a = POCON {getPOCON :: Char -> CArray (Int,Int) a -> a -> IO (a, Int)}

pocon :: Class.Real a => Char -> CArray (Int,Int) a -> a -> IO (a, Int)
pocon = getPOCON $ Class.switchReal (POCON S.pocon) (POCON D.pocon)


newtype POEQU a = POEQU {getPOEQU :: CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)}

poequ :: Class.Real a => CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)
poequ = getPOEQU $ Class.switchReal (POEQU S.poequ) (POEQU D.poequ)


newtype POEQUB a = POEQUB {getPOEQUB :: CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)}

poequb :: Class.Real a => CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)
poequb = getPOEQUB $ Class.switchReal (POEQUB S.poequb) (POEQUB D.poequb)


newtype PORFS a = PORFS {getPORFS :: Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

porfs :: Class.Real a => Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
porfs = getPORFS $ Class.switchReal (PORFS S.porfs) (PORFS D.porfs)


newtype POSV a = POSV {getPOSV :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

posv :: Class.Real a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
posv = getPOSV $ Class.switchReal (POSV S.posv) (POSV D.posv)


newtype POSVX a = POSVX {getPOSVX :: Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

posvx :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
posvx = getPOSVX $ Class.switchReal (POSVX S.posvx) (POSVX D.posvx)


newtype POTF2 a = POTF2 {getPOTF2 :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potf2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int)
potf2 = getPOTF2 $ Class.switchReal (POTF2 S.potf2) (POTF2 D.potf2)


newtype POTRF a = POTRF {getPOTRF :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potrf :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int)
potrf = getPOTRF $ Class.switchReal (POTRF S.potrf) (POTRF D.potrf)


newtype POTRI a = POTRI {getPOTRI :: Char -> IOCArray (Int,Int) a -> IO (Int)}

potri :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (Int)
potri = getPOTRI $ Class.switchReal (POTRI S.potri) (POTRI D.potri)


newtype POTRS a = POTRS {getPOTRS :: Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

potrs :: Class.Real a => Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
potrs = getPOTRS $ Class.switchReal (POTRS S.potrs) (POTRS D.potrs)


newtype PPCON a = PPCON {getPPCON :: Char -> Int -> CArray Int a -> a -> IO (a, Int)}

ppcon :: Class.Real a => Char -> Int -> CArray Int a -> a -> IO (a, Int)
ppcon = getPPCON $ Class.switchReal (PPCON S.ppcon) (PPCON D.ppcon)


newtype PPEQU a = PPEQU {getPPEQU :: Char -> Int -> CArray Int a -> IO (CArray Int a, a, a, Int)}

ppequ :: Class.Real a => Char -> Int -> CArray Int a -> IO (CArray Int a, a, a, Int)
ppequ = getPPEQU $ Class.switchReal (PPEQU S.ppequ) (PPEQU D.ppequ)


newtype PPRFS a = PPRFS {getPPRFS :: Char -> Int -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

pprfs :: Class.Real a => Char -> Int -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
pprfs = getPPRFS $ Class.switchReal (PPRFS S.pprfs) (PPRFS D.pprfs)


newtype PPSV a = PPSV {getPPSV :: Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

ppsv :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
ppsv = getPPSV $ Class.switchReal (PPSV S.ppsv) (PPSV D.ppsv)


newtype PPSVX a = PPSVX {getPPSVX :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

ppsvx :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> Char -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Char, CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
ppsvx = getPPSVX $ Class.switchReal (PPSVX S.ppsvx) (PPSVX D.ppsvx)


newtype PPTRF a = PPTRF {getPPTRF :: Char -> Int -> IOCArray Int a -> IO (Int)}

pptrf :: Class.Real a => Char -> Int -> IOCArray Int a -> IO (Int)
pptrf = getPPTRF $ Class.switchReal (PPTRF S.pptrf) (PPTRF D.pptrf)


newtype PPTRI a = PPTRI {getPPTRI :: Char -> Int -> IOCArray Int a -> IO (Int)}

pptri :: Class.Real a => Char -> Int -> IOCArray Int a -> IO (Int)
pptri = getPPTRI $ Class.switchReal (PPTRI S.pptri) (PPTRI D.pptri)


newtype PPTRS a = PPTRS {getPPTRS :: Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pptrs :: Class.Real a => Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pptrs = getPPTRS $ Class.switchReal (PPTRS S.pptrs) (PPTRS D.pptrs)


newtype PSTF2 a = PSTF2 {getPSTF2 :: Char -> IOCArray (Int,Int) a -> a -> IO (CArray Int CInt, Int, Int)}

pstf2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> a -> IO (CArray Int CInt, Int, Int)
pstf2 = getPSTF2 $ Class.switchReal (PSTF2 S.pstf2) (PSTF2 D.pstf2)


newtype PSTRF a = PSTRF {getPSTRF :: Char -> IOCArray (Int,Int) a -> a -> IO (CArray Int CInt, Int, Int)}

pstrf :: Class.Real a => Char -> IOCArray (Int,Int) a -> a -> IO (CArray Int CInt, Int, Int)
pstrf = getPSTRF $ Class.switchReal (PSTRF S.pstrf) (PSTRF D.pstrf)


newtype PTCON a = PTCON {getPTCON :: CArray Int a -> CArray Int a -> a -> IO (a, Int)}

ptcon :: Class.Real a => CArray Int a -> CArray Int a -> a -> IO (a, Int)
ptcon = getPTCON $ Class.switchReal (PTCON S.ptcon) (PTCON D.ptcon)


newtype PTEQR a = PTEQR {getPTEQR :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pteqr :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pteqr = getPTEQR $ Class.switchReal (PTEQR S.pteqr) (PTEQR D.pteqr)


newtype PTRFS a = PTRFS {getPTRFS :: CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

ptrfs :: Class.Real a => CArray Int a -> CArray Int a -> CArray Int a -> CArray Int a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
ptrfs = getPTRFS $ Class.switchReal (PTRFS S.ptrfs) (PTRFS D.ptrfs)


newtype PTSV a = PTSV {getPTSV :: IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

ptsv :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
ptsv = getPTSV $ Class.switchReal (PTSV S.ptsv) (PTSV D.ptsv)


newtype PTSVX a = PTSVX {getPTSVX :: Char -> CArray Int a -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

ptsvx :: Class.Real a => Char -> CArray Int a -> CArray Int a -> IOCArray Int a -> IOCArray Int a -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
ptsvx = getPTSVX $ Class.switchReal (PTSVX S.ptsvx) (PTSVX D.ptsvx)


newtype PTTRF a = PTTRF {getPTTRF :: IOCArray Int a -> IOCArray Int a -> IO (Int)}

pttrf :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IO (Int)
pttrf = getPTTRF $ Class.switchReal (PTTRF S.pttrf) (PTTRF D.pttrf)


newtype PTTRS a = PTTRS {getPTTRS :: CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

pttrs :: Class.Real a => CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
pttrs = getPTTRS $ Class.switchReal (PTTRS S.pttrs) (PTTRS D.pttrs)


newtype PTTS2 a = PTTS2 {getPTTS2 :: CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()}

ptts2 :: Class.Real a => CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()
ptts2 = getPTTS2 $ Class.switchReal (PTTS2 S.ptts2) (PTTS2 D.ptts2)


newtype RSCL a = RSCL {getRSCL :: Int -> a -> IOCArray Int a -> Int -> IO ()}

rscl :: Class.Real a => Int -> a -> IOCArray Int a -> Int -> IO ()
rscl = getRSCL $ Class.switchReal (RSCL S.rscl) (RSCL D.rscl)


newtype SPCON a = SPCON {getSPCON :: Char -> CArray Int a -> CArray Int CInt -> a -> IO (a, Int)}

spcon :: Class.Real a => Char -> CArray Int a -> CArray Int CInt -> a -> IO (a, Int)
spcon = getSPCON $ Class.switchReal (SPCON S.spcon) (SPCON D.spcon)


newtype SPRFS a = SPRFS {getSPRFS :: Char -> CArray Int a -> CArray Int a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

sprfs :: Class.Real a => Char -> CArray Int a -> CArray Int a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
sprfs = getSPRFS $ Class.switchReal (SPRFS S.sprfs) (SPRFS D.sprfs)


newtype SPSV a = SPSV {getSPSV :: Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

spsv :: Class.Real a => Char -> Int -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
spsv = getSPSV $ Class.switchReal (SPSV S.spsv) (SPSV D.spsv)


newtype SPSVX a = SPSVX {getSPSVX :: Char -> Char -> CArray Int a -> IOCArray Int a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

spsvx :: Class.Real a => Char -> Char -> CArray Int a -> IOCArray Int a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
spsvx = getSPSVX $ Class.switchReal (SPSVX S.spsvx) (SPSVX D.spsvx)


newtype SPTRF a = SPTRF {getSPTRF :: Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)}

sptrf :: Class.Real a => Char -> Int -> IOCArray Int a -> IO (CArray Int CInt, Int)
sptrf = getSPTRF $ Class.switchReal (SPTRF S.sptrf) (SPTRF D.sptrf)


newtype SPTRI a = SPTRI {getSPTRI :: Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)}

sptri :: Class.Real a => Char -> IOCArray Int a -> CArray Int CInt -> IO (Int)
sptri = getSPTRI $ Class.switchReal (SPTRI S.sptri) (SPTRI D.sptri)


newtype SPTRS a = SPTRS {getSPTRS :: Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sptrs :: Class.Real a => Char -> CArray Int a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sptrs = getSPTRS $ Class.switchReal (SPTRS S.sptrs) (SPTRS D.sptrs)


newtype STEBZ a = STEBZ {getSTEBZ :: Char -> Char -> a -> a -> Int -> Int -> a -> CArray Int a -> CArray Int a -> IO (Int, Int, CArray Int a, CArray Int CInt, CArray Int CInt, Int)}

stebz :: Class.Real a => Char -> Char -> a -> a -> Int -> Int -> a -> CArray Int a -> CArray Int a -> IO (Int, Int, CArray Int a, CArray Int CInt, CArray Int CInt, Int)
stebz = getSTEBZ $ Class.switchReal (STEBZ S.stebz) (STEBZ D.stebz)


newtype STEDC a = STEDC {getSTEDC :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int)}

stedc :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int)
stedc = getSTEDC $ Class.switchReal (STEDC S.stedc) (STEDC D.stedc)


newtype STEGR a = STEGR {getSTEGR :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

stegr :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
stegr = getSTEGR $ Class.switchReal (STEGR S.stegr) (STEGR D.stegr)


newtype STEIN a = STEIN {getSTEIN :: CArray Int a -> CArray Int a -> Int -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> Int -> IO (CArray (Int,Int) a, CArray Int CInt, Int)}

stein :: Class.Real a => CArray Int a -> CArray Int a -> Int -> CArray Int a -> CArray Int CInt -> CArray Int CInt -> Int -> IO (CArray (Int,Int) a, CArray Int CInt, Int)
stein = getSTEIN $ Class.switchReal (STEIN S.stein) (STEIN D.stein)


newtype STEMR a = STEMR {getSTEMR :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Bool, Int)}

stemr :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> Int -> Int -> Int -> Bool -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Bool, Int)
stemr = getSTEMR $ Class.switchReal (STEMR S.stemr) (STEMR D.stemr)


newtype STEQR a = STEQR {getSTEQR :: Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

steqr :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> IOCArray (Int,Int) a -> IO (Int)
steqr = getSTEQR $ Class.switchReal (STEQR S.steqr) (STEQR D.steqr)


newtype STERF a = STERF {getSTERF :: IOCArray Int a -> IOCArray Int a -> IO (Int)}

sterf :: Class.Real a => IOCArray Int a -> IOCArray Int a -> IO (Int)
sterf = getSTERF $ Class.switchReal (STERF S.sterf) (STERF D.sterf)


newtype STEV a = STEV {getSTEV :: Char -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

stev :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
stev = getSTEV $ Class.switchReal (STEV S.stev) (STEV D.stev)


newtype STEVD a = STEVD {getSTEVD :: Char -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, Int)}

stevd :: Class.Real a => Char -> IOCArray Int a -> IOCArray Int a -> Int -> Int -> Int -> Int -> IO (CArray (Int,Int) a, Int)
stevd = getSTEVD $ Class.switchReal (STEVD S.stevd) (STEVD D.stevd)


newtype STEVR a = STEVR {getSTEVR :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

stevr :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
stevr = getSTEVR $ Class.switchReal (STEVR S.stevr) (STEVR D.stevr)


newtype STEVX a = STEVX {getSTEVX :: Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)}

stevx :: Class.Real a => Char -> Char -> IOCArray Int a -> IOCArray Int a -> a -> a -> Int -> Int -> a -> Int -> Int -> IO (Int, CArray Int a, CArray (Int,Int) a, CArray Int CInt, Int)
stevx = getSTEVX $ Class.switchReal (STEVX S.stevx) (STEVX D.stevx)


newtype SYCON a = SYCON {getSYCON :: Char -> CArray (Int,Int) a -> CArray Int CInt -> a -> IO (a, Int)}

sycon :: Class.Real a => Char -> CArray (Int,Int) a -> CArray Int CInt -> a -> IO (a, Int)
sycon = getSYCON $ Class.switchReal (SYCON S.sycon) (SYCON D.sycon)


newtype SYCONV a = SYCONV {getSYCONV :: Char -> Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (CArray Int a, Int)}

syconv :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (CArray Int a, Int)
syconv = getSYCONV $ Class.switchReal (SYCONV S.syconv) (SYCONV D.syconv)


newtype SYEQUB a = SYEQUB {getSYEQUB :: Char -> CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)}

syequb :: Class.Real a => Char -> CArray (Int,Int) a -> IO (CArray Int a, a, a, Int)
syequb = getSYEQUB $ Class.switchReal (SYEQUB S.syequb) (SYEQUB D.syequb)


newtype SYRFS a = SYRFS {getSYRFS :: Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

syrfs :: Class.Real a => Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray Int CInt -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
syrfs = getSYRFS $ Class.switchReal (SYRFS S.syrfs) (SYRFS D.syrfs)


newtype SYSV a = SYSV {getSYSV :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)}

sysv :: Class.Real a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)
sysv = getSYSV $ Class.switchReal (SYSV S.sysv) (SYSV D.sysv)


newtype SYSVX a = SYSVX {getSYSVX :: Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)}

sysvx :: Class.Real a => Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray Int CInt -> CArray (Int,Int) a -> Int -> Int -> IO (CArray (Int,Int) a, a, CArray Int a, CArray Int a, Int)
sysvx = getSYSVX $ Class.switchReal (SYSVX S.sysvx) (SYSVX D.sysvx)


newtype SYSWAPR a = SYSWAPR {getSYSWAPR :: Char -> IOCArray (Int,Int) a -> Int -> Int -> IO ()}

syswapr :: Class.Real a => Char -> IOCArray (Int,Int) a -> Int -> Int -> IO ()
syswapr = getSYSWAPR $ Class.switchReal (SYSWAPR S.syswapr) (SYSWAPR D.syswapr)


newtype SYTD2 a = SYTD2 {getSYTD2 :: Char -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, Int)}

sytd2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, CArray Int a, Int)
sytd2 = getSYTD2 $ Class.switchReal (SYTD2 S.sytd2) (SYTD2 D.sytd2)


newtype SYTF2 a = SYTF2 {getSYTF2 :: Char -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)}

sytf2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> IO (CArray Int CInt, Int)
sytf2 = getSYTF2 $ Class.switchReal (SYTF2 S.sytf2) (SYTF2 D.sytf2)


newtype SYTRD a = SYTRD {getSYTRD :: Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int)}

sytrd :: Class.Real a => Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int)
sytrd = getSYTRD $ Class.switchReal (SYTRD S.sytrd) (SYTRD D.sytrd)


newtype SYTRF a = SYTRF {getSYTRF :: Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)}

sytrf :: Class.Real a => Char -> IOCArray (Int,Int) a -> Int -> IO (CArray Int CInt, Int)
sytrf = getSYTRF $ Class.switchReal (SYTRF S.sytrf) (SYTRF D.sytrf)


newtype SYTRI a = SYTRI {getSYTRI :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (Int)}

sytri :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IO (Int)
sytri = getSYTRI $ Class.switchReal (SYTRI S.sytri) (SYTRI D.sytri)


newtype SYTRI2 a = SYTRI2 {getSYTRI2 :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> Int -> IO (Int)}

sytri2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> Int -> IO (Int)
sytri2 = getSYTRI2 $ Class.switchReal (SYTRI2 S.sytri2) (SYTRI2 D.sytri2)


newtype SYTRI2X a = SYTRI2X {getSYTRI2X :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)}

sytri2x :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> Int -> IO (Int)
sytri2x = getSYTRI2X $ Class.switchReal (SYTRI2X S.sytri2x) (SYTRI2X D.sytri2x)


newtype SYTRS a = SYTRS {getSYTRS :: Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sytrs :: Class.Real a => Char -> CArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sytrs = getSYTRS $ Class.switchReal (SYTRS S.sytrs) (SYTRS D.sytrs)


newtype SYTRS2 a = SYTRS2 {getSYTRS2 :: Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)}

sytrs2 :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int CInt -> IOCArray (Int,Int) a -> IO (Int)
sytrs2 = getSYTRS2 $ Class.switchReal (SYTRS2 S.sytrs2) (SYTRS2 D.sytrs2)


newtype TBCON a = TBCON {getTBCON :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IO (a, Int)}

tbcon :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IO (a, Int)
tbcon = getTBCON $ Class.switchReal (TBCON S.tbcon) (TBCON D.tbcon)


newtype TBRFS a = TBRFS {getTBRFS :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

tbrfs :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
tbrfs = getTBRFS $ Class.switchReal (TBRFS S.tbrfs) (TBRFS D.tbrfs)


newtype TBTRS a = TBTRS {getTBTRS :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

tbtrs :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
tbtrs = getTBTRS $ Class.switchReal (TBTRS S.tbtrs) (TBTRS D.tbtrs)


newtype TFSM a = TFSM {getTFSM :: Char -> Char -> Char -> Char -> Char -> Int -> a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()}

tfsm :: Class.Real a => Char -> Char -> Char -> Char -> Char -> Int -> a -> CArray Int a -> IOCArray (Int,Int) a -> IO ()
tfsm = getTFSM $ Class.switchReal (TFSM S.tfsm) (TFSM D.tfsm)


newtype TFTRI a = TFTRI {getTFTRI :: Char -> Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

tftri :: Class.Real a => Char -> Char -> Char -> Int -> IOCArray Int a -> IO (Int)
tftri = getTFTRI $ Class.switchReal (TFTRI S.tftri) (TFTRI D.tftri)


newtype TFTTP a = TFTTP {getTFTTP :: Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)}

tfttp :: Class.Real a => Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)
tfttp = getTFTTP $ Class.switchReal (TFTTP S.tfttp) (TFTTP D.tfttp)


newtype TFTTR a = TFTTR {getTFTTR :: Char -> Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

tfttr :: Class.Real a => Char -> Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
tfttr = getTFTTR $ Class.switchReal (TFTTR S.tfttr) (TFTTR D.tfttr)


newtype TGEVC a = TGEVC {getTGEVC :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)}

tgevc :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)
tgevc = getTGEVC $ Class.switchReal (TGEVC S.tgevc) (TGEVC D.tgevc)


newtype TGEX2 a = TGEX2 {getTGEX2 :: Bool -> Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (Int)}

tgex2 :: Class.Real a => Bool -> Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> Int -> IO (Int)
tgex2 = getTGEX2 $ Class.switchReal (TGEX2 S.tgex2) (TGEX2 D.tgex2)


newtype TGEXC a = TGEXC {getTGEXC :: Bool -> Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, Int, Int)}

tgexc :: Class.Real a => Bool -> Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> Int -> IO (Int, Int, Int)
tgexc = getTGEXC $ Class.switchReal (TGEXC S.tgexc) (TGEXC D.tgexc)


newtype TGSEN a = TGSEN {getTGSEN :: Int -> Bool -> Bool -> CArray Int Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int, a, a, CArray Int a, Int)}

tgsen :: Class.Real a => Int -> Bool -> Bool -> CArray Int Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, CArray Int a, Int, a, a, CArray Int a, Int)
tgsen = getTGSEN $ Class.switchReal (TGSEN S.tgsen) (TGSEN D.tgsen)


newtype TGSJA a = TGSJA {getTGSJA :: Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int, Int)}

tgsja :: Class.Real a => Char -> Char -> Char -> Int -> Int -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int, Int)
tgsja = getTGSJA $ Class.switchReal (TGSJA S.tgsja) (TGSJA D.tgsja)


newtype TGSNA a = TGSNA {getTGSNA :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)}

tgsna :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)
tgsna = getTGSNA $ Class.switchReal (TGSNA S.tgsna) (TGSNA D.tgsna)


newtype TGSY2 a = TGSY2 {getTGSY2 :: Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> IO (a, a, a, Int, Int)}

tgsy2 :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> a -> a -> IO (a, a, a, Int, Int)
tgsy2 = getTGSY2 $ Class.switchReal (TGSY2 S.tgsy2) (TGSY2 D.tgsy2)


newtype TGSYL a = TGSYL {getTGSYL :: Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (a, a, Int)}

tgsyl :: Class.Real a => Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> IO (a, a, Int)
tgsyl = getTGSYL $ Class.switchReal (TGSYL S.tgsyl) (TGSYL D.tgsyl)


newtype TPCON a = TPCON {getTPCON :: Char -> Char -> Char -> Int -> CArray Int a -> IO (a, Int)}

tpcon :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> IO (a, Int)
tpcon = getTPCON $ Class.switchReal (TPCON S.tpcon) (TPCON D.tpcon)


newtype TPRFS a = TPRFS {getTPRFS :: Char -> Char -> Char -> Int -> CArray Int a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

tprfs :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
tprfs = getTPRFS $ Class.switchReal (TPRFS S.tprfs) (TPRFS D.tprfs)


newtype TPTRI a = TPTRI {getTPTRI :: Char -> Char -> Int -> IOCArray Int a -> IO (Int)}

tptri :: Class.Real a => Char -> Char -> Int -> IOCArray Int a -> IO (Int)
tptri = getTPTRI $ Class.switchReal (TPTRI S.tptri) (TPTRI D.tptri)


newtype TPTRS a = TPTRS {getTPTRS :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)}

tptrs :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray (Int,Int) a -> IO (Int)
tptrs = getTPTRS $ Class.switchReal (TPTRS S.tptrs) (TPTRS D.tptrs)


newtype TPTTF a = TPTTF {getTPTTF :: Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)}

tpttf :: Class.Real a => Char -> Char -> Int -> CArray Int a -> IO (CArray Int a, Int)
tpttf = getTPTTF $ Class.switchReal (TPTTF S.tpttf) (TPTTF D.tpttf)


newtype TPTTR a = TPTTR {getTPTTR :: Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

tpttr :: Class.Real a => Char -> Int -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
tpttr = getTPTTR $ Class.switchReal (TPTTR S.tpttr) (TPTTR D.tpttr)


newtype TRCON a = TRCON {getTRCON :: Char -> Char -> Char -> CArray (Int,Int) a -> IO (a, Int)}

trcon :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) a -> IO (a, Int)
trcon = getTRCON $ Class.switchReal (TRCON S.trcon) (TRCON D.trcon)


newtype TREVC a = TREVC {getTREVC :: Char -> Char -> IOCArray Int Bool -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)}

trevc :: Class.Real a => Char -> Char -> IOCArray Int Bool -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int, Int)
trevc = getTREVC $ Class.switchReal (TREVC S.trevc) (TREVC D.trevc)


newtype TREXC a = TREXC {getTREXC :: Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int, Int, Int)}

trexc :: Class.Real a => Char -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (Int, Int, Int)
trexc = getTREXC $ Class.switchReal (TREXC S.trexc) (TREXC D.trexc)


newtype TRRFS a = TRRFS {getTRRFS :: Char -> Char -> Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)}

trrfs :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> IO (CArray Int a, CArray Int a, Int)
trrfs = getTRRFS $ Class.switchReal (TRRFS S.trrfs) (TRRFS D.trrfs)


newtype TRSEN a = TRSEN {getTRSEN :: Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, a, a, Int)}

trsen :: Class.Real a => Char -> Char -> CArray Int Bool -> IOCArray (Int,Int) a -> IOCArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, a, a, Int)
trsen = getTRSEN $ Class.switchReal (TRSEN S.trsen) (TRSEN D.trsen)


newtype TRSNA a = TRSNA {getTRSNA :: Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)}

trsna :: Class.Real a => Char -> Char -> CArray Int Bool -> CArray (Int,Int) a -> CArray (Int,Int) a -> CArray (Int,Int) a -> Int -> Int -> IO (CArray Int a, CArray Int a, Int, Int)
trsna = getTRSNA $ Class.switchReal (TRSNA S.trsna) (TRSNA D.trsna)


newtype TRSYL a = TRSYL {getTRSYL :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (a, Int)}

trsyl :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (a, Int)
trsyl = getTRSYL $ Class.switchReal (TRSYL S.trsyl) (TRSYL D.trsyl)


newtype TRTI2 a = TRTI2 {getTRTI2 :: Char -> Char -> IOCArray (Int,Int) a -> IO (Int)}

trti2 :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> IO (Int)
trti2 = getTRTI2 $ Class.switchReal (TRTI2 S.trti2) (TRTI2 D.trti2)


newtype TRTRI a = TRTRI {getTRTRI :: Char -> Char -> IOCArray (Int,Int) a -> IO (Int)}

trtri :: Class.Real a => Char -> Char -> IOCArray (Int,Int) a -> IO (Int)
trtri = getTRTRI $ Class.switchReal (TRTRI S.trtri) (TRTRI D.trtri)


newtype TRTRS a = TRTRS {getTRTRS :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)}

trtrs :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO (Int)
trtrs = getTRTRS $ Class.switchReal (TRTRS S.trtrs) (TRTRS D.trtrs)


newtype TRTTF a = TRTTF {getTRTTF :: Char -> Char -> CArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

trttf :: Class.Real a => Char -> Char -> CArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
trttf = getTRTTF $ Class.switchReal (TRTTF S.trttf) (TRTTF D.trttf)


newtype TRTTP a = TRTTP {getTRTTP :: Char -> CArray (Int,Int) a -> IO (CArray Int a, Int)}

trttp :: Class.Real a => Char -> CArray (Int,Int) a -> IO (CArray Int a, Int)
trttp = getTRTTP $ Class.switchReal (TRTTP S.trttp) (TRTTP D.trttp)


newtype TZRZF a = TZRZF {getTZRZF :: Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)}

tzrzf :: Class.Real a => Int -> IOCArray (Int,Int) a -> Int -> IO (CArray Int a, Int)
tzrzf = getTZRZF $ Class.switchReal (TZRZF S.tzrzf) (TZRZF D.tzrzf)


newtype ORG2L a = ORG2L {getORG2L :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

org2l :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
org2l = getORG2L $ Class.switchReal (ORG2L S.org2l) (ORG2L D.org2l)


newtype ORG2R a = ORG2R {getORG2R :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

org2r :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
org2r = getORG2R $ Class.switchReal (ORG2R S.org2r) (ORG2R D.org2r)


newtype ORGBR a = ORGBR {getORGBR :: Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orgbr :: Class.Real a => Char -> Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orgbr = getORGBR $ Class.switchReal (ORGBR S.orgbr) (ORGBR D.orgbr)


newtype ORGHR a = ORGHR {getORGHR :: Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orghr :: Class.Real a => Int -> Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orghr = getORGHR $ Class.switchReal (ORGHR S.orghr) (ORGHR D.orghr)


newtype ORGL2 a = ORGL2 {getORGL2 :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

orgl2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
orgl2 = getORGL2 $ Class.switchReal (ORGL2 S.orgl2) (ORGL2 D.orgl2)


newtype ORGLQ a = ORGLQ {getORGLQ :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orglq :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orglq = getORGLQ $ Class.switchReal (ORGLQ S.orglq) (ORGLQ D.orglq)


newtype ORGQL a = ORGQL {getORGQL :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orgql :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orgql = getORGQL $ Class.switchReal (ORGQL S.orgql) (ORGQL D.orgql)


newtype ORGQR a = ORGQR {getORGQR :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orgqr :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orgqr = getORGQR $ Class.switchReal (ORGQR S.orgqr) (ORGQR D.orgqr)


newtype ORGR2 a = ORGR2 {getORGR2 :: Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)}

orgr2 :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> IO (Int)
orgr2 = getORGR2 $ Class.switchReal (ORGR2 S.orgr2) (ORGR2 D.orgr2)


newtype ORGRQ a = ORGRQ {getORGRQ :: Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orgrq :: Class.Real a => Int -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orgrq = getORGRQ $ Class.switchReal (ORGRQ S.orgrq) (ORGRQ D.orgrq)


newtype ORGTR a = ORGTR {getORGTR :: Char -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)}

orgtr :: Class.Real a => Char -> IOCArray (Int,Int) a -> CArray Int a -> Int -> IO (Int)
orgtr = getORGTR $ Class.switchReal (ORGTR S.orgtr) (ORGTR D.orgtr)


newtype ORM2L a = ORM2L {getORM2L :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

orm2l :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
orm2l = getORM2L $ Class.switchReal (ORM2L S.orm2l) (ORM2L D.orm2l)


newtype ORM2R a = ORM2R {getORM2R :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

orm2r :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
orm2r = getORM2R $ Class.switchReal (ORM2R S.orm2r) (ORM2R D.orm2r)


newtype ORMBR a = ORMBR {getORMBR :: Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormbr :: Class.Real a => Char -> Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormbr = getORMBR $ Class.switchReal (ORMBR S.ormbr) (ORMBR D.ormbr)


newtype ORMHR a = ORMHR {getORMHR :: Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormhr :: Class.Real a => Char -> Char -> Int -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormhr = getORMHR $ Class.switchReal (ORMHR S.ormhr) (ORMHR D.ormhr)


newtype ORML2 a = ORML2 {getORML2 :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

orml2 :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
orml2 = getORML2 $ Class.switchReal (ORML2 S.orml2) (ORML2 D.orml2)


newtype ORMLQ a = ORMLQ {getORMLQ :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormlq :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormlq = getORMLQ $ Class.switchReal (ORMLQ S.ormlq) (ORMLQ D.ormlq)


newtype ORMQL a = ORMQL {getORMQL :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormql :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormql = getORMQL $ Class.switchReal (ORMQL S.ormql) (ORMQL D.ormql)


newtype ORMQR a = ORMQR {getORMQR :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormqr :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormqr = getORMQR $ Class.switchReal (ORMQR S.ormqr) (ORMQR D.ormqr)


newtype ORMR2 a = ORMR2 {getORMR2 :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormr2 :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormr2 = getORMR2 $ Class.switchReal (ORMR2 S.ormr2) (ORMR2 D.ormr2)


newtype ORMR3 a = ORMR3 {getORMR3 :: Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormr3 :: Class.Real a => Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormr3 = getORMR3 $ Class.switchReal (ORMR3 S.ormr3) (ORMR3 D.ormr3)


newtype ORMRQ a = ORMRQ {getORMRQ :: Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormrq :: Class.Real a => Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormrq = getORMRQ $ Class.switchReal (ORMRQ S.ormrq) (ORMRQ D.ormrq)


newtype ORMRZ a = ORMRZ {getORMRZ :: Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormrz :: Class.Real a => Char -> Char -> Int -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormrz = getORMRZ $ Class.switchReal (ORMRZ S.ormrz) (ORMRZ D.ormrz)


newtype ORMTR a = ORMTR {getORMTR :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

ormtr :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
ormtr = getORMTR $ Class.switchReal (ORMTR S.ormtr) (ORMTR D.ormtr)


newtype OPGTR a = OPGTR {getOPGTR :: Char -> Int -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)}

opgtr :: Class.Real a => Char -> Int -> CArray Int a -> CArray Int a -> Int -> IO (CArray (Int,Int) a, Int)
opgtr = getOPGTR $ Class.switchReal (OPGTR S.opgtr) (OPGTR D.opgtr)


newtype OPMTR a = OPMTR {getOPMTR :: Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)}

opmtr :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> CArray Int a -> IOCArray (Int,Int) a -> Int -> IO (Int)
opmtr = getOPMTR $ Class.switchReal (OPMTR S.opmtr) (OPMTR D.opmtr)
