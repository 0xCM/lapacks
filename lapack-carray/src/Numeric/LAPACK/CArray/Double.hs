-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.CArray.Double where

import qualified Numeric.LAPACK.FFI.Double as FFI
import qualified Numeric.Netlib.CArray.Utility as Call
import Numeric.Netlib.CArray.Utility ((^!))

import Data.Array.IOCArray (IOCArray, getBounds)
import Data.Array.CArray (CArray, bounds)

import Foreign.Storable (peek)
import Foreign.Ptr (Ptr, FunPtr)
import Foreign.C.String (castCCharToChar)
import Foreign.C.Types (CInt)

import Control.Monad.Trans.Cont (evalContT)
import Control.Monad.IO.Class (liftIO)
import Control.Applicative (pure, (<*>), (<$>))


-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dbbcsd.f>
bbcsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOCArray Int Double {- ^ theta -} ->
   IOCArray Int Double {- ^ phi -} ->
   IOCArray (Int,Int) Double {- ^ u1 -} ->
   IOCArray (Int,Int) Double {- ^ u2 -} ->
   IOCArray (Int,Int) Double {- ^ v1t -} ->
   IOCArray (Int,Int) Double {- ^ v2t -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, Int)
bbcsd jobu1 jobu2 jobv1t jobv2t trans m theta phi u1 u2 v1t v2t lwork = do
   thetaDim0 <- Call.sizes1 <$> getBounds theta
   phiDim0 <- Call.sizes1 <$> getBounds phi
   (u1Dim0,u1Dim1) <- Call.sizes2 <$> getBounds u1
   (u2Dim0,u2Dim1) <- Call.sizes2 <$> getBounds u2
   (v1tDim0,v1tDim1) <- Call.sizes2 <$> getBounds v1t
   (v2tDim0,v2tDim1) <- Call.sizes2 <$> getBounds v2t
   let q = thetaDim0
   let p = u1Dim0
   let ldu1 = u1Dim1
   let ldu2 = u2Dim1
   let ldv1t = v1tDim1
   let ldv2t = v2tDim1
   Call.assert "bbcsd: q-1 == phiDim0" (q-1 == phiDim0)
   Call.assert "bbcsd: m-p == u2Dim0" (m-p == u2Dim0)
   Call.assert "bbcsd: q == v1tDim0" (q == v1tDim0)
   Call.assert "bbcsd: m-q == v2tDim0" (m-q == v2tDim0)
   b11d <- Call.newArray1 q
   b11e <- Call.newArray1 (q-1)
   b12d <- Call.newArray1 q
   b12e <- Call.newArray1 (q-1)
   b21d <- Call.newArray1 q
   b21e <- Call.newArray1 (q-1)
   b22d <- Call.newArray1 q
   b22e <- Call.newArray1 (q-1)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      b11dPtr <- Call.ioarray b11d
      b11ePtr <- Call.ioarray b11e
      b12dPtr <- Call.ioarray b12d
      b12ePtr <- Call.ioarray b12e
      b21dPtr <- Call.ioarray b21d
      b21ePtr <- Call.ioarray b21e
      b22dPtr <- Call.ioarray b22d
      b22ePtr <- Call.ioarray b22e
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bbcsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr mPtr pPtr qPtr thetaPtr phiPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr b11dPtr b11ePtr b12dPtr b12ePtr b21dPtr b21ePtr b22dPtr b22ePtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,,,,)
         <*> Call.freezeArray b11d
         <*> Call.freezeArray b11e
         <*> Call.freezeArray b12d
         <*> Call.freezeArray b12e
         <*> Call.freezeArray b21d
         <*> Call.freezeArray b21e
         <*> Call.freezeArray b22d
         <*> Call.freezeArray b22e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dbdsdc.f>
bdsdc ::
   Char {- ^ uplo -} ->
   Char {- ^ compq -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ ldq -} ->
   Int {- ^ ldiq -} ->
   Int {- ^ lwork -} ->
   IO (CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int Double, CArray Int CInt, Int)
bdsdc uplo compq d e ldu ldvt ldq ldiq lwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "bdsdc: n-1 == eDim0" (n-1 == eDim0)
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 n ldvt
   q <- Call.newArray1 ldq
   iq <- Call.newArray1 ldiq
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (8*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      compqPtr <- Call.char compq
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      qPtr <- Call.ioarray q
      iqPtr <- Call.ioarray iq
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bdsdc uploPtr compqPtr nPtr dPtr ePtr uPtr lduPtr vtPtr ldvtPtr qPtr iqPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> Call.freezeArray q
         <*> Call.freezeArray iq
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dbdsqr.f>
bdsqr ::
   Char {- ^ uplo -} ->
   Int {- ^ nru -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ vt -} ->
   IOCArray (Int,Int) Double {- ^ u -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   IO (Int)
bdsqr uplo nru d e vt u c = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (vtDim0,vtDim1) <- Call.sizes2 <$> getBounds vt
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = dDim0
   let ncvt = vtDim0
   let ldvt = vtDim1
   let ldu = uDim1
   let ncc = cDim0
   let ldc = cDim1
   Call.assert "bdsqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "bdsqr: n == uDim0" (n == uDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      ncvtPtr <- Call.cint ncvt
      nruPtr <- Call.cint nru
      nccPtr <- Call.cint ncc
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.bdsqr uploPtr nPtr ncvtPtr nruPtr nccPtr dPtr ePtr vtPtr ldvtPtr uPtr lduPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ddisna.f>
disna ::
   Char {- ^ job -} ->
   Int {- ^ m -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ d -} ->
   Int {- ^ sepSize -} ->
   IO (CArray Int Double, Int)
disna job m n d sepSize = do
   let dDim0 = Call.sizes1 $ bounds d
   let _dSize = dDim0
   sep <- Call.newArray1 sepSize
   evalContT $ do
      jobPtr <- Call.char job
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      dPtr <- Call.array d
      sepPtr <- Call.ioarray sep
      infoPtr <- Call.alloca
      liftIO $ FFI.disna jobPtr mPtr nPtr dPtr sepPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sep
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbbrd.f>
gbbrd ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Int {- ^ ldpt -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   IO (CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
gbbrd vect m kl ku ab ldq ldpt c = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = abDim0
   let ldab = abDim1
   let ncc = cDim0
   let ldc = cDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   q <- Call.newArray2 m ldq
   pt <- Call.newArray2 n ldpt
   work <- Call.newArray1 (2*maximum[m,n])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nccPtr <- Call.cint ncc
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ptPtr <- Call.ioarray pt
      ldptPtr <- Call.cint ldpt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gbbrd vectPtr mPtr nPtr nccPtr klPtr kuPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr ptPtr ldptPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray q
         <*> Call.freezeArray pt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbcon.f>
gbcon ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
gbcon norm kl ku ab ipiv anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = abDim0
   let ldab = abDim1
   Call.assert "gbcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbcon normPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbequ.f>
gbequ ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IO (CArray Int Double, CArray Int Double, Double, Double, Double, Int)
gbequ m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequ mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbequb.f>
gbequb ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IO (CArray Int Double, CArray Int Double, Double, Double, Double, Int)
gbequb m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbrfs.f>
gbrfs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   CArray (Int,Int) Double {- ^ afb -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
gbrfs trans kl ku ab afb ipiv b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (afbDim0,afbDim1) = Call.sizes2 $ bounds afb
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "gbrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbrfs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbsv.f>
gbsv ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (CArray Int CInt, Int)
gbsv kl ku ab b = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsv nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbsvx.f>
gbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ afb -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOCArray Int Double {- ^ r -} ->
   IOCArray Int Double {- ^ c -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
gbsvx fact trans kl ku ab afb ipiv equed r c b ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (afbDim0,afbDim1) <- Call.sizes2 <$> getBounds afb
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   rDim0 <- Call.sizes1 <$> getBounds r
   cDim0 <- Call.sizes1 <$> getBounds c
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "gbsvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbsvx: n == rDim0" (n == rDim0)
   Call.assert "gbsvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsvx factPtr transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbtf2.f>
gbtf2 ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IO (CArray Int CInt, Int)
gbtf2 m kl ku ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtf2 mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbtrf.f>
gbtrf ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IO (CArray Int CInt, Int)
gbtrf m kl ku ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrf mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgbtrs.f>
gbtrs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
gbtrs trans kl ku ab ipiv b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbtrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgebak.f>
gebak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray Int Double {- ^ scale -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   IO (Int)
gebak job side ilo ihi scale v = do
   let scaleDim0 = Call.sizes1 $ bounds scale
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = scaleDim0
   let m = vDim0
   let ldv = vDim1
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      scalePtr <- Call.array scale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.gebak jobPtr sidePtr nPtr iloPtr ihiPtr scalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgebal.f>
gebal ::
   Char {- ^ job -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int, Int, CArray Int Double, Int)
gebal job a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   scale <- Call.newArray1 n
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      infoPtr <- Call.alloca
      liftIO $ FFI.gebal jobPtr nPtr aPtr ldaPtr iloPtr ihiPtr scalePtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgebd2.f>
gebd2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, Int)
gebd2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gebd2 mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgebrd.f>
gebrd ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, Int)
gebrd m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gebrd mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgecon.f>
gecon ::
   Char {- ^ norm -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
gecon norm a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gecon normPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeequ.f>
geequ ::
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, CArray Int Double, Double, Double, Double, Int)
geequ m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequ mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeequb.f>
geequb ::
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, CArray Int Double, Double, Double, Double, Int)
geequb m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequb mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgees.f>
gees ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Double -> Ptr Double -> IO Bool) {- ^ select -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, Int)
gees jobvs sort select a ldvs lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gees jobvsPtr sortPtr selectPtr nPtr aPtr ldaPtr sdimPtr wrPtr wiPtr vsPtr ldvsPtr workPtr lworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vs
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeesx.f>
geesx ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Double -> Ptr Double -> IO Bool) {- ^ select -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, Double, Double, Int)
geesx jobvs sort select sense a ldvs lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      rcondePtr <- Call.alloca
      rcondvPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geesx jobvsPtr sortPtr selectPtr sensePtr nPtr aPtr ldaPtr sdimPtr wrPtr wiPtr vsPtr ldvsPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr liworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vs
         <*> peek rcondePtr
         <*> peek rcondvPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeev.f>
geev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
geev jobvl jobvr a ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geev jobvlPtr jobvrPtr nPtr aPtr ldaPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeevx.f>
geevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int, Int, CArray Int Double, Double, CArray Int Double, CArray Int Double, Int)
geevx balanc jobvl jobvr sense a ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   scale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (2*n-2)
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      abnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr scalePtr abnrmPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> peek abnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgehd2.f>
gehd2 ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
gehd2 ilo ihi a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gehd2 nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgehrd.f>
gehrd ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
gehrd ilo ihi a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 lwork
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gehrd nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgejsv.f>
gejsv ::
   Char {- ^ joba -} ->
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Char {- ^ jobr -} ->
   Char {- ^ jobt -} ->
   Char {- ^ jobp -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldv -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
gejsv joba jobu jobv jobr jobt jobp m a ldu ldv lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   sva <- Call.newArray1 n
   u <- Call.newArray2 n ldu
   v <- Call.newArray2 n ldv
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 (m+3*n)
   evalContT $ do
      jobaPtr <- Call.char joba
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      jobrPtr <- Call.char jobr
      jobtPtr <- Call.char jobt
      jobpPtr <- Call.char jobp
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      svaPtr <- Call.ioarray sva
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gejsv jobaPtr jobuPtr jobvPtr jobrPtr jobtPtr jobpPtr mPtr nPtr aPtr ldaPtr svaPtr uPtr lduPtr vPtr ldvPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray sva
         <*> Call.freezeArray u
         <*> Call.freezeArray v
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgelq2.f>
gelq2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
gelq2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gelq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgelqf.f>
gelqf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
gelqf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgels.f>
gels ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gels trans m a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gels transPtr mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgelsd.f>
gelsd ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, Int, Int)
gelsd m a b rcond lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.double rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsd mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgelss.f>
gelss ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int, Int)
gelss m a b rcond lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.double rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelss mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgelsy.f>
gelsy ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Double {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int)
gelsy m a b jpvt rcond lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gelsy: n == jpvtDim0" (n == jpvtDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      jpvtPtr <- Call.ioarray jpvt
      rcondPtr <- Call.double rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsy mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr jpvtPtr rcondPtr rankPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeql2.f>
geql2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
geql2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geql2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqlf.f>
geqlf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
geqlf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqlf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqp3.f>
geqp3 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
geqp3 m a jpvt lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   let n = aDim0
   let lda = aDim1
   Call.assert "geqp3: n == jpvtDim0" (n == jpvtDim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqp3 mPtr nPtr aPtr ldaPtr jpvtPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqr2.f>
geqr2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
geqr2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqr2p.f>
geqr2p ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
geqr2p m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2p mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqrf.f>
geqrf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
geqrf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgeqrfp.f>
geqrfp ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
geqrfp m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrfp mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgerfs.f>
gerfs ::
   Char {- ^ trans -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ af -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
gerfs trans a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gerfs: n == afDim0" (n == afDim0)
   Call.assert "gerfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gerfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerfs transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgerq2.f>
gerq2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
gerq2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gerq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgerqf.f>
gerqf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
gerqf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesc2.f>
gesc2 ::
   CArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int Double {- ^ rhs -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray Int CInt {- ^ jpiv -} ->
   IO (Double)
gesc2 a rhs ipiv jpiv = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   rhsDim0 <- Call.sizes1 <$> getBounds rhs
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let jpivDim0 = Call.sizes1 $ bounds jpiv
   let n = aDim0
   let lda = aDim1
   Call.assert "gesc2: n == rhsDim0" (n == rhsDim0)
   Call.assert "gesc2: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesc2: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rhsPtr <- Call.ioarray rhs
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      scalePtr <- Call.alloca
      liftIO $ FFI.gesc2 nPtr aPtr ldaPtr rhsPtr ipivPtr jpivPtr scalePtr
      liftIO $ peek scalePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesdd.f>
gesdd ::
   Char {- ^ jobz -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
gesdd jobz m a ucol ldu ldvt lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (8*minimum[m,n])
   evalContT $ do
      jobzPtr <- Call.char jobz
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesdd jobzPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesv.f>
gesv ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (CArray Int CInt, Int)
gesv a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gesv nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesvd.f>
gesvd ::
   Char {- ^ jobu -} ->
   Char {- ^ jobvt -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
gesvd jobu jobvt m a ucol ldu ldvt lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvtPtr <- Call.char jobvt
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvd jobuPtr jobvtPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesvj.f>
gesvj ::
   Char {- ^ joba -} ->
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ mv -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   IOCArray Int Double {- ^ work -} ->
   IO (CArray Int Double, Int)
gesvj joba jobu jobv m a mv v work = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   workDim0 <- Call.sizes1 <$> getBounds work
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   let lwork = workDim0
   Call.assert "gesvj: n == vDim0" (n == vDim0)
   sva <- Call.newArray1 n
   evalContT $ do
      jobaPtr <- Call.char joba
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvj jobaPtr jobuPtr jobvPtr mPtr nPtr aPtr ldaPtr svaPtr mvPtr vPtr ldvPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sva
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgesvx.f>
gesvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ af -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOCArray Int Double {- ^ r -} ->
   IOCArray Int Double {- ^ c -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
gesvx fact trans a af ipiv equed r c b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   rDim0 <- Call.sizes1 <$> getBounds r
   cDim0 <- Call.sizes1 <$> getBounds c
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gesvx: n == afDim0" (n == afDim0)
   Call.assert "gesvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesvx: n == rDim0" (n == rDim0)
   Call.assert "gesvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvx factPtr transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgetc2.f>
getc2 ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int CInt, CArray Int CInt, Int)
getc2 a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   jpiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      jpivPtr <- Call.ioarray jpiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getc2 nPtr aPtr ldaPtr ipivPtr jpivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray jpiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgetf2.f>
getf2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int CInt, Int)
getf2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getf2 mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgetrf.f>
getrf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int CInt, Int)
getrf m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getrf mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgetri.f>
getri ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ lwork -} ->
   IO (Int)
getri a ipiv lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "getri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.getri nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgetrs.f>
getrs ::
   Char {- ^ trans -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
getrs trans a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "getrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.getrs transPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggbak.f>
ggbak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray Int Double {- ^ lscale -} ->
   CArray Int Double {- ^ rscale -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   IO (Int)
ggbak job side ilo ihi lscale rscale v = do
   let lscaleDim0 = Call.sizes1 $ bounds lscale
   let rscaleDim0 = Call.sizes1 $ bounds rscale
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = lscaleDim0
   let m = vDim0
   let ldv = vDim1
   Call.assert "ggbak: n == rscaleDim0" (n == rscaleDim0)
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      lscalePtr <- Call.array lscale
      rscalePtr <- Call.array rscale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbak jobPtr sidePtr nPtr iloPtr ihiPtr lscalePtr rscalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggbal.f>
ggbal ::
   Char {- ^ job -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int Double, CArray Int Double, Int)
ggbal job a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggbal: n == bDim0" (n == bDim0)
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbal jobPtr nPtr aPtr ldaPtr bPtr ldbPtr iloPtr ihiPtr lscalePtr rscalePtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgges.f>
gges ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Double -> Ptr Double -> Ptr Double -> IO Bool) {- ^ selctg -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
gges jobvsl jobvsr sort selctg a b ldvsl ldvsr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "gges: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   work <- Call.newArray1 (maximum[1,lwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gges jobvslPtr jobvsrPtr sortPtr selctgPtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alpharPtr alphaiPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr workPtr lworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggesx.f>
ggesx ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Double -> Ptr Double -> Ptr Double -> IO Bool) {- ^ selctg -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int Double, CArray Int Double, Int)
ggesx jobvsl jobvsr sort selctg sense a b ldvsl ldvsr lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggesx: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   rconde <- Call.newArray1 2
   rcondv <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggesx jobvslPtr jobvsrPtr sortPtr selctgPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alpharPtr alphaiPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr liworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggev.f>
ggev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
ggev jobvl jobvr a b ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggev: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggev jobvlPtr jobvrPtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggevx.f>
ggevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int, Int, CArray Int Double, CArray Int Double, Double, Double, CArray Int Double, CArray Int Double, Int)
ggevx balanc jobvl jobvr sense a b ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggevx: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (n+6)
   bwork <- Call.newArray1 n
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      abnrmPtr <- Call.alloca
      bbnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr lscalePtr rscalePtr abnrmPtr bbnrmPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> peek abnrmPtr
         <*> peek bbnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggglm.f>
ggglm ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray Int Double {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
ggglm a b d lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   dDim0 <- Call.sizes1 <$> getBounds d
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   let n = dDim0
   x <- Call.newArray1 m
   y <- Call.newArray1 p
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggglm nPtr mPtr pPtr aPtr ldaPtr bPtr ldbPtr dPtr xPtr yPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray x
         <*> Call.freezeArray y
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgghrd.f>
gghrd ::
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   IO (Int)
gghrd compq compz ilo ihi a b q z = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "gghrd: n == bDim0" (n == bDim0)
   Call.assert "gghrd: n == qDim0" (n == qDim0)
   Call.assert "gghrd: n == zDim0" (n == zDim0)
   evalContT $ do
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.gghrd compqPtr compzPtr nPtr iloPtr ihiPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgglse.f>
gglse ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray Int Double {- ^ c -} ->
   IOCArray Int Double {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
gglse a b c d lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   cDim0 <- Call.sizes1 <$> getBounds c
   dDim0 <- Call.sizes1 <$> getBounds d
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = cDim0
   let p = dDim0
   Call.assert "gglse: n == bDim0" (n == bDim0)
   x <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gglse mPtr nPtr pPtr aPtr ldaPtr bPtr ldbPtr cPtr dPtr xPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggqrf.f>
ggqrf ::
   Int {- ^ n -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
ggqrf n a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   taua <- Call.newArray1 (minimum[n,m])
   taub <- Call.newArray1 (minimum[n,p])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggqrf nPtr mPtr pPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dggrqf.f>
ggrqf ::
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
ggrqf m p a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggrqf: n == bDim0" (n == bDim0)
   taua <- Call.newArray1 (minimum[m,n])
   taub <- Call.newArray1 (minimum[p,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggrqf mPtr pPtr nPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgsvj0.f>
gsvj0 ::
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ sva -} ->
   Int {- ^ mv -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   Double {- ^ eps -} ->
   Double {- ^ sfmin -} ->
   Double {- ^ tol -} ->
   Int {- ^ nsweep -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gsvj0 jobv m a d sva mv v eps sfmin tol nsweep lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   dDim0 <- Call.sizes1 <$> getBounds d
   svaDim0 <- Call.sizes1 <$> getBounds sva
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   Call.assert "gsvj0: n == dDim0" (n == dDim0)
   Call.assert "gsvj0: n == svaDim0" (n == svaDim0)
   Call.assert "gsvj0: n == vDim0" (n == vDim0)
   work <- Call.newArray1 lwork
   evalContT $ do
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      epsPtr <- Call.double eps
      sfminPtr <- Call.double sfmin
      tolPtr <- Call.double tol
      nsweepPtr <- Call.cint nsweep
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gsvj0 jobvPtr mPtr nPtr aPtr ldaPtr dPtr svaPtr mvPtr vPtr ldvPtr epsPtr sfminPtr tolPtr nsweepPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgsvj1.f>
gsvj1 ::
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   Int {- ^ n1 -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ sva -} ->
   Int {- ^ mv -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   Double {- ^ eps -} ->
   Double {- ^ sfmin -} ->
   Double {- ^ tol -} ->
   Int {- ^ nsweep -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gsvj1 jobv m n1 a d sva mv v eps sfmin tol nsweep lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   dDim0 <- Call.sizes1 <$> getBounds d
   svaDim0 <- Call.sizes1 <$> getBounds sva
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   Call.assert "gsvj1: n == dDim0" (n == dDim0)
   Call.assert "gsvj1: n == svaDim0" (n == svaDim0)
   Call.assert "gsvj1: n == vDim0" (n == vDim0)
   work <- Call.newArray1 lwork
   evalContT $ do
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      epsPtr <- Call.double eps
      sfminPtr <- Call.double sfmin
      tolPtr <- Call.double tol
      nsweepPtr <- Call.cint nsweep
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gsvj1 jobvPtr mPtr nPtr n1Ptr aPtr ldaPtr dPtr svaPtr mvPtr vPtr ldvPtr epsPtr sfminPtr tolPtr nsweepPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgtcon.f>
gtcon ::
   Char {- ^ norm -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   CArray Int Double {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
gtcon norm dl d du du2 ipiv anorm = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = dDim0
   Call.assert "gtcon: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtcon: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtcon: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtcon normPtr nPtr dlPtr dPtr duPtr du2Ptr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgtrfs.f>
gtrfs ::
   Char {- ^ trans -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   CArray Int Double {- ^ dlf -} ->
   CArray Int Double {- ^ df -} ->
   CArray Int Double {- ^ duf -} ->
   CArray Int Double {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
gtrfs trans dl d du dlf df duf du2 ipiv b x = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let dlfDim0 = Call.sizes1 $ bounds dlf
   let dfDim0 = Call.sizes1 $ bounds df
   let dufDim0 = Call.sizes1 $ bounds duf
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gtrfs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtrfs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtrfs: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtrfs: n == dfDim0" (n == dfDim0)
   Call.assert "gtrfs: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtrfs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gtrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.array dlf
      dfPtr <- Call.array df
      dufPtr <- Call.array duf
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtrfs transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgtsv.f>
gtsv ::
   IOCArray Int Double {- ^ dl -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ du -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
gtsv dl d du b = do
   dlDim0 <- Call.sizes1 <$> getBounds dl
   dDim0 <- Call.sizes1 <$> getBounds d
   duDim0 <- Call.sizes1 <$> getBounds du
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsv: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsv: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsv nPtr nrhsPtr dlPtr dPtr duPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgtsvx.f>
gtsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   IOCArray Int Double {- ^ dlf -} ->
   IOCArray Int Double {- ^ df -} ->
   IOCArray Int Double {- ^ duf -} ->
   IOCArray Int Double {- ^ du2 -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
gtsvx fact trans dl d du dlf df duf du2 ipiv b ldx = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   dlfDim0 <- Call.sizes1 <$> getBounds dlf
   dfDim0 <- Call.sizes1 <$> getBounds df
   dufDim0 <- Call.sizes1 <$> getBounds duf
   du2Dim0 <- Call.sizes1 <$> getBounds du2
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsvx: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsvx: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtsvx: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtsvx: n == dfDim0" (n == dfDim0)
   Call.assert "gtsvx: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtsvx: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtsvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.ioarray dlf
      dfPtr <- Call.ioarray df
      dufPtr <- Call.ioarray duf
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsvx factPtr transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgttrf.f>
gttrf ::
   IOCArray Int Double {- ^ dl -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ du -} ->
   IO (CArray Int Double, CArray Int CInt, Int)
gttrf dl d du = do
   dlDim0 <- Call.sizes1 <$> getBounds dl
   dDim0 <- Call.sizes1 <$> getBounds d
   duDim0 <- Call.sizes1 <$> getBounds du
   let n = dDim0
   Call.assert "gttrf: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrf: n-1 == duDim0" (n-1 == duDim0)
   du2 <- Call.newArray1 (n-2)
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrf nPtr dlPtr dPtr duPtr du2Ptr ipivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray du2
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgttrs.f>
gttrs ::
   Char {- ^ trans -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   CArray Int Double {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
gttrs trans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gttrs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gttrs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gttrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrs transPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dgtts2.f>
gtts2 ::
   Int {- ^ itrans -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   CArray Int Double {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO ()
gtts2 itrans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtts2: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtts2: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtts2: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtts2: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      itransPtr <- Call.cint itrans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.gtts2 itransPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbev.f>
sbev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
sbev jobz uplo kd ab ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbev jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbevd.f>
sbevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ ldz -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
sbevd jobz uplo kd ab ldz workSize lwork liwork = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sbevd jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbevx.f>
sbevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) Double, Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
sbevx jobz range uplo kd ab ldq vl vu il iu abstol m ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sbevx jobzPtr rangePtr uploPtr nPtr kdPtr abPtr ldabPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbgst.f>
sbgst ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   CArray (Int,Int) Double {- ^ bb -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Int)
sbgst vect uplo ka kb ab bb ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let (bbDim0,bbDim1) = Call.sizes2 $ bounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgst: n == bbDim0" (n == bbDim0)
   x <- Call.newArray2 n ldx
   work <- Call.newArray1 (2*n)
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.array bb
      ldbbPtr <- Call.cint ldbb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgst vectPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr xPtr ldxPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbgv.f>
sbgv ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ bb -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
sbgv jobz uplo ka kb ab bb ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgv: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgv jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbgvd.f>
sbgvd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ bb -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
sbgvd jobz uplo ka kb ab bb ldz lwork liwork = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgvd: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgvd jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbgvx.f>
sbgvx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ bb -} ->
   Int {- ^ ldq -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ ldz -} ->
   Int {- ^ m -} ->
   IO (CArray (Int,Int) Double, Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
sbgvx jobz range uplo ka kb ab bb ldq vl vu il iu abstol ldz m = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgvx: n == bbDim0" (n == bbDim0)
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 m
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgvx jobzPtr rangePtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsbtrd.f>
sbtrd ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IO (CArray Int Double, CArray Int Double, Int)
sbtrd vect uplo kd ab q = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = abDim0
   let ldab = abDim1
   let ldq = qDim1
   Call.assert "sbtrd: n == qDim0" (n == qDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbtrd vectPtr uploPtr nPtr kdPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyev.f>
syev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
syev jobz uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syev jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyevd.f>
syevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, Int)
syevd jobz uplo a workSize lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syevd jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyevr.f>
syevr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
syevr jobz range uplo a vl vu il iu abstol m ldz lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syevr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyevx.f>
syevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
syevx jobz range uplo a vl vu il iu abstol m ldz lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.syevx jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsygs2.f>
sygs2 ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
sygs2 itype uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygs2: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sygs2 itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsygst.f>
sygst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
sygst itype uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygst: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sygst itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsygv.f>
sygv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
sygv itype jobz uplo a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygv: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sygv itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsygvd.f>
sygvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, Int)
sygvd itype jobz uplo a b lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygvd: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sygvd itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsygvx.f>
sygvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
sygvx itype jobz range uplo a b vl vu il iu abstol m ldz lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygvx: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sygvx itypePtr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsfrk.f>
sfrk ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Double {- ^ alpha -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ beta -} ->
   IOCArray Int Double {- ^ c -} ->
   IO ()
sfrk transr uplo trans n k alpha a beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   cDim0 <- Call.sizes1 <$> getBounds c
   let _ka = aDim0
   let lda = aDim1
   let _nt = cDim0
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      betaPtr <- Call.double beta
      cPtr <- Call.ioarray c
      liftIO $ FFI.sfrk transrPtr uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr betaPtr cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dhgeqz.f>
hgeqz ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   IOCArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Int)
hgeqz job compq compz ilo ihi h t q z lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldt = tDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "hgeqz: n == tDim0" (n == tDim0)
   Call.assert "hgeqz: n == qDim0" (n == qDim0)
   Call.assert "hgeqz: n == zDim0" (n == zDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hgeqz jobPtr compqPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr tPtr ldtPtr alpharPtr alphaiPtr betaPtr qPtr ldqPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspev.f>
spev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
spev jobz uplo n ap ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "spev: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.spev jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspevd.f>
spevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
spevd jobz uplo n ap ldz lwork liwork = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "spevd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spevd jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspevx.f>
spevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
spevx jobz range uplo n ap vl vu il iu abstol m ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "spevx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (8*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.spevx jobzPtr rangePtr uploPtr nPtr apPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspgst.f>
spgst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ bp -} ->
   IO (Int)
spgst itype uplo n ap bp = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let bpDim0 = Call.sizes1 $ bounds bp
   Call.assert "spgst: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgst: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.array bp
      infoPtr <- Call.alloca
      liftIO $ FFI.spgst itypePtr uploPtr nPtr apPtr bpPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspgv.f>
spgv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ bp -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
spgv itype jobz uplo n ap bp ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "spgv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgv: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.spgv itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspgvd.f>
spgvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ bp -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, Int)
spgvd itype jobz uplo n ap bp ldz lwork liwork = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "spgvd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgvd: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spgvd itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspgvx.f>
spgvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ bp -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
spgvx itype jobz range uplo n ap bp vl vu il iu abstol m ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "spgvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgvx: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (8*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.spgvx itypePtr jobzPtr rangePtr uploPtr nPtr apPtr bpPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsptrd.f>
sptrd ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Int)
sptrd uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "sptrd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrd uploPtr nPtr apPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dhsein.f>
hsein ::
   Char {- ^ side -} ->
   Char {- ^ eigsrc -} ->
   Char {- ^ initv -} ->
   IOCArray Int Bool {- ^ select -} ->
   CArray (Int,Int) Double {- ^ h -} ->
   IOCArray Int Double {- ^ wr -} ->
   CArray Int Double {- ^ wi -} ->
   IOCArray (Int,Int) Double {- ^ vl -} ->
   IOCArray (Int,Int) Double {- ^ vr -} ->
   IO (Int, CArray Int CInt, CArray Int CInt, Int)
hsein side eigsrc initv select h wr wi vl vr = do
   selectDim0 <- Call.sizes1 <$> getBounds select
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   wrDim0 <- Call.sizes1 <$> getBounds wr
   let wiDim0 = Call.sizes1 $ bounds wi
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let ldh = hDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "hsein: n == hDim0" (n == hDim0)
   Call.assert "hsein: n == wrDim0" (n == wrDim0)
   Call.assert "hsein: n == wiDim0" (n == wiDim0)
   Call.assert "hsein: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 ((n+2)*n)
   ifaill <- Call.newArray1 mm
   ifailr <- Call.newArray1 mm
   evalContT $ do
      sidePtr <- Call.char side
      eigsrcPtr <- Call.char eigsrc
      initvPtr <- Call.char initv
      selectPtr <- Call.ioarray select
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.array wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      ifaillPtr <- Call.ioarray ifaill
      ifailrPtr <- Call.ioarray ifailr
      infoPtr <- Call.alloca
      liftIO $ FFI.hsein sidePtr eigsrcPtr initvPtr selectPtr nPtr hPtr ldhPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr ifaillPtr ifailrPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray ifaill
         <*> Call.freezeArray ifailr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dhseqr.f>
hseqr ::
   Char {- ^ job -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
hseqr job compz ilo ihi h z lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "hseqr: n == zDim0" (n == zDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hseqr jobPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/iladlc.f>
ilalc ::
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO CInt
ilalc m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalc mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/iladlr.f>
ilalr ::
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO CInt
ilalr m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalr mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/disnan.f>
isnan ::
   Double {- ^ din -} ->
   IO Bool
isnan din = do
   evalContT $ do
      dinPtr <- Call.double din
      liftIO $ FFI.isnan dinPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlabad.f>
labad ::
   Double {- ^ small -} ->
   Double {- ^ large -} ->
   IO (Double, Double)
labad small large = do
   evalContT $ do
      smallPtr <- Call.double small
      largePtr <- Call.double large
      liftIO $ FFI.labad smallPtr largePtr
      liftIO $ pure (,)
         <*> peek smallPtr
         <*> peek largePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlabrd.f>
labrd ::
   Int {- ^ m -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldx -} ->
   Int {- ^ ldy -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double)
labrd m nb a ldx ldy = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 nb
   e <- Call.newArray1 nb
   tauq <- Call.newArray1 nb
   taup <- Call.newArray1 nb
   x <- Call.newArray2 nb ldx
   y <- Call.newArray2 nb ldy
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.labrd mPtr nPtr nbPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr xPtr ldxPtr yPtr ldyPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> Call.freezeArray x
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlacn2.f>
lacn2 ::
   IOCArray Int Double {- ^ x -} ->
   Double {- ^ est -} ->
   Int {- ^ kase -} ->
   IOCArray Int CInt {- ^ isave -} ->
   IO (CArray Int Double, CArray Int CInt, Double, Int)
lacn2 x est kase isave = do
   xDim0 <- Call.sizes1 <$> getBounds x
   isaveDim0 <- Call.sizes1 <$> getBounds isave
   let n = xDim0
   Call.assert "lacn2: 3 == isaveDim0" (3 == isaveDim0)
   v <- Call.newArray1 n
   isgn <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      isgnPtr <- Call.ioarray isgn
      estPtr <- Call.double est
      kasePtr <- Call.cint kase
      isavePtr <- Call.ioarray isave
      liftIO $ FFI.lacn2 nPtr vPtr xPtr isgnPtr estPtr kasePtr isavePtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray isgn
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlacon.f>
lacon ::
   IOCArray Int Double {- ^ x -} ->
   Double {- ^ est -} ->
   Int {- ^ kase -} ->
   IO (CArray Int Double, CArray Int CInt, Double, Int)
lacon x est kase = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let n = xDim0
   v <- Call.newArray1 n
   isgn <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      isgnPtr <- Call.ioarray isgn
      estPtr <- Call.double est
      kasePtr <- Call.cint kase
      liftIO $ FFI.lacon nPtr vPtr xPtr isgnPtr estPtr kasePtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray isgn
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlacpy.f>
lacpy ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldb -} ->
   IO (CArray (Int,Int) Double)
lacpy uplo m a ldb = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   b <- Call.newArray2 n ldb
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lacpy uploPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr
      liftIO $ Call.freezeArray b

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dladiv.f>
ladiv ::
   Double {- ^ a -} ->
   Double {- ^ b -} ->
   Double {- ^ c -} ->
   Double {- ^ d -} ->
   IO (Double, Double)
ladiv a b c d = do
   evalContT $ do
      aPtr <- Call.double a
      bPtr <- Call.double b
      cPtr <- Call.double c
      dPtr <- Call.double d
      pPtr <- Call.alloca
      qPtr <- Call.alloca
      liftIO $ FFI.ladiv aPtr bPtr cPtr dPtr pPtr qPtr
      liftIO $ pure (,)
         <*> peek pPtr
         <*> peek qPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlae2.f>
lae2 ::
   Double {- ^ a -} ->
   Double {- ^ b -} ->
   Double {- ^ c -} ->
   IO (Double, Double)
lae2 a b c = do
   evalContT $ do
      aPtr <- Call.double a
      bPtr <- Call.double b
      cPtr <- Call.double c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      liftIO $ FFI.lae2 aPtr bPtr cPtr rt1Ptr rt2Ptr
      liftIO $ pure (,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaebz.f>
laebz ::
   Int {- ^ ijob -} ->
   Int {- ^ nitmax -} ->
   Int {- ^ nbmin -} ->
   Double {- ^ abstol -} ->
   Double {- ^ reltol -} ->
   Double {- ^ pivmin -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   CArray Int Double {- ^ e2 -} ->
   IOCArray Int CInt {- ^ nval -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray Int Double {- ^ c -} ->
   IOCArray (Int,Int) CInt {- ^ nab -} ->
   IO (Int, Int)
laebz ijob nitmax nbmin abstol reltol pivmin d e e2 nval ab c nab = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let e2Dim0 = Call.sizes1 $ bounds e2
   nvalDim0 <- Call.sizes1 <$> getBounds nval
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   cDim0 <- Call.sizes1 <$> getBounds c
   (nabDim0,nabDim1) <- Call.sizes2 <$> getBounds nab
   let n = dDim0
   let minp = nvalDim0
   let mmax = abDim1
   Call.assert "laebz: n == eDim0" (n == eDim0)
   Call.assert "laebz: n == e2Dim0" (n == e2Dim0)
   Call.assert "laebz: 2 == abDim0" (2 == abDim0)
   Call.assert "laebz: mmax == cDim0" (mmax == cDim0)
   Call.assert "laebz: 2 == nabDim0" (2 == nabDim0)
   Call.assert "laebz: mmax == nabDim1" (mmax == nabDim1)
   work <- Call.newArray1 mmax
   iwork <- Call.newArray1 mmax
   evalContT $ do
      ijobPtr <- Call.cint ijob
      nitmaxPtr <- Call.cint nitmax
      nPtr <- Call.cint n
      mmaxPtr <- Call.cint mmax
      minpPtr <- Call.cint minp
      nbminPtr <- Call.cint nbmin
      abstolPtr <- Call.double abstol
      reltolPtr <- Call.double reltol
      pivminPtr <- Call.double pivmin
      dPtr <- Call.array d
      ePtr <- Call.array e
      e2Ptr <- Call.array e2
      nvalPtr <- Call.ioarray nval
      abPtr <- Call.ioarray ab
      cPtr <- Call.ioarray c
      moutPtr <- Call.alloca
      nabPtr <- Call.ioarray nab
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laebz ijobPtr nitmaxPtr nPtr mmaxPtr minpPtr nbminPtr abstolPtr reltolPtr pivminPtr dPtr ePtr e2Ptr nvalPtr abPtr cPtr moutPtr nabPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek moutPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed0.f>
laed0 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   IOCArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   Int {- ^ ldqs -} ->
   Int {- ^ workSize -} ->
   Int {- ^ iworkSize -} ->
   IO (CArray (Int,Int) Double, Int)
laed0 icompq qsiz d e q ldqs workSize iworkSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   let eDim0 = Call.sizes1 $ bounds e
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed0: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "laed0: n == qDim0" (n == qDim0)
   qstore <- Call.newArray2 n ldqs
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 iworkSize
   evalContT $ do
      icompqPtr <- Call.cint icompq
      qsizPtr <- Call.cint qsiz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.array e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      qstorePtr <- Call.ioarray qstore
      ldqsPtr <- Call.cint ldqs
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed0 icompqPtr qsizPtr nPtr dPtr ePtr qPtr ldqPtr qstorePtr ldqsPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray qstore
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed1.f>
laed1 ::
   IOCArray Int Double {- ^ d -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray Int CInt {- ^ indxq -} ->
   Double {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   IO (Int)
laed1 d q indxq rho cutpnt = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   indxqDim0 <- Call.sizes1 <$> getBounds indxq
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed1: n == qDim0" (n == qDim0)
   Call.assert "laed1: n == indxqDim0" (n == indxqDim0)
   work <- Call.newArray1 (4*n+n^!2)
   iwork <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.double rho
      cutpntPtr <- Call.cint cutpnt
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed1 nPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr workPtr iworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed2.f>
laed2 ::
   Int {- ^ n1 -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray Int CInt {- ^ indxq -} ->
   Double {- ^ rho -} ->
   CArray Int Double {- ^ z -} ->
   IO (Int, Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)
laed2 n1 d q indxq rho z = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   indxqDim0 <- Call.sizes1 <$> getBounds indxq
   let zDim0 = Call.sizes1 $ bounds z
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed2: n == qDim0" (n == qDim0)
   Call.assert "laed2: n == indxqDim0" (n == indxqDim0)
   Call.assert "laed2: n == zDim0" (n == zDim0)
   dlamda <- Call.newArray1 n
   w <- Call.newArray1 n
   q2 <- Call.newArray1 (n1^!2+(n-n1)^!2)
   indx <- Call.newArray1 n
   indxc <- Call.newArray1 n
   indxp <- Call.newArray1 n
   coltyp <- Call.newArray1 n
   evalContT $ do
      kPtr <- Call.alloca
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.double rho
      zPtr <- Call.array z
      dlamdaPtr <- Call.ioarray dlamda
      wPtr <- Call.ioarray w
      q2Ptr <- Call.ioarray q2
      indxPtr <- Call.ioarray indx
      indxcPtr <- Call.ioarray indxc
      indxpPtr <- Call.ioarray indxp
      coltypPtr <- Call.ioarray coltyp
      infoPtr <- Call.alloca
      liftIO $ FFI.laed2 kPtr nPtr n1Ptr dPtr qPtr ldqPtr indxqPtr rhoPtr zPtr dlamdaPtr wPtr q2Ptr indxPtr indxcPtr indxpPtr coltypPtr infoPtr
      liftIO $ pure (,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> peek rhoPtr
         <*> Call.freezeArray dlamda
         <*> Call.freezeArray w
         <*> Call.freezeArray q2
         <*> Call.freezeArray indx
         <*> Call.freezeArray indxc
         <*> Call.freezeArray indxp
         <*> Call.freezeArray coltyp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed3.f>
laed3 ::
   Int {- ^ n1 -} ->
   Int {- ^ ldq -} ->
   Double {- ^ rho -} ->
   IOCArray Int Double {- ^ dlamda -} ->
   CArray Int Double {- ^ q2 -} ->
   CArray Int CInt {- ^ indx -} ->
   CArray Int CInt {- ^ ctot -} ->
   IOCArray Int Double {- ^ w -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray Int Double, Int)
laed3 n1 ldq rho dlamda q2 indx ctot w = do
   dlamdaDim0 <- Call.sizes1 <$> getBounds dlamda
   let q2Dim0 = Call.sizes1 $ bounds q2
   let indxDim0 = Call.sizes1 $ bounds indx
   let ctotDim0 = Call.sizes1 $ bounds ctot
   wDim0 <- Call.sizes1 <$> getBounds w
   let k = dlamdaDim0
   let n = indxDim0
   Call.ignore "laed3: ldq2*n == q2Dim0" q2Dim0
   Call.assert "laed3: 4 == ctotDim0" (4 == ctotDim0)
   Call.assert "laed3: k == wDim0" (k == wDim0)
   d <- Call.newArray1 n
   q <- Call.newArray2 n ldq
   s <- Call.newArray1 (n1+1)
   evalContT $ do
      kPtr <- Call.cint k
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      rhoPtr <- Call.double rho
      dlamdaPtr <- Call.ioarray dlamda
      q2Ptr <- Call.array q2
      indxPtr <- Call.array indx
      ctotPtr <- Call.array ctot
      wPtr <- Call.ioarray w
      sPtr <- Call.ioarray s
      infoPtr <- Call.alloca
      liftIO $ FFI.laed3 kPtr nPtr n1Ptr dPtr qPtr ldqPtr rhoPtr dlamdaPtr q2Ptr indxPtr ctotPtr wPtr sPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed4.f>
laed4 ::
   Int {- ^ i -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ rho -} ->
   IO (CArray Int Double, Double, Int)
laed4 i d z rho = do
   let dDim0 = Call.sizes1 $ bounds d
   let zDim0 = Call.sizes1 $ bounds z
   let n = dDim0
   Call.assert "laed4: n == zDim0" (n == zDim0)
   delta <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.double rho
      dlamPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laed4 nPtr iPtr dPtr zPtr deltaPtr rhoPtr dlamPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray delta
         <*> peek dlamPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed5.f>
laed5 ::
   Int {- ^ i -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ rho -} ->
   IO (CArray Int Double, Double)
laed5 i d z rho = do
   let dDim0 = Call.sizes1 $ bounds d
   let zDim0 = Call.sizes1 $ bounds z
   Call.assert "laed5: 2 == dDim0" (2 == dDim0)
   Call.assert "laed5: 2 == zDim0" (2 == zDim0)
   delta <- Call.newArray1 2
   evalContT $ do
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.double rho
      dlamPtr <- Call.alloca
      liftIO $ FFI.laed5 iPtr dPtr zPtr deltaPtr rhoPtr dlamPtr
      liftIO $ pure (,)
         <*> Call.freezeArray delta
         <*> peek dlamPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed6.f>
laed6 ::
   Int {- ^ kniter -} ->
   Bool {- ^ orgati -} ->
   Double {- ^ rho -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ finit -} ->
   IO (Double, Int)
laed6 kniter orgati rho d z finit = do
   let dDim0 = Call.sizes1 $ bounds d
   let zDim0 = Call.sizes1 $ bounds z
   Call.assert "laed6: 3 == dDim0" (3 == dDim0)
   Call.assert "laed6: 3 == zDim0" (3 == zDim0)
   evalContT $ do
      kniterPtr <- Call.cint kniter
      orgatiPtr <- Call.bool orgati
      rhoPtr <- Call.double rho
      dPtr <- Call.array d
      zPtr <- Call.array z
      finitPtr <- Call.double finit
      tauPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laed6 kniterPtr orgatiPtr rhoPtr dPtr zPtr finitPtr tauPtr infoPtr
      liftIO $ pure (,)
         <*> peek tauPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed7.f>
laed7 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   Int {- ^ tlvls -} ->
   Int {- ^ curlvl -} ->
   Int {- ^ curpbm -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   Double {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   IOCArray Int Double {- ^ qstore -} ->
   IOCArray Int CInt {- ^ qptr -} ->
   CArray Int CInt {- ^ prmptr -} ->
   CArray Int CInt {- ^ perm -} ->
   CArray Int CInt {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) Double {- ^ givnum -} ->
   IO (CArray Int CInt, Int)
laed7 icompq qsiz tlvls curlvl curpbm d q rho cutpnt qstore qptr prmptr perm givptr givcol givnum = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   qstoreDim0 <- Call.sizes1 <$> getBounds qstore
   qptrDim0 <- Call.sizes1 <$> getBounds qptr
   let prmptrDim0 = Call.sizes1 $ bounds prmptr
   let permDim0 = Call.sizes1 $ bounds perm
   let givptrDim0 = Call.sizes1 $ bounds givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let n = dDim0
   let ldq = qDim1
   let nlgn = prmptrDim0
   Call.assert "laed7: n == qDim0" (n == qDim0)
   Call.assert "laed7: n^!2+1 == qstoreDim0" (n^!2+1 == qstoreDim0)
   Call.assert "laed7: n+2 == qptrDim0" (n+2 == qptrDim0)
   Call.assert "laed7: nlgn == permDim0" (nlgn == permDim0)
   Call.assert "laed7: nlgn == givptrDim0" (nlgn == givptrDim0)
   Call.assert "laed7: nlgn == givcolDim0" (nlgn == givcolDim0)
   Call.assert "laed7: 2 == givcolDim1" (2 == givcolDim1)
   Call.assert "laed7: nlgn == givnumDim0" (nlgn == givnumDim0)
   Call.assert "laed7: 2 == givnumDim1" (2 == givnumDim1)
   indxq <- Call.newArray1 n
   work <- Call.newArray1 (3*n+2*qsiz*n)
   iwork <- Call.newArray1 (4*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nPtr <- Call.cint n
      qsizPtr <- Call.cint qsiz
      tlvlsPtr <- Call.cint tlvls
      curlvlPtr <- Call.cint curlvl
      curpbmPtr <- Call.cint curpbm
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.double rho
      cutpntPtr <- Call.cint cutpnt
      qstorePtr <- Call.ioarray qstore
      qptrPtr <- Call.ioarray qptr
      prmptrPtr <- Call.array prmptr
      permPtr <- Call.array perm
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      givnumPtr <- Call.array givnum
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed7 icompqPtr nPtr qsizPtr tlvlsPtr curlvlPtr curpbmPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr qstorePtr qptrPtr prmptrPtr permPtr givptrPtr givcolPtr givnumPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray indxq
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed8.f>
laed8 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   CArray Int CInt {- ^ indxq -} ->
   Double {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   CArray Int Double {- ^ z -} ->
   Int {- ^ ldq2 -} ->
   IO (Int, Double, CArray Int Double, CArray (Int,Int) Double, CArray Int Double, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) Double, CArray Int CInt, CArray Int CInt, Int)
laed8 icompq qsiz d q indxq rho cutpnt z ldq2 = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let indxqDim0 = Call.sizes1 $ bounds indxq
   let zDim0 = Call.sizes1 $ bounds z
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed8: n == qDim0" (n == qDim0)
   Call.assert "laed8: n == indxqDim0" (n == indxqDim0)
   Call.assert "laed8: n == zDim0" (n == zDim0)
   dlamda <- Call.newArray1 n
   q2 <- Call.newArray2 n ldq2
   w <- Call.newArray1 n
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 n 2
   givnum <- Call.newArray2 n 2
   indxp <- Call.newArray1 n
   indx <- Call.newArray1 n
   evalContT $ do
      icompqPtr <- Call.cint icompq
      kPtr <- Call.alloca
      nPtr <- Call.cint n
      qsizPtr <- Call.cint qsiz
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.array indxq
      rhoPtr <- Call.double rho
      cutpntPtr <- Call.cint cutpnt
      zPtr <- Call.array z
      dlamdaPtr <- Call.ioarray dlamda
      q2Ptr <- Call.ioarray q2
      ldq2Ptr <- Call.cint ldq2
      wPtr <- Call.ioarray w
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      givnumPtr <- Call.ioarray givnum
      indxpPtr <- Call.ioarray indxp
      indxPtr <- Call.ioarray indx
      infoPtr <- Call.alloca
      liftIO $ FFI.laed8 icompqPtr kPtr nPtr qsizPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr zPtr dlamdaPtr q2Ptr ldq2Ptr wPtr permPtr givptrPtr givcolPtr givnumPtr indxpPtr indxPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> peek rhoPtr
         <*> Call.freezeArray dlamda
         <*> Call.freezeArray q2
         <*> Call.freezeArray w
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> Call.freezeArray indxp
         <*> Call.freezeArray indx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaed9.f>
laed9 ::
   Int {- ^ kstart -} ->
   Int {- ^ kstop -} ->
   Int {- ^ n -} ->
   Int {- ^ ldq -} ->
   Double {- ^ rho -} ->
   CArray Int Double {- ^ dlamda -} ->
   CArray Int Double {- ^ w -} ->
   Int {- ^ lds -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
laed9 kstart kstop n ldq rho dlamda w lds = do
   let dlamdaDim0 = Call.sizes1 $ bounds dlamda
   let wDim0 = Call.sizes1 $ bounds w
   let k = dlamdaDim0
   Call.assert "laed9: k == wDim0" (k == wDim0)
   d <- Call.newArray1 n
   q <- Call.newArray2 n ldq
   s <- Call.newArray2 k lds
   evalContT $ do
      kPtr <- Call.cint k
      kstartPtr <- Call.cint kstart
      kstopPtr <- Call.cint kstop
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      rhoPtr <- Call.double rho
      dlamdaPtr <- Call.array dlamda
      wPtr <- Call.array w
      sPtr <- Call.ioarray s
      ldsPtr <- Call.cint lds
      infoPtr <- Call.alloca
      liftIO $ FFI.laed9 kPtr kstartPtr kstopPtr nPtr dPtr qPtr ldqPtr rhoPtr dlamdaPtr wPtr sPtr ldsPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaeda.f>
laeda ::
   Int {- ^ n -} ->
   Int {- ^ tlvls -} ->
   Int {- ^ curlvl -} ->
   Int {- ^ curpbm -} ->
   CArray Int CInt {- ^ prmptr -} ->
   CArray Int CInt {- ^ perm -} ->
   CArray Int CInt {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) Double {- ^ givnum -} ->
   CArray Int Double {- ^ q -} ->
   CArray Int CInt {- ^ qptr -} ->
   IO (CArray Int Double, CArray Int Double, Int)
laeda n tlvls curlvl curpbm prmptr perm givptr givcol givnum q qptr = do
   let prmptrDim0 = Call.sizes1 $ bounds prmptr
   let permDim0 = Call.sizes1 $ bounds perm
   let givptrDim0 = Call.sizes1 $ bounds givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let qDim0 = Call.sizes1 $ bounds q
   let qptrDim0 = Call.sizes1 $ bounds qptr
   let nlgn = prmptrDim0
   Call.assert "laeda: nlgn == permDim0" (nlgn == permDim0)
   Call.assert "laeda: nlgn == givptrDim0" (nlgn == givptrDim0)
   Call.assert "laeda: nlgn == givcolDim0" (nlgn == givcolDim0)
   Call.assert "laeda: 2 == givcolDim1" (2 == givcolDim1)
   Call.assert "laeda: nlgn == givnumDim0" (nlgn == givnumDim0)
   Call.assert "laeda: 2 == givnumDim1" (2 == givnumDim1)
   Call.assert "laeda: n^!2 == qDim0" (n^!2 == qDim0)
   Call.assert "laeda: n+2 == qptrDim0" (n+2 == qptrDim0)
   z <- Call.newArray1 n
   ztemp <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      tlvlsPtr <- Call.cint tlvls
      curlvlPtr <- Call.cint curlvl
      curpbmPtr <- Call.cint curpbm
      prmptrPtr <- Call.array prmptr
      permPtr <- Call.array perm
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      givnumPtr <- Call.array givnum
      qPtr <- Call.array q
      qptrPtr <- Call.array qptr
      zPtr <- Call.ioarray z
      ztempPtr <- Call.ioarray ztemp
      infoPtr <- Call.alloca
      liftIO $ FFI.laeda nPtr tlvlsPtr curlvlPtr curpbmPtr prmptrPtr permPtr givptrPtr givcolPtr givnumPtr qPtr qptrPtr zPtr ztempPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray ztemp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaein.f>
laein ::
   Bool {- ^ rightv -} ->
   Bool {- ^ noinit -} ->
   CArray (Int,Int) Double {- ^ h -} ->
   Double {- ^ wr -} ->
   Double {- ^ wi -} ->
   IOCArray Int Double {- ^ vr -} ->
   IOCArray Int Double {- ^ vi -} ->
   Int {- ^ ldb -} ->
   Double {- ^ eps3 -} ->
   Double {- ^ smlnum -} ->
   Double {- ^ bignum -} ->
   IO (CArray (Int,Int) Double, Int)
laein rightv noinit h wr wi vr vi ldb eps3 smlnum bignum = do
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   vrDim0 <- Call.sizes1 <$> getBounds vr
   viDim0 <- Call.sizes1 <$> getBounds vi
   let n = hDim0
   let ldh = hDim1
   Call.assert "laein: n == vrDim0" (n == vrDim0)
   Call.assert "laein: n == viDim0" (n == viDim0)
   b <- Call.newArray2 n ldb
   work <- Call.newArray1 n
   evalContT $ do
      rightvPtr <- Call.bool rightv
      noinitPtr <- Call.bool noinit
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.double wr
      wiPtr <- Call.double wi
      vrPtr <- Call.ioarray vr
      viPtr <- Call.ioarray vi
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      eps3Ptr <- Call.double eps3
      smlnumPtr <- Call.double smlnum
      bignumPtr <- Call.double bignum
      infoPtr <- Call.alloca
      liftIO $ FFI.laein rightvPtr noinitPtr nPtr hPtr ldhPtr wrPtr wiPtr vrPtr viPtr bPtr ldbPtr workPtr eps3Ptr smlnumPtr bignumPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray b
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaev2.f>
laev2 ::
   Double {- ^ a -} ->
   Double {- ^ b -} ->
   Double {- ^ c -} ->
   IO (Double, Double, Double, Double)
laev2 a b c = do
   evalContT $ do
      aPtr <- Call.double a
      bPtr <- Call.double b
      cPtr <- Call.double c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      cs1Ptr <- Call.alloca
      sn1Ptr <- Call.alloca
      liftIO $ FFI.laev2 aPtr bPtr cPtr rt1Ptr rt2Ptr cs1Ptr sn1Ptr
      liftIO $ pure (,,,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr
         <*> peek cs1Ptr
         <*> peek sn1Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaexc.f>
laexc ::
   Bool {- ^ wantq -} ->
   IOCArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   Int {- ^ j1 -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   IO (Int)
laexc wantq t q j1 n1 n2 = do
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = tDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "laexc: n == qDim0" (n == qDim0)
   work <- Call.newArray1 n
   evalContT $ do
      wantqPtr <- Call.bool wantq
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      j1Ptr <- Call.cint j1
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.laexc wantqPtr nPtr tPtr ldtPtr qPtr ldqPtr j1Ptr n1Ptr n2Ptr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlag2.f>
lag2 ::
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ safmin -} ->
   IO (Double, Double, Double, Double, Double)
lag2 a b safmin = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let lda = aDim1
   let ldb = bDim1
   Call.assert "lag2: 2 == aDim0" (2 == aDim0)
   Call.assert "lag2: 2 == bDim0" (2 == bDim0)
   evalContT $ do
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      safminPtr <- Call.double safmin
      scale1Ptr <- Call.alloca
      scale2Ptr <- Call.alloca
      wr1Ptr <- Call.alloca
      wr2Ptr <- Call.alloca
      wiPtr <- Call.alloca
      liftIO $ FFI.lag2 aPtr ldaPtr bPtr ldbPtr safminPtr scale1Ptr scale2Ptr wr1Ptr wr2Ptr wiPtr
      liftIO $ pure (,,,,)
         <*> peek scale1Ptr
         <*> peek scale2Ptr
         <*> peek wr1Ptr
         <*> peek wr2Ptr
         <*> peek wiPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlag2s.f>
lag2s ::
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldsa -} ->
   IO (CArray (Int,Int) Float, Int)
lag2s m a ldsa = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   sa <- Call.newArray2 n ldsa
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      saPtr <- Call.ioarray sa
      ldsaPtr <- Call.cint ldsa
      infoPtr <- Call.alloca
      liftIO $ FFI.lag2s mPtr nPtr aPtr ldaPtr saPtr ldsaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sa
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlags2.f>
lags2 ::
   Bool {- ^ upper -} ->
   Double {- ^ a1 -} ->
   Double {- ^ a2 -} ->
   Double {- ^ a3 -} ->
   Double {- ^ b1 -} ->
   Double {- ^ b2 -} ->
   Double {- ^ b3 -} ->
   IO (Double, Double, Double, Double, Double, Double)
lags2 upper a1 a2 a3 b1 b2 b3 = do
   evalContT $ do
      upperPtr <- Call.bool upper
      a1Ptr <- Call.double a1
      a2Ptr <- Call.double a2
      a3Ptr <- Call.double a3
      b1Ptr <- Call.double b1
      b2Ptr <- Call.double b2
      b3Ptr <- Call.double b3
      csuPtr <- Call.alloca
      snuPtr <- Call.alloca
      csvPtr <- Call.alloca
      snvPtr <- Call.alloca
      csqPtr <- Call.alloca
      snqPtr <- Call.alloca
      liftIO $ FFI.lags2 upperPtr a1Ptr a2Ptr a3Ptr b1Ptr b2Ptr b3Ptr csuPtr snuPtr csvPtr snvPtr csqPtr snqPtr
      liftIO $ pure (,,,,,)
         <*> peek csuPtr
         <*> peek snuPtr
         <*> peek csvPtr
         <*> peek snvPtr
         <*> peek csqPtr
         <*> peek snqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlagtf.f>
lagtf ::
   IOCArray Int Double {- ^ a -} ->
   Double {- ^ lambda -} ->
   IOCArray Int Double {- ^ b -} ->
   IOCArray Int Double {- ^ c -} ->
   Double {- ^ tol -} ->
   IO (CArray Int Double, CArray Int CInt, Int)
lagtf a lambda b c tol = do
   aDim0 <- Call.sizes1 <$> getBounds a
   bDim0 <- Call.sizes1 <$> getBounds b
   cDim0 <- Call.sizes1 <$> getBounds c
   let n = aDim0
   Call.assert "lagtf: n-1 == bDim0" (n-1 == bDim0)
   Call.assert "lagtf: n-1 == cDim0" (n-1 == cDim0)
   d <- Call.newArray1 (n-2)
   in_ <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      lambdaPtr <- Call.double lambda
      bPtr <- Call.ioarray b
      cPtr <- Call.ioarray c
      tolPtr <- Call.double tol
      dPtr <- Call.ioarray d
      in_Ptr <- Call.ioarray in_
      infoPtr <- Call.alloca
      liftIO $ FFI.lagtf nPtr aPtr lambdaPtr bPtr cPtr tolPtr dPtr in_Ptr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray in_
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlagtm.f>
lagtm ::
   Char {- ^ trans -} ->
   Double {- ^ alpha -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   CArray (Int,Int) Double {- ^ x -} ->
   Double {- ^ beta -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO ()
lagtm trans alpha dl d du x beta b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = xDim0
   let ldx = xDim1
   let ldb = bDim1
   Call.assert "lagtm: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "lagtm: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "lagtm: nrhs == bDim0" (nrhs == bDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      alphaPtr <- Call.double alpha
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      betaPtr <- Call.double beta
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lagtm transPtr nPtr nrhsPtr alphaPtr dlPtr dPtr duPtr xPtr ldxPtr betaPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlagts.f>
lagts ::
   Int {- ^ job -} ->
   CArray Int Double {- ^ a -} ->
   CArray Int Double {- ^ b -} ->
   CArray Int Double {- ^ c -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int CInt {- ^ in_ -} ->
   IOCArray Int Double {- ^ y -} ->
   Double {- ^ tol -} ->
   IO (Double, Int)
lagts job a b c d in_ y tol = do
   let aDim0 = Call.sizes1 $ bounds a
   let bDim0 = Call.sizes1 $ bounds b
   let cDim0 = Call.sizes1 $ bounds c
   let dDim0 = Call.sizes1 $ bounds d
   let in_Dim0 = Call.sizes1 $ bounds in_
   yDim0 <- Call.sizes1 <$> getBounds y
   let n = aDim0
   Call.assert "lagts: n-1 == bDim0" (n-1 == bDim0)
   Call.assert "lagts: n-1 == cDim0" (n-1 == cDim0)
   Call.assert "lagts: n-2 == dDim0" (n-2 == dDim0)
   Call.assert "lagts: n == in_Dim0" (n == in_Dim0)
   Call.assert "lagts: n == yDim0" (n == yDim0)
   evalContT $ do
      jobPtr <- Call.cint job
      nPtr <- Call.cint n
      aPtr <- Call.array a
      bPtr <- Call.array b
      cPtr <- Call.array c
      dPtr <- Call.array d
      in_Ptr <- Call.array in_
      yPtr <- Call.ioarray y
      tolPtr <- Call.double tol
      infoPtr <- Call.alloca
      liftIO $ FFI.lagts jobPtr nPtr aPtr bPtr cPtr dPtr in_Ptr yPtr tolPtr infoPtr
      liftIO $ pure (,)
         <*> peek tolPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlagv2.f>
lagv2 ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Double, Double, Double, Double)
lagv2 a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let lda = aDim1
   let ldb = bDim1
   Call.assert "lagv2: 2 == aDim0" (2 == aDim0)
   Call.assert "lagv2: 2 == bDim0" (2 == bDim0)
   alphar <- Call.newArray1 2
   alphai <- Call.newArray1 2
   beta <- Call.newArray1 2
   evalContT $ do
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      cslPtr <- Call.alloca
      snlPtr <- Call.alloca
      csrPtr <- Call.alloca
      snrPtr <- Call.alloca
      liftIO $ FFI.lagv2 aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr cslPtr snlPtr csrPtr snrPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> peek cslPtr
         <*> peek snlPtr
         <*> peek csrPtr
         <*> peek snrPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlahqr.f>
lahqr ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   IO (CArray Int Double, CArray Int Double, Int)
lahqr wantt wantz ilo ihi h iloz ihiz z = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "lahqr: n == zDim0" (n == zDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.lahqr wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlahr2.f>
lahr2 ::
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldt -} ->
   Int {- ^ ldy -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double)
lahr2 n k nb a ldt ldy = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let lda = aDim1
   Call.assert "lahr2: n-k+1 == aDim0" (n-k+1 == aDim0)
   tau <- Call.newArray1 nb
   t <- Call.newArray2 nb ldt
   y <- Call.newArray2 nb ldy
   evalContT $ do
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.lahr2 nPtr kPtr nbPtr aPtr ldaPtr tauPtr tPtr ldtPtr yPtr ldyPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray tau
         <*> Call.freezeArray t
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaic1.f>
laic1 ::
   Int {- ^ job -} ->
   CArray Int Double {- ^ x -} ->
   Double {- ^ sest -} ->
   CArray Int Double {- ^ w -} ->
   Double {- ^ gamma -} ->
   IO (Double, Double, Double)
laic1 job x sest w gamma = do
   let xDim0 = Call.sizes1 $ bounds x
   let wDim0 = Call.sizes1 $ bounds w
   let j = xDim0
   Call.assert "laic1: j == wDim0" (j == wDim0)
   evalContT $ do
      jobPtr <- Call.cint job
      jPtr <- Call.cint j
      xPtr <- Call.array x
      sestPtr <- Call.double sest
      wPtr <- Call.array w
      gammaPtr <- Call.double gamma
      sestprPtr <- Call.alloca
      sPtr <- Call.alloca
      cPtr <- Call.alloca
      liftIO $ FFI.laic1 jobPtr jPtr xPtr sestPtr wPtr gammaPtr sestprPtr sPtr cPtr
      liftIO $ pure (,,)
         <*> peek sestprPtr
         <*> peek sPtr
         <*> peek cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaisnan.f>
laisnan ::
   Double {- ^ din1 -} ->
   Double {- ^ din2 -} ->
   IO Bool
laisnan din1 din2 = do
   evalContT $ do
      din1Ptr <- Call.double din1
      din2Ptr <- Call.double din2
      liftIO $ FFI.laisnan din1Ptr din2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaln2.f>
laln2 ::
   Bool {- ^ ltrans -} ->
   Double {- ^ smin -} ->
   Double {- ^ ca -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ d1 -} ->
   Double {- ^ d2 -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ wr -} ->
   Double {- ^ wi -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Double, Double, Int)
laln2 ltrans smin ca a d1 d2 b wr wi ldx = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let na = aDim0
   let lda = aDim1
   let nw = bDim0
   let ldb = bDim1
   x <- Call.newArray2 nw ldx
   evalContT $ do
      ltransPtr <- Call.bool ltrans
      naPtr <- Call.cint na
      nwPtr <- Call.cint nw
      sminPtr <- Call.double smin
      caPtr <- Call.double ca
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      d1Ptr <- Call.double d1
      d2Ptr <- Call.double d2
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      wrPtr <- Call.double wr
      wiPtr <- Call.double wi
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      scalePtr <- Call.alloca
      xnormPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laln2 ltransPtr naPtr nwPtr sminPtr caPtr aPtr ldaPtr d1Ptr d2Ptr bPtr ldbPtr wrPtr wiPtr xPtr ldxPtr scalePtr xnormPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray x
         <*> peek scalePtr
         <*> peek xnormPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlals0.f>
lals0 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldbx -} ->
   CArray Int CInt {- ^ perm -} ->
   Int {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) Double {- ^ givnum -} ->
   CArray (Int,Int) Double {- ^ poles -} ->
   CArray Int Double {- ^ difl -} ->
   CArray (Int,Int) Double {- ^ difr -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ c -} ->
   Double {- ^ s -} ->
   IO (CArray (Int,Int) Double, Int)
lals0 icompq nl nr sqre b ldbx perm givptr givcol givnum poles difl difr z c s = do
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let permDim0 = Call.sizes1 $ bounds perm
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let (polesDim0,polesDim1) = Call.sizes2 $ bounds poles
   let diflDim0 = Call.sizes1 $ bounds difl
   let (difrDim0,difrDim1) = Call.sizes2 $ bounds difr
   let zDim0 = Call.sizes1 $ bounds z
   let nrhs = bDim0
   let ldb = bDim1
   let _n = permDim0
   let ldgcol = givcolDim1
   let ldgnum = givnumDim1
   let k = diflDim0
   Call.assert "lals0: 2 == givcolDim0" (2 == givcolDim0)
   Call.assert "lals0: 2 == givnumDim0" (2 == givnumDim0)
   Call.assert "lals0: 2 == polesDim0" (2 == polesDim0)
   Call.assert "lals0: ldgnum == polesDim1" (ldgnum == polesDim1)
   Call.assert "lals0: 2 == difrDim0" (2 == difrDim0)
   Call.assert "lals0: ldgnum == difrDim1" (ldgnum == difrDim1)
   Call.assert "lals0: k == zDim0" (k == zDim0)
   bx <- Call.newArray2 nrhs ldbx
   work <- Call.newArray1 k
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      permPtr <- Call.array perm
      givptrPtr <- Call.cint givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.array givnum
      ldgnumPtr <- Call.cint ldgnum
      polesPtr <- Call.array poles
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      kPtr <- Call.cint k
      cPtr <- Call.double c
      sPtr <- Call.double s
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lals0 icompqPtr nlPtr nrPtr sqrePtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr polesPtr diflPtr difrPtr zPtr kPtr cPtr sPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlalsa.f>
lalsa ::
   Int {- ^ icompq -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldbx -} ->
   CArray (Int,Int) Double {- ^ u -} ->
   CArray (Int,Int) Double {- ^ vt -} ->
   CArray Int CInt {- ^ k -} ->
   CArray (Int,Int) Double {- ^ difl -} ->
   CArray (Int,Int) Double {- ^ difr -} ->
   CArray (Int,Int) Double {- ^ z -} ->
   CArray (Int,Int) Double {- ^ poles -} ->
   CArray Int CInt {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) CInt {- ^ perm -} ->
   CArray (Int,Int) Double {- ^ givnum -} ->
   CArray Int Double {- ^ c -} ->
   CArray Int Double {- ^ s -} ->
   IO (CArray (Int,Int) Double, Int)
lalsa icompq b ldbx u vt k difl difr z poles givptr givcol perm givnum c s = do
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let (uDim0,uDim1) = Call.sizes2 $ bounds u
   let (vtDim0,vtDim1) = Call.sizes2 $ bounds vt
   let kDim0 = Call.sizes1 $ bounds k
   let (diflDim0,diflDim1) = Call.sizes2 $ bounds difl
   let (difrDim0,difrDim1) = Call.sizes2 $ bounds difr
   let (zDim0,zDim1) = Call.sizes2 $ bounds z
   let (polesDim0,polesDim1) = Call.sizes2 $ bounds poles
   let givptrDim0 = Call.sizes1 $ bounds givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (permDim0,permDim1) = Call.sizes2 $ bounds perm
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   let nrhs = bDim0
   let ldb = bDim1
   let smlsiz = uDim0
   let ldu = uDim1
   let n = kDim0
   let nlvl = diflDim0
   let ldgcol = givcolDim1
   Call.assert "lalsa: smlsiz+1 == vtDim0" (smlsiz+1 == vtDim0)
   Call.assert "lalsa: ldu == vtDim1" (ldu == vtDim1)
   Call.assert "lalsa: ldu == diflDim1" (ldu == diflDim1)
   Call.assert "lalsa: 2*nlvl == difrDim0" (2*nlvl == difrDim0)
   Call.assert "lalsa: ldu == difrDim1" (ldu == difrDim1)
   Call.assert "lalsa: nlvl == zDim0" (nlvl == zDim0)
   Call.assert "lalsa: ldu == zDim1" (ldu == zDim1)
   Call.assert "lalsa: 2*nlvl == polesDim0" (2*nlvl == polesDim0)
   Call.assert "lalsa: ldu == polesDim1" (ldu == polesDim1)
   Call.assert "lalsa: n == givptrDim0" (n == givptrDim0)
   Call.assert "lalsa: 2*nlvl == givcolDim0" (2*nlvl == givcolDim0)
   Call.assert "lalsa: nlvl == permDim0" (nlvl == permDim0)
   Call.assert "lalsa: ldgcol == permDim1" (ldgcol == permDim1)
   Call.assert "lalsa: 2*nlvl == givnumDim0" (2*nlvl == givnumDim0)
   Call.assert "lalsa: ldu == givnumDim1" (ldu == givnumDim1)
   Call.assert "lalsa: n == cDim0" (n == cDim0)
   Call.assert "lalsa: n == sDim0" (n == sDim0)
   bx <- Call.newArray2 nrhs ldbx
   work <- Call.newArray1 n
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      uPtr <- Call.array u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.array vt
      kPtr <- Call.array k
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      polesPtr <- Call.array poles
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      permPtr <- Call.array perm
      givnumPtr <- Call.array givnum
      cPtr <- Call.array c
      sPtr <- Call.array s
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsa icompqPtr smlsizPtr nPtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr uPtr lduPtr vtPtr kPtr diflPtr difrPtr zPtr polesPtr givptrPtr givcolPtr ldgcolPtr permPtr givnumPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlalsd.f>
lalsd ::
   Char {- ^ uplo -} ->
   Int {- ^ smlsiz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ rcond -} ->
   Int {- ^ workSize -} ->
   Int {- ^ iworkSize -} ->
   IO (Int, Int)
lalsd uplo smlsiz d e b rcond workSize iworkSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "lalsd: n-1 == eDim0" (n-1 == eDim0)
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 iworkSize
   evalContT $ do
      uploPtr <- Call.char uplo
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      rcondPtr <- Call.double rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsd uploPtr smlsizPtr nPtr nrhsPtr dPtr ePtr bPtr ldbPtr rcondPtr rankPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlamrg.f>
lamrg ::
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   CArray Int Double {- ^ a -} ->
   Int {- ^ dtrd1 -} ->
   Int {- ^ dtrd2 -} ->
   IO (CArray Int CInt)
lamrg n1 n2 a dtrd1 dtrd2 = do
   let aDim0 = Call.sizes1 $ bounds a
   Call.assert "lamrg: n1+n2 == aDim0" (n1+n2 == aDim0)
   index <- Call.newArray1 (n1+n2)
   evalContT $ do
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      aPtr <- Call.array a
      dtrd1Ptr <- Call.cint dtrd1
      dtrd2Ptr <- Call.cint dtrd2
      indexPtr <- Call.ioarray index
      liftIO $ FFI.lamrg n1Ptr n2Ptr aPtr dtrd1Ptr dtrd2Ptr indexPtr
      liftIO $ Call.freezeArray index

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaneg.f>
laneg ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ lld -} ->
   Double {- ^ sigma -} ->
   Double {- ^ pivmin -} ->
   Int {- ^ r -} ->
   IO CInt
laneg d lld sigma pivmin r = do
   let dDim0 = Call.sizes1 $ bounds d
   let lldDim0 = Call.sizes1 $ bounds lld
   let n = dDim0
   Call.assert "laneg: n-1 == lldDim0" (n-1 == lldDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lldPtr <- Call.array lld
      sigmaPtr <- Call.double sigma
      pivminPtr <- Call.double pivmin
      rPtr <- Call.cint r
      liftIO $ FFI.laneg nPtr dPtr lldPtr sigmaPtr pivminPtr rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlangb.f>
langb ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Double
langb norm kl ku ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.langb normPtr nPtr klPtr kuPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlange.f>
lange ::
   Char {- ^ norm -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Double
lange norm m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lange normPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlangt.f>
langt ::
   Char {- ^ norm -} ->
   CArray Int Double {- ^ dl -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ du -} ->
   IO Double
langt norm dl d du = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let n = dDim0
   Call.assert "langt: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "langt: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      liftIO $ FFI.langt normPtr nPtr dlPtr dPtr duPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlanhs.f>
lanhs ::
   Char {- ^ norm -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Double
lanhs norm a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhs normPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlansb.f>
lansb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Double
lansb norm uplo k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansb normPtr uploPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlansf.f>
lansf ::
   Char {- ^ norm -} ->
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Double
lansf norm transr uplo n a lwork = do
   let aDim0 = Call.sizes1 $ bounds a
   Call.assert "lansf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansf normPtr transrPtr uploPtr nPtr aPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlansp.f>
lansp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Double
lansp norm uplo n ap lwork = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "lansp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansp normPtr uploPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlanst.f>
lanst ::
   Char {- ^ norm -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IO Double
lanst norm d e = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "lanst: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      liftIO $ FFI.lanst normPtr nPtr dPtr ePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlansy.f>
lansy ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Double
lansy norm uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansy normPtr uploPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlantb.f>
lantb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Double
lantb norm uplo diag k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantb normPtr uploPtr diagPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlantp.f>
lantp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Double
lantp norm uplo diag n ap lwork = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "lantp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantp normPtr uploPtr diagPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlantr.f>
lantr ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Double
lantr norm uplo diag m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantr normPtr uploPtr diagPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlanv2.f>
lanv2 ::
   Double {- ^ a -} ->
   Double {- ^ b -} ->
   Double {- ^ c -} ->
   Double {- ^ d -} ->
   IO (Double, Double, Double, Double, Double, Double, Double, Double, Double, Double)
lanv2 a b c d = do
   evalContT $ do
      aPtr <- Call.double a
      bPtr <- Call.double b
      cPtr <- Call.double c
      dPtr <- Call.double d
      rt1rPtr <- Call.alloca
      rt1iPtr <- Call.alloca
      rt2rPtr <- Call.alloca
      rt2iPtr <- Call.alloca
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      liftIO $ FFI.lanv2 aPtr bPtr cPtr dPtr rt1rPtr rt1iPtr rt2rPtr rt2iPtr csPtr snPtr
      liftIO $ pure (,,,,,,,,,)
         <*> peek aPtr
         <*> peek bPtr
         <*> peek cPtr
         <*> peek dPtr
         <*> peek rt1rPtr
         <*> peek rt1iPtr
         <*> peek rt2rPtr
         <*> peek rt2iPtr
         <*> peek csPtr
         <*> peek snPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapll.f>
lapll ::
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO (Double)
lapll n x incx y incy = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      ssminPtr <- Call.alloca
      liftIO $ FFI.lapll nPtr xPtr incxPtr yPtr incyPtr ssminPtr
      liftIO $ peek ssminPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapmr.f>
lapmr ::
   Bool {- ^ forwrd -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IOCArray Int CInt {- ^ k -} ->
   IO ()
lapmr forwrd x k = do
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   kDim0 <- Call.sizes1 <$> getBounds k
   let n = xDim0
   let ldx = xDim1
   let m = kDim0
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmr forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapmt.f>
lapmt ::
   Bool {- ^ forwrd -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IOCArray Int CInt {- ^ k -} ->
   IO ()
lapmt forwrd m x k = do
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   kDim0 <- Call.sizes1 <$> getBounds k
   let n = xDim0
   let ldx = xDim1
   Call.assert "lapmt: n == kDim0" (n == kDim0)
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmt forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapy2.f>
lapy2 ::
   Double {- ^ x -} ->
   Double {- ^ y -} ->
   IO Double
lapy2 x y = do
   evalContT $ do
      xPtr <- Call.double x
      yPtr <- Call.double y
      liftIO $ FFI.lapy2 xPtr yPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapy3.f>
lapy3 ::
   Double {- ^ x -} ->
   Double {- ^ y -} ->
   Double {- ^ z -} ->
   IO Double
lapy3 x y z = do
   evalContT $ do
      xPtr <- Call.double x
      yPtr <- Call.double y
      zPtr <- Call.double z
      liftIO $ FFI.lapy3 xPtr yPtr zPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqgb.f>
laqgb ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   CArray Int Double {- ^ r -} ->
   CArray Int Double {- ^ c -} ->
   Double {- ^ rowcnd -} ->
   Double {- ^ colcnd -} ->
   Double {- ^ amax -} ->
   IO (Char)
laqgb kl ku ab r c rowcnd colcnd amax = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let rDim0 = Call.sizes1 $ bounds r
   let cDim0 = Call.sizes1 $ bounds c
   let n = abDim0
   let ldab = abDim1
   let m = rDim0
   Call.assert "laqgb: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.double rowcnd
      colcndPtr <- Call.double colcnd
      amaxPtr <- Call.double amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqgb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqge.f>
laqge ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ r -} ->
   CArray Int Double {- ^ c -} ->
   Double {- ^ rowcnd -} ->
   Double {- ^ colcnd -} ->
   Double {- ^ amax -} ->
   IO (Char)
laqge a r c rowcnd colcnd amax = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let rDim0 = Call.sizes1 $ bounds r
   let cDim0 = Call.sizes1 $ bounds c
   let n = aDim0
   let lda = aDim1
   let m = rDim0
   Call.assert "laqge: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.double rowcnd
      colcndPtr <- Call.double colcnd
      amaxPtr <- Call.double amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqge mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqp2.f>
laqp2 ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   IOCArray Int Double {- ^ vn1 -} ->
   IOCArray Int Double {- ^ vn2 -} ->
   IO (CArray Int Double)
laqp2 m offset a jpvt vn1 vn2 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   vn1Dim0 <- Call.sizes1 <$> getBounds vn1
   vn2Dim0 <- Call.sizes1 <$> getBounds vn2
   let n = aDim0
   let lda = aDim1
   Call.assert "laqp2: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqp2: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqp2: n == vn2Dim0" (n == vn2Dim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      workPtr <- Call.ioarray work
      liftIO $ FFI.laqp2 mPtr nPtr offsetPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqps.f>
laqps ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Int {- ^ kb -} ->
   IOCArray Int Double {- ^ vn1 -} ->
   IOCArray Int Double {- ^ vn2 -} ->
   IOCArray Int Double {- ^ auxv -} ->
   IOCArray (Int,Int) Double {- ^ f -} ->
   IO (Int, CArray Int Double)
laqps m offset a jpvt kb vn1 vn2 auxv f = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   vn1Dim0 <- Call.sizes1 <$> getBounds vn1
   vn2Dim0 <- Call.sizes1 <$> getBounds vn2
   auxvDim0 <- Call.sizes1 <$> getBounds auxv
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let n = aDim0
   let lda = aDim1
   let nb = auxvDim0
   let ldf = fDim1
   Call.assert "laqps: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqps: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqps: n == vn2Dim0" (n == vn2Dim0)
   Call.assert "laqps: nb == fDim0" (nb == fDim0)
   tau <- Call.newArray1 kb
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      auxvPtr <- Call.ioarray auxv
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      liftIO $ FFI.laqps mPtr nPtr offsetPtr nbPtr kbPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr auxvPtr fPtr ldfPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr0.f>
laqr0 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
laqr0 wantt wantz ilo h iloz ihiz z workSize lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   wr <- Call.newArray1 ihi
   wi <- Call.newArray1 ihi
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr0 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr1.f>
laqr1 ::
   CArray (Int,Int) Double {- ^ h -} ->
   Double {- ^ sr1 -} ->
   Double {- ^ si1 -} ->
   Double {- ^ sr2 -} ->
   Double {- ^ si2 -} ->
   IO (CArray Int Double)
laqr1 h sr1 si1 sr2 si2 = do
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   let n = hDim0
   let ldh = hDim1
   v <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      sr1Ptr <- Call.double sr1
      si1Ptr <- Call.double si1
      sr2Ptr <- Call.double sr2
      si2Ptr <- Call.double si2
      vPtr <- Call.ioarray v
      liftIO $ FFI.laqr1 nPtr hPtr ldhPtr sr1Ptr si1Ptr sr2Ptr si2Ptr vPtr
      liftIO $ Call.freezeArray v

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr2.f>
laqr2 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double)
laqr2 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr2: n == zDim0" (n == zDim0)
   sr <- Call.newArray1 kbot
   si <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr2 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr srPtr siPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sr
         <*> Call.freezeArray si
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr3.f>
laqr3 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double)
laqr3 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr3: n == zDim0" (n == zDim0)
   sr <- Call.newArray1 kbot
   si <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr3 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr srPtr siPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sr
         <*> Call.freezeArray si
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr4.f>
laqr4 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int)
laqr4 wantt wantz ilo h iloz ihiz z workSize lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   wr <- Call.newArray1 ihi
   wi <- Call.newArray1 ihi
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr4 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqr5.f>
laqr5 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ kacc22 -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   IOCArray Int Double {- ^ sr -} ->
   IOCArray Int Double {- ^ si -} ->
   IOCArray (Int,Int) Double {- ^ h -} ->
   Int {- ^ iloz -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ ldu -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldwh -} ->
   IO (CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double)
laqr5 wantt wantz kacc22 ktop kbot sr si h iloz z ldv ldu nv ldwv nh ldwh = do
   srDim0 <- Call.sizes1 <$> getBounds sr
   siDim0 <- Call.sizes1 <$> getBounds si
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let nshfts = srDim0
   let n = hDim0
   let ldh = hDim1
   let ihiz = zDim0
   let ldz = zDim1
   Call.assert "laqr5: nshfts == siDim0" (nshfts == siDim0)
   v <- Call.newArray2 (nshfts`div`2) ldv
   u <- Call.newArray2 (3*nshfts-3) ldu
   wv <- Call.newArray2 (3*nshfts-3) ldwv
   wh <- Call.newArray2 nh ldwh
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      kacc22Ptr <- Call.cint kacc22
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nshftsPtr <- Call.cint nshfts
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      nhPtr <- Call.cint nh
      whPtr <- Call.ioarray wh
      ldwhPtr <- Call.cint ldwh
      liftIO $ FFI.laqr5 wanttPtr wantzPtr kacc22Ptr nPtr ktopPtr kbotPtr nshftsPtr srPtr siPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr vPtr ldvPtr uPtr lduPtr nvPtr wvPtr ldwvPtr nhPtr whPtr ldwhPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray u
         <*> Call.freezeArray wv
         <*> Call.freezeArray wh

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqsb.f>
laqsb ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   CArray Int Double {- ^ s -} ->
   Double {- ^ scond -} ->
   Double {- ^ amax -} ->
   IO (Char)
laqsb uplo kd ab s scond amax = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let sDim0 = Call.sizes1 $ bounds s
   let n = abDim0
   let ldab = abDim1
   Call.assert "laqsb: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.array s
      scondPtr <- Call.double scond
      amaxPtr <- Call.double amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsb uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqsp.f>
laqsp ::
   Char {- ^ uplo -} ->
   IOCArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ s -} ->
   Double {- ^ scond -} ->
   Double {- ^ amax -} ->
   IO (Char)
laqsp uplo ap s scond amax = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let sDim0 = Call.sizes1 $ bounds s
   let n = sDim0
   Call.assert "laqsp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      sPtr <- Call.array s
      scondPtr <- Call.double scond
      amaxPtr <- Call.double amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsp uploPtr nPtr apPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqsy.f>
laqsy ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ s -} ->
   Double {- ^ scond -} ->
   Double {- ^ amax -} ->
   IO (Char)
laqsy uplo a s scond amax = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let sDim0 = Call.sizes1 $ bounds s
   let n = aDim0
   let lda = aDim1
   Call.assert "laqsy: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.array s
      scondPtr <- Call.double scond
      amaxPtr <- Call.double amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsy uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaqtr.f>
laqtr ::
   Bool {- ^ ltran -} ->
   Bool {- ^ lreal -} ->
   CArray (Int,Int) Double {- ^ t -} ->
   CArray Int Double {- ^ b -} ->
   Double {- ^ w -} ->
   IOCArray Int Double {- ^ x -} ->
   IO (Double, Int)
laqtr ltran lreal t b w x = do
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   let bDim0 = Call.sizes1 $ bounds b
   xDim0 <- Call.sizes1 <$> getBounds x
   let n = tDim0
   let ldt = tDim1
   Call.assert "laqtr: n == bDim0" (n == bDim0)
   Call.assert "laqtr: 2*n == xDim0" (2*n == xDim0)
   work <- Call.newArray1 n
   evalContT $ do
      ltranPtr <- Call.bool ltran
      lrealPtr <- Call.bool lreal
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      bPtr <- Call.array b
      wPtr <- Call.double w
      scalePtr <- Call.alloca
      xPtr <- Call.ioarray x
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.laqtr ltranPtr lrealPtr nPtr tPtr ldtPtr bPtr wPtr scalePtr xPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlar1v.f>
lar1v ::
   Int {- ^ b1 -} ->
   Int {- ^ bn -} ->
   Double {- ^ lambda -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ l -} ->
   CArray Int Double {- ^ ld -} ->
   CArray Int Double {- ^ lld -} ->
   Double {- ^ pivmin -} ->
   Double {- ^ gaptol -} ->
   IOCArray Int Double {- ^ z -} ->
   Bool {- ^ wantnc -} ->
   Int {- ^ r -} ->
   IO (Int, Double, Double, Int, CArray Int CInt, Double, Double, Double)
lar1v b1 bn lambda d l ld lld pivmin gaptol z wantnc r = do
   let dDim0 = Call.sizes1 $ bounds d
   let lDim0 = Call.sizes1 $ bounds l
   let ldDim0 = Call.sizes1 $ bounds ld
   let lldDim0 = Call.sizes1 $ bounds lld
   zDim0 <- Call.sizes1 <$> getBounds z
   let n = dDim0
   Call.assert "lar1v: n-1 == lDim0" (n-1 == lDim0)
   Call.assert "lar1v: n-1 == ldDim0" (n-1 == ldDim0)
   Call.assert "lar1v: n-1 == lldDim0" (n-1 == lldDim0)
   Call.assert "lar1v: n == zDim0" (n == zDim0)
   isuppz <- Call.newArray1 2
   work <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      b1Ptr <- Call.cint b1
      bnPtr <- Call.cint bn
      lambdaPtr <- Call.double lambda
      dPtr <- Call.array d
      lPtr <- Call.array l
      ldPtr <- Call.array ld
      lldPtr <- Call.array lld
      pivminPtr <- Call.double pivmin
      gaptolPtr <- Call.double gaptol
      zPtr <- Call.ioarray z
      wantncPtr <- Call.bool wantnc
      negcntPtr <- Call.alloca
      ztzPtr <- Call.alloca
      mingmaPtr <- Call.alloca
      rPtr <- Call.cint r
      isuppzPtr <- Call.ioarray isuppz
      nrminvPtr <- Call.alloca
      residPtr <- Call.alloca
      rqcorrPtr <- Call.alloca
      workPtr <- Call.ioarray work
      liftIO $ FFI.lar1v nPtr b1Ptr bnPtr lambdaPtr dPtr lPtr ldPtr lldPtr pivminPtr gaptolPtr zPtr wantncPtr negcntPtr ztzPtr mingmaPtr rPtr isuppzPtr nrminvPtr residPtr rqcorrPtr workPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek negcntPtr)
         <*> peek ztzPtr
         <*> peek mingmaPtr
         <*> fmap fromIntegral (peek rPtr)
         <*> Call.freezeArray isuppz
         <*> peek nrminvPtr
         <*> peek residPtr
         <*> peek rqcorrPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlar2v.f>
lar2v ::
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ x -} ->
   IOCArray Int Double {- ^ y -} ->
   IOCArray Int Double {- ^ z -} ->
   Int {- ^ incx -} ->
   CArray Int Double {- ^ c -} ->
   CArray Int Double {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lar2v n x y z incx c s incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   zDim0 <- Call.sizes1 <$> getBounds z
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   let _xSize = xDim0
   let _ySize = yDim0
   let _zSize = zDim0
   Call.assert "lar2v: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lar2v: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      zPtr <- Call.ioarray z
      incxPtr <- Call.cint incx
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lar2v nPtr xPtr yPtr zPtr incxPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarf.f>
larf ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   CArray Int Double {- ^ v -} ->
   Int {- ^ incv -} ->
   Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larf side m v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.double tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larf sidePtr mPtr nPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarfb.f>
larfb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ v -} ->
   CArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larfb side trans direct storev m v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larfb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarfg.f>
larfg ::
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   IOCArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Double, Double)
larfg n alpha x incx = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfg nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarfgp.f>
larfgp ::
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   IOCArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Double, Double)
larfgp n alpha x incx = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfgp nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarft.f>
larft ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   CArray (Int,Int) Double {- ^ v -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (CArray (Int,Int) Double)
larft direct storev n v tau ldt = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let tauDim0 = Call.sizes1 $ bounds tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larft directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarfx.f>
larfx ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   CArray Int Double {- ^ v -} ->
   Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larfx side m v tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      tauPtr <- Call.double tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larfx sidePtr mPtr nPtr vPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlargv.f>
largv ::
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int Double {- ^ y -} ->
   Int {- ^ incy -} ->
   Int {- ^ incc -} ->
   IO (CArray Int Double)
largv n x incx y incy incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let _xSize = xDim0
   let _ySize = yDim0
   c <- Call.newArray1 (1+(n-1)*incc)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.ioarray c
      inccPtr <- Call.cint incc
      liftIO $ FFI.largv nPtr xPtr incxPtr yPtr incyPtr cPtr inccPtr
      liftIO $ Call.freezeArray c

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarnv.f>
larnv ::
   Int {- ^ idist -} ->
   IOCArray Int CInt {- ^ iseed -} ->
   Int {- ^ n -} ->
   IO (CArray Int Double)
larnv idist iseed n = do
   iseedDim0 <- Call.sizes1 <$> getBounds iseed
   Call.assert "larnv: 4 == iseedDim0" (4 == iseedDim0)
   x <- Call.newArray1 n
   evalContT $ do
      idistPtr <- Call.cint idist
      iseedPtr <- Call.ioarray iseed
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      liftIO $ FFI.larnv idistPtr iseedPtr nPtr xPtr
      liftIO $ Call.freezeArray x

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarra.f>
larra ::
   CArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray Int Double {- ^ e2 -} ->
   Double {- ^ spltol -} ->
   Double {- ^ tnrm -} ->
   IO (Int, CArray Int CInt, Int)
larra d e e2 spltol tnrm = do
   let dDim0 = Call.sizes1 $ bounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   e2Dim0 <- Call.sizes1 <$> getBounds e2
   let n = dDim0
   Call.assert "larra: n == eDim0" (n == eDim0)
   Call.assert "larra: n == e2Dim0" (n == e2Dim0)
   isplit <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.ioarray e
      e2Ptr <- Call.ioarray e2
      spltolPtr <- Call.double spltol
      tnrmPtr <- Call.double tnrm
      nsplitPtr <- Call.alloca
      isplitPtr <- Call.ioarray isplit
      infoPtr <- Call.alloca
      liftIO $ FFI.larra nPtr dPtr ePtr e2Ptr spltolPtr tnrmPtr nsplitPtr isplitPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrb.f>
larrb ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ lld -} ->
   Int {- ^ ifirst -} ->
   Int {- ^ ilast -} ->
   Double {- ^ rtol1 -} ->
   Double {- ^ rtol2 -} ->
   Int {- ^ offset -} ->
   IOCArray Int Double {- ^ w -} ->
   IOCArray Int Double {- ^ wgap -} ->
   IOCArray Int Double {- ^ werr -} ->
   Double {- ^ pivmin -} ->
   Double {- ^ spdiam -} ->
   Int {- ^ twist -} ->
   IO (Int)
larrb d lld ifirst ilast rtol1 rtol2 offset w wgap werr pivmin spdiam twist = do
   let dDim0 = Call.sizes1 $ bounds d
   let lldDim0 = Call.sizes1 $ bounds lld
   wDim0 <- Call.sizes1 <$> getBounds w
   wgapDim0 <- Call.sizes1 <$> getBounds wgap
   werrDim0 <- Call.sizes1 <$> getBounds werr
   let n = dDim0
   Call.assert "larrb: n-1 == lldDim0" (n-1 == lldDim0)
   Call.assert "larrb: n == wDim0" (n == wDim0)
   Call.assert "larrb: n-1 == wgapDim0" (n-1 == wgapDim0)
   Call.assert "larrb: n == werrDim0" (n == werrDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lldPtr <- Call.array lld
      ifirstPtr <- Call.cint ifirst
      ilastPtr <- Call.cint ilast
      rtol1Ptr <- Call.double rtol1
      rtol2Ptr <- Call.double rtol2
      offsetPtr <- Call.cint offset
      wPtr <- Call.ioarray w
      wgapPtr <- Call.ioarray wgap
      werrPtr <- Call.ioarray werr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      pivminPtr <- Call.double pivmin
      spdiamPtr <- Call.double spdiam
      twistPtr <- Call.cint twist
      infoPtr <- Call.alloca
      liftIO $ FFI.larrb nPtr dPtr lldPtr ifirstPtr ilastPtr rtol1Ptr rtol2Ptr offsetPtr wPtr wgapPtr werrPtr workPtr iworkPtr pivminPtr spdiamPtr twistPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrc.f>
larrc ::
   Char {- ^ jobt -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   Double {- ^ pivmin -} ->
   IO (Int, Int, Int, Int)
larrc jobt vl vu d e pivmin = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "larrc: n == eDim0" (n == eDim0)
   evalContT $ do
      jobtPtr <- Call.char jobt
      nPtr <- Call.cint n
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      dPtr <- Call.array d
      ePtr <- Call.array e
      pivminPtr <- Call.double pivmin
      eigcntPtr <- Call.alloca
      lcntPtr <- Call.alloca
      rcntPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.larrc jobtPtr nPtr vlPtr vuPtr dPtr ePtr pivminPtr eigcntPtr lcntPtr rcntPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek eigcntPtr)
         <*> fmap fromIntegral (peek lcntPtr)
         <*> fmap fromIntegral (peek rcntPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrd.f>
larrd ::
   Char {- ^ range -} ->
   Char {- ^ order -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   CArray Int Double {- ^ gers -} ->
   Double {- ^ reltol -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   CArray Int Double {- ^ e2 -} ->
   Double {- ^ pivmin -} ->
   Int {- ^ nsplit -} ->
   CArray Int CInt {- ^ isplit -} ->
   IO (Int, CArray Int Double, CArray Int Double, Double, Double, CArray Int CInt, CArray Int CInt, Int)
larrd range order vl vu il iu gers reltol d e e2 pivmin nsplit isplit = do
   let gersDim0 = Call.sizes1 $ bounds gers
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let e2Dim0 = Call.sizes1 $ bounds e2
   let isplitDim0 = Call.sizes1 $ bounds isplit
   let n = dDim0
   Call.assert "larrd: 2*n == gersDim0" (2*n == gersDim0)
   Call.assert "larrd: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "larrd: n-1 == e2Dim0" (n-1 == e2Dim0)
   Call.assert "larrd: n == isplitDim0" (n == isplitDim0)
   w <- Call.newArray1 n
   werr <- Call.newArray1 n
   iblock <- Call.newArray1 n
   indexw <- Call.newArray1 n
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      rangePtr <- Call.char range
      orderPtr <- Call.char order
      nPtr <- Call.cint n
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      gersPtr <- Call.array gers
      reltolPtr <- Call.double reltol
      dPtr <- Call.array d
      ePtr <- Call.array e
      e2Ptr <- Call.array e2
      pivminPtr <- Call.double pivmin
      nsplitPtr <- Call.cint nsplit
      isplitPtr <- Call.array isplit
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wlPtr <- Call.alloca
      wuPtr <- Call.alloca
      iblockPtr <- Call.ioarray iblock
      indexwPtr <- Call.ioarray indexw
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larrd rangePtr orderPtr nPtr vlPtr vuPtr ilPtr iuPtr gersPtr reltolPtr dPtr ePtr e2Ptr pivminPtr nsplitPtr isplitPtr mPtr wPtr werrPtr wlPtr wuPtr iblockPtr indexwPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray werr
         <*> peek wlPtr
         <*> peek wuPtr
         <*> Call.freezeArray iblock
         <*> Call.freezeArray indexw
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarre.f>
larre ::
   Char {- ^ range -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray Int Double {- ^ e2 -} ->
   Double {- ^ rtol1 -} ->
   Double {- ^ rtol2 -} ->
   Double {- ^ spltol -} ->
   IO (Double, Double, Int, CArray Int CInt, Int, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int CInt, CArray Int CInt, CArray Int Double, Double, Int)
larre range vl vu il iu d e e2 rtol1 rtol2 spltol = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   e2Dim0 <- Call.sizes1 <$> getBounds e2
   let n = dDim0
   Call.assert "larre: n == eDim0" (n == eDim0)
   Call.assert "larre: n == e2Dim0" (n == e2Dim0)
   isplit <- Call.newArray1 n
   w <- Call.newArray1 n
   werr <- Call.newArray1 n
   wgap <- Call.newArray1 n
   iblock <- Call.newArray1 n
   indexw <- Call.newArray1 n
   gers <- Call.newArray1 (2*n)
   work <- Call.newArray1 (6*n)
   iwork <- Call.newArray1 (5*n)
   evalContT $ do
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      e2Ptr <- Call.ioarray e2
      rtol1Ptr <- Call.double rtol1
      rtol2Ptr <- Call.double rtol2
      spltolPtr <- Call.double spltol
      nsplitPtr <- Call.alloca
      isplitPtr <- Call.ioarray isplit
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wgapPtr <- Call.ioarray wgap
      iblockPtr <- Call.ioarray iblock
      indexwPtr <- Call.ioarray indexw
      gersPtr <- Call.ioarray gers
      pivminPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larre rangePtr nPtr vlPtr vuPtr ilPtr iuPtr dPtr ePtr e2Ptr rtol1Ptr rtol2Ptr spltolPtr nsplitPtr isplitPtr mPtr wPtr werrPtr wgapPtr iblockPtr indexwPtr gersPtr pivminPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,)
         <*> peek vlPtr
         <*> peek vuPtr
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray werr
         <*> Call.freezeArray wgap
         <*> Call.freezeArray iblock
         <*> Call.freezeArray indexw
         <*> Call.freezeArray gers
         <*> peek pivminPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrf.f>
larrf ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ l -} ->
   CArray Int Double {- ^ ld -} ->
   Int {- ^ clstrt -} ->
   Int {- ^ clend -} ->
   CArray Int Double {- ^ w -} ->
   IOCArray Int Double {- ^ wgap -} ->
   CArray Int Double {- ^ werr -} ->
   Double {- ^ spdiam -} ->
   Double {- ^ clgapl -} ->
   Double {- ^ clgapr -} ->
   Double {- ^ pivmin -} ->
   IO (Double, CArray Int Double, CArray Int Double, Int)
larrf d l ld clstrt clend w wgap werr spdiam clgapl clgapr pivmin = do
   let dDim0 = Call.sizes1 $ bounds d
   let lDim0 = Call.sizes1 $ bounds l
   let ldDim0 = Call.sizes1 $ bounds ld
   let wDim0 = Call.sizes1 $ bounds w
   wgapDim0 <- Call.sizes1 <$> getBounds wgap
   let werrDim0 = Call.sizes1 $ bounds werr
   let n = dDim0
   let _wSize = wDim0
   let _wgapSize = wgapDim0
   let _werrSize = werrDim0
   Call.assert "larrf: n-1 == lDim0" (n-1 == lDim0)
   Call.assert "larrf: n-1 == ldDim0" (n-1 == ldDim0)
   dplus <- Call.newArray1 n
   lplus <- Call.newArray1 (n-1)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lPtr <- Call.array l
      ldPtr <- Call.array ld
      clstrtPtr <- Call.cint clstrt
      clendPtr <- Call.cint clend
      wPtr <- Call.array w
      wgapPtr <- Call.ioarray wgap
      werrPtr <- Call.array werr
      spdiamPtr <- Call.double spdiam
      clgaplPtr <- Call.double clgapl
      clgaprPtr <- Call.double clgapr
      pivminPtr <- Call.double pivmin
      sigmaPtr <- Call.alloca
      dplusPtr <- Call.ioarray dplus
      lplusPtr <- Call.ioarray lplus
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.larrf nPtr dPtr lPtr ldPtr clstrtPtr clendPtr wPtr wgapPtr werrPtr spdiamPtr clgaplPtr clgaprPtr pivminPtr sigmaPtr dplusPtr lplusPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> peek sigmaPtr
         <*> Call.freezeArray dplus
         <*> Call.freezeArray lplus
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrj.f>
larrj ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e2 -} ->
   Int {- ^ ifirst -} ->
   Int {- ^ ilast -} ->
   Double {- ^ rtol -} ->
   Int {- ^ offset -} ->
   IOCArray Int Double {- ^ w -} ->
   IOCArray Int Double {- ^ werr -} ->
   Double {- ^ pivmin -} ->
   Double {- ^ spdiam -} ->
   IO (Int)
larrj d e2 ifirst ilast rtol offset w werr pivmin spdiam = do
   let dDim0 = Call.sizes1 $ bounds d
   let e2Dim0 = Call.sizes1 $ bounds e2
   wDim0 <- Call.sizes1 <$> getBounds w
   werrDim0 <- Call.sizes1 <$> getBounds werr
   let n = dDim0
   Call.assert "larrj: n-1 == e2Dim0" (n-1 == e2Dim0)
   Call.assert "larrj: n == wDim0" (n == wDim0)
   Call.assert "larrj: n == werrDim0" (n == werrDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      e2Ptr <- Call.array e2
      ifirstPtr <- Call.cint ifirst
      ilastPtr <- Call.cint ilast
      rtolPtr <- Call.double rtol
      offsetPtr <- Call.cint offset
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      pivminPtr <- Call.double pivmin
      spdiamPtr <- Call.double spdiam
      infoPtr <- Call.alloca
      liftIO $ FFI.larrj nPtr dPtr e2Ptr ifirstPtr ilastPtr rtolPtr offsetPtr wPtr werrPtr workPtr iworkPtr pivminPtr spdiamPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrk.f>
larrk ::
   Int {- ^ iw -} ->
   Double {- ^ gl -} ->
   Double {- ^ gu -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e2 -} ->
   Double {- ^ pivmin -} ->
   Double {- ^ reltol -} ->
   IO (Double, Double, Int)
larrk iw gl gu d e2 pivmin reltol = do
   let dDim0 = Call.sizes1 $ bounds d
   let e2Dim0 = Call.sizes1 $ bounds e2
   let n = dDim0
   Call.assert "larrk: n-1 == e2Dim0" (n-1 == e2Dim0)
   evalContT $ do
      nPtr <- Call.cint n
      iwPtr <- Call.cint iw
      glPtr <- Call.double gl
      guPtr <- Call.double gu
      dPtr <- Call.array d
      e2Ptr <- Call.array e2
      pivminPtr <- Call.double pivmin
      reltolPtr <- Call.double reltol
      wPtr <- Call.alloca
      werrPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.larrk nPtr iwPtr glPtr guPtr dPtr e2Ptr pivminPtr reltolPtr wPtr werrPtr infoPtr
      liftIO $ pure (,,)
         <*> peek wPtr
         <*> peek werrPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrr.f>
larrr ::
   CArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IO (Int)
larrr d e = do
   let dDim0 = Call.sizes1 $ bounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "larrr: n == eDim0" (n == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.larrr nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrv.f>
larrv ::
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ l -} ->
   Double {- ^ pivmin -} ->
   CArray Int CInt {- ^ isplit -} ->
   Int {- ^ m -} ->
   Int {- ^ dol -} ->
   Int {- ^ dou -} ->
   Double {- ^ minrgp -} ->
   Double {- ^ rtol1 -} ->
   Double {- ^ rtol2 -} ->
   IOCArray Int Double {- ^ w -} ->
   IOCArray Int Double {- ^ werr -} ->
   IOCArray Int Double {- ^ wgap -} ->
   CArray Int CInt {- ^ iblock -} ->
   CArray Int CInt {- ^ indexw -} ->
   CArray Int Double {- ^ gers -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) Double, CArray Int CInt, Int)
larrv vl vu d l pivmin isplit m dol dou minrgp rtol1 rtol2 w werr wgap iblock indexw gers ldz = do
   dDim0 <- Call.sizes1 <$> getBounds d
   lDim0 <- Call.sizes1 <$> getBounds l
   let isplitDim0 = Call.sizes1 $ bounds isplit
   wDim0 <- Call.sizes1 <$> getBounds w
   werrDim0 <- Call.sizes1 <$> getBounds werr
   wgapDim0 <- Call.sizes1 <$> getBounds wgap
   let iblockDim0 = Call.sizes1 $ bounds iblock
   let indexwDim0 = Call.sizes1 $ bounds indexw
   let gersDim0 = Call.sizes1 $ bounds gers
   let n = dDim0
   Call.assert "larrv: n == lDim0" (n == lDim0)
   Call.assert "larrv: n == isplitDim0" (n == isplitDim0)
   Call.assert "larrv: n == wDim0" (n == wDim0)
   Call.assert "larrv: n == werrDim0" (n == werrDim0)
   Call.assert "larrv: n == wgapDim0" (n == wgapDim0)
   Call.assert "larrv: n == iblockDim0" (n == iblockDim0)
   Call.assert "larrv: n == indexwDim0" (n == indexwDim0)
   Call.assert "larrv: 2*n == gersDim0" (2*n == gersDim0)
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (12*n)
   iwork <- Call.newArray1 (7*n)
   evalContT $ do
      nPtr <- Call.cint n
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      dPtr <- Call.ioarray d
      lPtr <- Call.ioarray l
      pivminPtr <- Call.double pivmin
      isplitPtr <- Call.array isplit
      mPtr <- Call.cint m
      dolPtr <- Call.cint dol
      douPtr <- Call.cint dou
      minrgpPtr <- Call.double minrgp
      rtol1Ptr <- Call.double rtol1
      rtol2Ptr <- Call.double rtol2
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wgapPtr <- Call.ioarray wgap
      iblockPtr <- Call.array iblock
      indexwPtr <- Call.array indexw
      gersPtr <- Call.array gers
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larrv nPtr vlPtr vuPtr dPtr lPtr pivminPtr isplitPtr mPtr dolPtr douPtr minrgpPtr rtol1Ptr rtol2Ptr wPtr werrPtr wgapPtr iblockPtr indexwPtr gersPtr zPtr ldzPtr isuppzPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartg.f>
lartg ::
   Double {- ^ f -} ->
   Double {- ^ g -} ->
   IO (Double, Double, Double)
lartg f g = do
   evalContT $ do
      fPtr <- Call.double f
      gPtr <- Call.double g
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      rPtr <- Call.alloca
      liftIO $ FFI.lartg fPtr gPtr csPtr snPtr rPtr
      liftIO $ pure (,,)
         <*> peek csPtr
         <*> peek snPtr
         <*> peek rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartgp.f>
lartgp ::
   Double {- ^ f -} ->
   Double {- ^ g -} ->
   IO (Double, Double, Double)
lartgp f g = do
   evalContT $ do
      fPtr <- Call.double f
      gPtr <- Call.double g
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      rPtr <- Call.alloca
      liftIO $ FFI.lartgp fPtr gPtr csPtr snPtr rPtr
      liftIO $ pure (,,)
         <*> peek csPtr
         <*> peek snPtr
         <*> peek rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartgs.f>
lartgs ::
   Double {- ^ x -} ->
   Double {- ^ y -} ->
   Double {- ^ sigma -} ->
   IO (Double, Double)
lartgs x y sigma = do
   evalContT $ do
      xPtr <- Call.double x
      yPtr <- Call.double y
      sigmaPtr <- Call.double sigma
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      liftIO $ FFI.lartgs xPtr yPtr sigmaPtr csPtr snPtr
      liftIO $ pure (,)
         <*> peek csPtr
         <*> peek snPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartv.f>
lartv ::
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int Double {- ^ y -} ->
   Int {- ^ incy -} ->
   CArray Int Double {- ^ c -} ->
   CArray Int Double {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lartv n x incx y incy c s incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   let _xSize = xDim0
   let _ySize = yDim0
   Call.assert "lartv: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lartv: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lartv nPtr xPtr incxPtr yPtr incyPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaruv.f>
laruv ::
   IOCArray Int CInt {- ^ iseed -} ->
   Int {- ^ n -} ->
   IO (CArray Int Double)
laruv iseed n = do
   iseedDim0 <- Call.sizes1 <$> getBounds iseed
   Call.assert "laruv: 4 == iseedDim0" (4 == iseedDim0)
   x <- Call.newArray1 n
   evalContT $ do
      iseedPtr <- Call.ioarray iseed
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      liftIO $ FFI.laruv iseedPtr nPtr xPtr
      liftIO $ Call.freezeArray x

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarz.f>
larz ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray Int Double {- ^ v -} ->
   Int {- ^ incv -} ->
   Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larz side m l v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = cDim0
   let ldc = cDim1
   Call.assert "larz: 1+(l-1)*abs(incv) == vDim0" (1+(l-1)*abs(incv) == vDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.double tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larz sidePtr mPtr nPtr lPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarzb.f>
larzb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) Double {- ^ v -} ->
   CArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larzb side trans direct storev m l v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _nv = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larzb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr lPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarzt.f>
larzt ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (CArray (Int,Int) Double)
larzt direct storev n v tau ldt = do
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let tauDim0 = Call.sizes1 $ bounds tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larzt directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlas2.f>
las2 ::
   Double {- ^ f -} ->
   Double {- ^ g -} ->
   Double {- ^ h -} ->
   IO (Double, Double)
las2 f g h = do
   evalContT $ do
      fPtr <- Call.double f
      gPtr <- Call.double g
      hPtr <- Call.double h
      ssminPtr <- Call.alloca
      ssmaxPtr <- Call.alloca
      liftIO $ FFI.las2 fPtr gPtr hPtr ssminPtr ssmaxPtr
      liftIO $ pure (,)
         <*> peek ssminPtr
         <*> peek ssmaxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlascl.f>
lascl ::
   Char {- ^ type_ -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Double {- ^ cfrom -} ->
   Double {- ^ cto -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
lascl type_ kl ku cfrom cto m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      type_Ptr <- Call.char type_
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      cfromPtr <- Call.double cfrom
      ctoPtr <- Call.double cto
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lascl type_Ptr klPtr kuPtr cfromPtr ctoPtr mPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd0.f>
lasd0 ::
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Int {- ^ ldu -} ->
   Int {- ^ m -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ smlsiz -} ->
   IO (CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
lasd0 sqre d e ldu m ldvt smlsiz = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "lasd0: m-1 == eDim0" (m-1 == eDim0)
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 m ldvt
   iwork <- Call.newArray1 (8*n)
   work <- Call.newArray1 (3*m^!2+2*m)
   evalContT $ do
      nPtr <- Call.cint n
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      smlsizPtr <- Call.cint smlsiz
      iworkPtr <- Call.ioarray iwork
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd0 nPtr sqrePtr dPtr ePtr uPtr lduPtr vtPtr ldvtPtr smlsizPtr iworkPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd1.f>
lasd1 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   Double {- ^ alpha -} ->
   Double {- ^ beta -} ->
   IOCArray (Int,Int) Double {- ^ u -} ->
   IOCArray (Int,Int) Double {- ^ vt -} ->
   IOCArray Int CInt {- ^ idxq -} ->
   IO (Double, Double, Int)
lasd1 nl nr sqre d alpha beta u vt idxq = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (vtDim0,vtDim1) <- Call.sizes2 <$> getBounds vt
   idxqDim0 <- Call.sizes1 <$> getBounds idxq
   let _dSize = dDim0
   let n = uDim0
   let ldu = uDim1
   let m = vtDim0
   let ldvt = vtDim1
   Call.assert "lasd1: n == idxqDim0" (n == idxqDim0)
   iwork <- Call.newArray1 (4*n)
   work <- Call.newArray1 (3*m^!2+2*m)
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      alphaPtr <- Call.double alpha
      betaPtr <- Call.double beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      idxqPtr <- Call.ioarray idxq
      iworkPtr <- Call.ioarray iwork
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd1 nlPtr nrPtr sqrePtr dPtr alphaPtr betaPtr uPtr lduPtr vtPtr ldvtPtr idxqPtr iworkPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> peek alphaPtr
         <*> peek betaPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd2.f>
lasd2 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   Double {- ^ alpha -} ->
   Double {- ^ beta -} ->
   IOCArray (Int,Int) Double {- ^ u -} ->
   IOCArray (Int,Int) Double {- ^ vt -} ->
   Int {- ^ ldu2 -} ->
   Int {- ^ ldvt2 -} ->
   IOCArray Int CInt {- ^ idxq -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int CInt, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int)
lasd2 nl nr sqre d alpha beta u vt ldu2 ldvt2 idxq = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (vtDim0,vtDim1) <- Call.sizes2 <$> getBounds vt
   idxqDim0 <- Call.sizes1 <$> getBounds idxq
   let n = dDim0
   let ldu = uDim1
   let _m = vtDim0
   let ldvt = vtDim1
   Call.assert "lasd2: n == uDim0" (n == uDim0)
   Call.assert "lasd2: n == idxqDim0" (n == idxqDim0)
   z <- Call.newArray1 n
   dsigma <- Call.newArray1 n
   u2 <- Call.newArray2 n ldu2
   vt2 <- Call.newArray2 n ldvt2
   idxp <- Call.newArray1 n
   idx <- Call.newArray1 n
   idxc <- Call.newArray1 n
   coltyp <- Call.newArray1 n
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.alloca
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      alphaPtr <- Call.double alpha
      betaPtr <- Call.double beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      dsigmaPtr <- Call.ioarray dsigma
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      vt2Ptr <- Call.ioarray vt2
      ldvt2Ptr <- Call.cint ldvt2
      idxpPtr <- Call.ioarray idxp
      idxPtr <- Call.ioarray idx
      idxcPtr <- Call.ioarray idxc
      idxqPtr <- Call.ioarray idxq
      coltypPtr <- Call.ioarray coltyp
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd2 nlPtr nrPtr sqrePtr kPtr dPtr zPtr alphaPtr betaPtr uPtr lduPtr vtPtr ldvtPtr dsigmaPtr u2Ptr ldu2Ptr vt2Ptr ldvt2Ptr idxpPtr idxPtr idxcPtr idxqPtr coltypPtr infoPtr
      liftIO $ pure (,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> Call.freezeArray z
         <*> Call.freezeArray dsigma
         <*> Call.freezeArray u2
         <*> Call.freezeArray vt2
         <*> Call.freezeArray idxp
         <*> Call.freezeArray idx
         <*> Call.freezeArray idxc
         <*> Call.freezeArray coltyp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd3.f>
lasd3 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   Int {- ^ ldq -} ->
   IOCArray Int Double {- ^ dsigma -} ->
   Int {- ^ ldu -} ->
   CArray (Int,Int) Double {- ^ u2 -} ->
   Int {- ^ m -} ->
   Int {- ^ ldvt -} ->
   IOCArray (Int,Int) Double {- ^ vt2 -} ->
   CArray Int CInt {- ^ idxc -} ->
   CArray Int CInt {- ^ ctot -} ->
   IOCArray Int Double {- ^ z -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
lasd3 nl nr sqre ldq dsigma ldu u2 m ldvt vt2 idxc ctot z = do
   dsigmaDim0 <- Call.sizes1 <$> getBounds dsigma
   let (u2Dim0,u2Dim1) = Call.sizes2 $ bounds u2
   (vt2Dim0,vt2Dim1) <- Call.sizes2 <$> getBounds vt2
   let idxcDim0 = Call.sizes1 $ bounds idxc
   let ctotDim0 = Call.sizes1 $ bounds ctot
   zDim0 <- Call.sizes1 <$> getBounds z
   let k = dsigmaDim0
   let n = u2Dim0
   let ldu2 = u2Dim1
   let ldvt2 = vt2Dim1
   Call.assert "lasd3: n == vt2Dim0" (n == vt2Dim0)
   Call.assert "lasd3: n == idxcDim0" (n == idxcDim0)
   Call.assert "lasd3: 4 == ctotDim0" (4 == ctotDim0)
   Call.assert "lasd3: k == zDim0" (k == zDim0)
   d <- Call.newArray1 k
   q <- Call.newArray2 k ldq
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 m ldvt
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.cint k
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      dsigmaPtr <- Call.ioarray dsigma
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      u2Ptr <- Call.array u2
      ldu2Ptr <- Call.cint ldu2
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      vt2Ptr <- Call.ioarray vt2
      ldvt2Ptr <- Call.cint ldvt2
      idxcPtr <- Call.array idxc
      ctotPtr <- Call.array ctot
      zPtr <- Call.ioarray z
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd3 nlPtr nrPtr sqrePtr kPtr dPtr qPtr ldqPtr dsigmaPtr uPtr lduPtr u2Ptr ldu2Ptr vtPtr ldvtPtr vt2Ptr ldvt2Ptr idxcPtr ctotPtr zPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd4.f>
lasd4 ::
   Int {- ^ i -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ rho -} ->
   IO (CArray Int Double, Double, Int)
lasd4 i d z rho = do
   let dDim0 = Call.sizes1 $ bounds d
   let zDim0 = Call.sizes1 $ bounds z
   let n = dDim0
   Call.assert "lasd4: n == zDim0" (n == zDim0)
   delta <- Call.newArray1 n
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.double rho
      sigmaPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd4 nPtr iPtr dPtr zPtr deltaPtr rhoPtr sigmaPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray delta
         <*> peek sigmaPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd5.f>
lasd5 ::
   Int {- ^ i -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ z -} ->
   Double {- ^ rho -} ->
   IO (CArray Int Double, Double)
lasd5 i d z rho = do
   let dDim0 = Call.sizes1 $ bounds d
   let zDim0 = Call.sizes1 $ bounds z
   Call.assert "lasd5: 2 == dDim0" (2 == dDim0)
   Call.assert "lasd5: 2 == zDim0" (2 == zDim0)
   delta <- Call.newArray1 2
   work <- Call.newArray1 2
   evalContT $ do
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.double rho
      dsigmaPtr <- Call.alloca
      workPtr <- Call.ioarray work
      liftIO $ FFI.lasd5 iPtr dPtr zPtr deltaPtr rhoPtr dsigmaPtr workPtr
      liftIO $ pure (,)
         <*> Call.freezeArray delta
         <*> peek dsigmaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd6.f>
lasd6 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ vf -} ->
   IOCArray Int Double {- ^ vl -} ->
   Double {- ^ alpha -} ->
   Double {- ^ beta -} ->
   IOCArray Int CInt {- ^ idxq -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ ldgnum -} ->
   Int {- ^ difrSize -} ->
   IO (Double, Double, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int Double, CArray Int Double, CArray Int Double, Int, Double, Double, Int)
lasd6 icompq nl nr sqre d vf vl alpha beta idxq ldgcol ldgnum difrSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   vfDim0 <- Call.sizes1 <$> getBounds vf
   vlDim0 <- Call.sizes1 <$> getBounds vl
   idxqDim0 <- Call.sizes1 <$> getBounds idxq
   let m = vfDim0
   let n = idxqDim0
   Call.assert "lasd6: nl+nr+1 == dDim0" (nl+nr+1 == dDim0)
   Call.assert "lasd6: m == vlDim0" (m == vlDim0)
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 2 ldgcol
   givnum <- Call.newArray2 2 ldgnum
   poles <- Call.newArray2 2 ldgnum
   difl <- Call.newArray1 n
   difr <- Call.newArray1 difrSize
   z <- Call.newArray1 m
   work <- Call.newArray1 (4*m)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      vfPtr <- Call.ioarray vf
      vlPtr <- Call.ioarray vl
      alphaPtr <- Call.double alpha
      betaPtr <- Call.double beta
      idxqPtr <- Call.ioarray idxq
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.ioarray givnum
      ldgnumPtr <- Call.cint ldgnum
      polesPtr <- Call.ioarray poles
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      zPtr <- Call.ioarray z
      kPtr <- Call.alloca
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd6 icompqPtr nlPtr nrPtr sqrePtr dPtr vfPtr vlPtr alphaPtr betaPtr idxqPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr polesPtr diflPtr difrPtr zPtr kPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> peek alphaPtr
         <*> peek betaPtr
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> Call.freezeArray poles
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek kPtr)
         <*> peek cPtr
         <*> peek sPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd7.f>
lasd7 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ vf -} ->
   IOCArray Int Double {- ^ vl -} ->
   Double {- ^ alpha -} ->
   Double {- ^ beta -} ->
   CArray Int CInt {- ^ idxq -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ ldgnum -} ->
   IO (Int, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) Double, Double, Double, Int)
lasd7 icompq nl nr sqre d vf vl alpha beta idxq ldgcol ldgnum = do
   dDim0 <- Call.sizes1 <$> getBounds d
   vfDim0 <- Call.sizes1 <$> getBounds vf
   vlDim0 <- Call.sizes1 <$> getBounds vl
   let idxqDim0 = Call.sizes1 $ bounds idxq
   let n = dDim0
   let m = vfDim0
   Call.assert "lasd7: m == vlDim0" (m == vlDim0)
   Call.assert "lasd7: n == idxqDim0" (n == idxqDim0)
   z <- Call.newArray1 m
   zw <- Call.newArray1 m
   vfw <- Call.newArray1 m
   vlw <- Call.newArray1 m
   dsigma <- Call.newArray1 n
   idx <- Call.newArray1 n
   idxp <- Call.newArray1 n
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 2 ldgcol
   givnum <- Call.newArray2 2 ldgnum
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.alloca
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      zwPtr <- Call.ioarray zw
      vfPtr <- Call.ioarray vf
      vfwPtr <- Call.ioarray vfw
      vlPtr <- Call.ioarray vl
      vlwPtr <- Call.ioarray vlw
      alphaPtr <- Call.double alpha
      betaPtr <- Call.double beta
      dsigmaPtr <- Call.ioarray dsigma
      idxPtr <- Call.ioarray idx
      idxpPtr <- Call.ioarray idxp
      idxqPtr <- Call.array idxq
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.ioarray givnum
      ldgnumPtr <- Call.cint ldgnum
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd7 icompqPtr nlPtr nrPtr sqrePtr kPtr dPtr zPtr zwPtr vfPtr vfwPtr vlPtr vlwPtr alphaPtr betaPtr dsigmaPtr idxPtr idxpPtr idxqPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr cPtr sPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> Call.freezeArray z
         <*> Call.freezeArray zw
         <*> Call.freezeArray vfw
         <*> Call.freezeArray vlw
         <*> Call.freezeArray dsigma
         <*> Call.freezeArray idx
         <*> Call.freezeArray idxp
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> peek cPtr
         <*> peek sPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd8.f>
lasd8 ::
   Int {- ^ icompq -} ->
   IOCArray Int Double {- ^ z -} ->
   IOCArray Int Double {- ^ vf -} ->
   IOCArray Int Double {- ^ vl -} ->
   Int {- ^ difrSize -} ->
   Int {- ^ lddifr -} ->
   IOCArray Int Double {- ^ dsigma -} ->
   IO (CArray Int Double, CArray Int Double, CArray (Int,Int) Double, Int)
lasd8 icompq z vf vl difrSize lddifr dsigma = do
   zDim0 <- Call.sizes1 <$> getBounds z
   vfDim0 <- Call.sizes1 <$> getBounds vf
   vlDim0 <- Call.sizes1 <$> getBounds vl
   dsigmaDim0 <- Call.sizes1 <$> getBounds dsigma
   let k = zDim0
   Call.assert "lasd8: k == vfDim0" (k == vfDim0)
   Call.assert "lasd8: k == vlDim0" (k == vlDim0)
   Call.assert "lasd8: k == dsigmaDim0" (k == dsigmaDim0)
   d <- Call.newArray1 k
   difl <- Call.newArray1 k
   difr <- Call.newArray2 difrSize lddifr
   work <- Call.newArray1 (3*k)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      kPtr <- Call.cint k
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      vfPtr <- Call.ioarray vf
      vlPtr <- Call.ioarray vl
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      lddifrPtr <- Call.cint lddifr
      dsigmaPtr <- Call.ioarray dsigma
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd8 icompqPtr kPtr dPtr zPtr vfPtr vlPtr diflPtr difrPtr lddifrPtr dsigmaPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasda.f>
lasda ::
   Int {- ^ icompq -} ->
   Int {- ^ smlsiz -} ->
   Int {- ^ sqre -} ->
   IOCArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   Int {- ^ uSize -} ->
   Int {- ^ ldu -} ->
   Int {- ^ vtSize -} ->
   Int {- ^ kSize -} ->
   Int {- ^ nlvl -} ->
   Int {- ^ difrSize -} ->
   Int {- ^ zSize -} ->
   Int {- ^ polesSize -} ->
   Int {- ^ givptrSize -} ->
   Int {- ^ givcolSize -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ permSize -} ->
   Int {- ^ givnumSize -} ->
   Int {- ^ cSize -} ->
   Int {- ^ sSize -} ->
   Int {- ^ workSize -} ->
   IO (CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int CInt, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray Int CInt, CArray (Int,Int) CInt, CArray (Int,Int) CInt, CArray (Int,Int) Double, CArray Int Double, CArray Int Double, Int)
lasda icompq smlsiz sqre d e uSize ldu vtSize kSize nlvl difrSize zSize polesSize givptrSize givcolSize ldgcol permSize givnumSize cSize sSize workSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.ignore "lasda: m-1 == eDim0" eDim0
   u <- Call.newArray2 uSize ldu
   vt <- Call.newArray2 vtSize ldu
   k <- Call.newArray1 kSize
   difl <- Call.newArray2 nlvl ldu
   difr <- Call.newArray2 difrSize ldu
   z <- Call.newArray2 zSize ldu
   poles <- Call.newArray2 polesSize ldu
   givptr <- Call.newArray1 givptrSize
   givcol <- Call.newArray2 givcolSize ldgcol
   perm <- Call.newArray2 permSize ldgcol
   givnum <- Call.newArray2 givnumSize ldu
   c <- Call.newArray1 cSize
   s <- Call.newArray1 sSize
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (7*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      ePtr <- Call.array e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      kPtr <- Call.ioarray k
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      zPtr <- Call.ioarray z
      polesPtr <- Call.ioarray poles
      givptrPtr <- Call.ioarray givptr
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      permPtr <- Call.ioarray perm
      givnumPtr <- Call.ioarray givnum
      cPtr <- Call.ioarray c
      sPtr <- Call.ioarray s
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lasda icompqPtr smlsizPtr nPtr sqrePtr dPtr ePtr uPtr lduPtr vtPtr kPtr diflPtr difrPtr zPtr polesPtr givptrPtr givcolPtr ldgcolPtr permPtr givnumPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> Call.freezeArray k
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> Call.freezeArray z
         <*> Call.freezeArray poles
         <*> Call.freezeArray givptr
         <*> Call.freezeArray givcol
         <*> Call.freezeArray perm
         <*> Call.freezeArray givnum
         <*> Call.freezeArray c
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasdq.f>
lasdq ::
   Char {- ^ uplo -} ->
   Int {- ^ sqre -} ->
   Int {- ^ nru -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ vt -} ->
   IOCArray (Int,Int) Double {- ^ u -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   IO (Int)
lasdq uplo sqre nru d e vt u c = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (vtDim0,vtDim1) <- Call.sizes2 <$> getBounds vt
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = dDim0
   let ncvt = vtDim0
   let ldvt = vtDim1
   let ldu = uDim1
   let ncc = cDim0
   let ldc = cDim1
   Call.assert "lasdq: n-1+sqre == eDim0" (n-1+sqre == eDim0)
   Call.assert "lasdq: n == uDim0" (n == uDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      sqrePtr <- Call.cint sqre
      nPtr <- Call.cint n
      ncvtPtr <- Call.cint ncvt
      nruPtr <- Call.cint nru
      nccPtr <- Call.cint ncc
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasdq uploPtr sqrePtr nPtr ncvtPtr nruPtr nccPtr dPtr ePtr vtPtr ldvtPtr uPtr lduPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasdt.f>
lasdt ::
   Int {- ^ n -} ->
   Int {- ^ msub -} ->
   IO (Int, Int, CArray Int CInt, CArray Int CInt, CArray Int CInt)
lasdt n msub = do
   inode <- Call.newArray1 n
   ndiml <- Call.newArray1 n
   ndimr <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      lvlPtr <- Call.alloca
      ndPtr <- Call.alloca
      inodePtr <- Call.ioarray inode
      ndimlPtr <- Call.ioarray ndiml
      ndimrPtr <- Call.ioarray ndimr
      msubPtr <- Call.cint msub
      liftIO $ FFI.lasdt nPtr lvlPtr ndPtr inodePtr ndimlPtr ndimrPtr msubPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek lvlPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray inode
         <*> Call.freezeArray ndiml
         <*> Call.freezeArray ndimr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaset.f>
laset ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   Double {- ^ beta -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) Double)
laset uplo m n alpha beta lda = do
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      betaPtr <- Call.double beta
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.laset uploPtr mPtr nPtr alphaPtr betaPtr aPtr ldaPtr
      liftIO $ Call.freezeArray a

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasq1.f>
lasq1 ::
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IO (Int)
lasq1 d e = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "lasq1: n == eDim0" (n == eDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasq1 nPtr dPtr ePtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasq2.f>
lasq2 ::
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ z -} ->
   IO (Int)
lasq2 n z = do
   zDim0 <- Call.sizes1 <$> getBounds z
   Call.assert "lasq2: 4*n == zDim0" (4*n == zDim0)
   evalContT $ do
      nPtr <- Call.cint n
      zPtr <- Call.ioarray z
      infoPtr <- Call.alloca
      liftIO $ FFI.lasq2 nPtr zPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasq4.f>
lasq4 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   CArray Int Double {- ^ z -} ->
   Int {- ^ pp -} ->
   Int {- ^ n0in -} ->
   Double {- ^ dmin -} ->
   Double {- ^ dmin1 -} ->
   Double {- ^ dmin2 -} ->
   Double {- ^ dn -} ->
   Double {- ^ dn1 -} ->
   Double {- ^ dn2 -} ->
   Double {- ^ g -} ->
   IO (Double, Int, Double)
lasq4 i0 n0 z pp n0in dmin dmin1 dmin2 dn dn1 dn2 g = do
   let zDim0 = Call.sizes1 $ bounds z
   Call.assert "lasq4: 4*n0 == zDim0" (4*n0 == zDim0)
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      n0inPtr <- Call.cint n0in
      dminPtr <- Call.double dmin
      dmin1Ptr <- Call.double dmin1
      dmin2Ptr <- Call.double dmin2
      dnPtr <- Call.double dn
      dn1Ptr <- Call.double dn1
      dn2Ptr <- Call.double dn2
      tauPtr <- Call.alloca
      ttypePtr <- Call.alloca
      gPtr <- Call.double g
      liftIO $ FFI.lasq4 i0Ptr n0Ptr zPtr ppPtr n0inPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dn1Ptr dn2Ptr tauPtr ttypePtr gPtr
      liftIO $ pure (,,)
         <*> peek tauPtr
         <*> fmap fromIntegral (peek ttypePtr)
         <*> peek gPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasq5.f>
lasq5 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   CArray Int Double {- ^ z -} ->
   Int {- ^ pp -} ->
   Double {- ^ tau -} ->
   Double {- ^ sigma -} ->
   Bool {- ^ ieee -} ->
   Double {- ^ eps -} ->
   IO (Double, Double, Double, Double, Double, Double)
lasq5 i0 n0 z pp tau sigma ieee eps = do
   let zDim0 = Call.sizes1 $ bounds z
   Call.ignore "lasq5: 4*n == zDim0" zDim0
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      tauPtr <- Call.double tau
      sigmaPtr <- Call.double sigma
      dminPtr <- Call.alloca
      dmin1Ptr <- Call.alloca
      dmin2Ptr <- Call.alloca
      dnPtr <- Call.alloca
      dnm1Ptr <- Call.alloca
      dnm2Ptr <- Call.alloca
      ieeePtr <- Call.bool ieee
      epsPtr <- Call.double eps
      liftIO $ FFI.lasq5 i0Ptr n0Ptr zPtr ppPtr tauPtr sigmaPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dnm1Ptr dnm2Ptr ieeePtr epsPtr
      liftIO $ pure (,,,,,)
         <*> peek dminPtr
         <*> peek dmin1Ptr
         <*> peek dmin2Ptr
         <*> peek dnPtr
         <*> peek dnm1Ptr
         <*> peek dnm2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasq6.f>
lasq6 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   CArray Int Double {- ^ z -} ->
   Int {- ^ pp -} ->
   IO (Double, Double, Double, Double, Double, Double)
lasq6 i0 n0 z pp = do
   let zDim0 = Call.sizes1 $ bounds z
   Call.ignore "lasq6: 4*n == zDim0" zDim0
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      dminPtr <- Call.alloca
      dmin1Ptr <- Call.alloca
      dmin2Ptr <- Call.alloca
      dnPtr <- Call.alloca
      dnm1Ptr <- Call.alloca
      dnm2Ptr <- Call.alloca
      liftIO $ FFI.lasq6 i0Ptr n0Ptr zPtr ppPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dnm1Ptr dnm2Ptr
      liftIO $ pure (,,,,,)
         <*> peek dminPtr
         <*> peek dmin1Ptr
         <*> peek dmin2Ptr
         <*> peek dnPtr
         <*> peek dnm1Ptr
         <*> peek dnm2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasr.f>
lasr ::
   Char {- ^ side -} ->
   Char {- ^ pivot -} ->
   Char {- ^ direct -} ->
   Int {- ^ m -} ->
   CArray Int Double {- ^ c -} ->
   CArray Int Double {- ^ s -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO ()
lasr side pivot direct m c s a = do
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let _cSize = cDim0
   let _sSize = sDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      sidePtr <- Call.char side
      pivotPtr <- Call.char pivot
      directPtr <- Call.char direct
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      cPtr <- Call.array c
      sPtr <- Call.array s
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.lasr sidePtr pivotPtr directPtr mPtr nPtr cPtr sPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasrt.f>
lasrt ::
   Char {- ^ id_ -} ->
   IOCArray Int Double {- ^ d -} ->
   IO (Int)
lasrt id_ d = do
   dDim0 <- Call.sizes1 <$> getBounds d
   let n = dDim0
   evalContT $ do
      id_Ptr <- Call.char id_
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      infoPtr <- Call.alloca
      liftIO $ FFI.lasrt id_Ptr nPtr dPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlassq.f>
lassq ::
   CArray Int Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ scale -} ->
   Double {- ^ sumsq -} ->
   IO (Double, Double)
lassq x incx scale sumsq = do
   let xDim0 = Call.sizes1 $ bounds x
   let n = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      scalePtr <- Call.double scale
      sumsqPtr <- Call.double sumsq
      liftIO $ FFI.lassq nPtr xPtr incxPtr scalePtr sumsqPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> peek sumsqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasv2.f>
lasv2 ::
   Double {- ^ f -} ->
   Double {- ^ g -} ->
   Double {- ^ h -} ->
   IO (Double, Double, Double, Double, Double, Double)
lasv2 f g h = do
   evalContT $ do
      fPtr <- Call.double f
      gPtr <- Call.double g
      hPtr <- Call.double h
      ssminPtr <- Call.alloca
      ssmaxPtr <- Call.alloca
      snrPtr <- Call.alloca
      csrPtr <- Call.alloca
      snlPtr <- Call.alloca
      cslPtr <- Call.alloca
      liftIO $ FFI.lasv2 fPtr gPtr hPtr ssminPtr ssmaxPtr snrPtr csrPtr snlPtr cslPtr
      liftIO $ pure (,,,,,)
         <*> peek ssminPtr
         <*> peek ssmaxPtr
         <*> peek snrPtr
         <*> peek csrPtr
         <*> peek snlPtr
         <*> peek cslPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaswp.f>
laswp ::
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ k1 -} ->
   Int {- ^ k2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ incx -} ->
   IO ()
laswp a k1 k2 ipiv incx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "laswp: k1+(k2-k1)*abs(incx) == ipivDim0" (k1+(k2-k1)*abs(incx) == ipivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      k1Ptr <- Call.cint k1
      k2Ptr <- Call.cint k2
      ipivPtr <- Call.array ipiv
      incxPtr <- Call.cint incx
      liftIO $ FFI.laswp nPtr aPtr ldaPtr k1Ptr k2Ptr ipivPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasy2.f>
lasy2 ::
   Bool {- ^ ltranl -} ->
   Bool {- ^ ltranr -} ->
   Int {- ^ isgn -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   CArray (Int,Int) Double {- ^ tl -} ->
   CArray (Int,Int) Double {- ^ tr -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Double, CArray (Int,Int) Double, Double, Int)
lasy2 ltranl ltranr isgn n1 n2 tl tr b ldx = do
   let (tlDim0,tlDim1) = Call.sizes2 $ bounds tl
   let (trDim0,trDim1) = Call.sizes2 $ bounds tr
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let ldtl = tlDim1
   let ldtr = trDim1
   let ldb = bDim1
   Call.assert "lasy2: 2 == tlDim0" (2 == tlDim0)
   Call.assert "lasy2: 2 == trDim0" (2 == trDim0)
   Call.assert "lasy2: 2 == bDim0" (2 == bDim0)
   x <- Call.newArray2 2 ldx
   evalContT $ do
      ltranlPtr <- Call.bool ltranl
      ltranrPtr <- Call.bool ltranr
      isgnPtr <- Call.cint isgn
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      tlPtr <- Call.array tl
      ldtlPtr <- Call.cint ldtl
      trPtr <- Call.array tr
      ldtrPtr <- Call.cint ldtr
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      scalePtr <- Call.alloca
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      xnormPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.lasy2 ltranlPtr ltranrPtr isgnPtr n1Ptr n2Ptr tlPtr ldtlPtr trPtr ldtrPtr bPtr ldbPtr scalePtr xPtr ldxPtr xnormPtr infoPtr
      liftIO $ pure (,,,)
         <*> peek scalePtr
         <*> Call.freezeArray x
         <*> peek xnormPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasyf.f>
lasyf ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (Int, CArray Int CInt, CArray (Int,Int) Double, Int)
lasyf uplo nb a ldw = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      infoPtr <- Call.alloca
      liftIO $ FFI.lasyf uploPtr nPtr nbPtr kbPtr aPtr ldaPtr ipivPtr wPtr ldwPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlat2s.f>
lat2s ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldsa -} ->
   IO (CArray (Int,Int) Float, Int)
lat2s uplo a ldsa = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   sa <- Call.newArray2 n ldsa
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      saPtr <- Call.ioarray sa
      ldsaPtr <- Call.cint ldsa
      infoPtr <- Call.alloca
      liftIO $ FFI.lat2s uploPtr nPtr aPtr ldaPtr saPtr ldsaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sa
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatbs.f>
latbs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IOCArray Int Double {- ^ x -} ->
   IOCArray Int Double {- ^ cnorm -} ->
   IO (Double, Int)
latbs uplo trans diag normin kd ab x cnorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = abDim0
   let ldab = abDim1
   Call.assert "latbs: n == xDim0" (n == xDim0)
   Call.assert "latbs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latbs uploPtr transPtr diagPtr norminPtr nPtr kdPtr abPtr ldabPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatdf.f>
latdf ::
   Int {- ^ ijob -} ->
   CArray (Int,Int) Double {- ^ z -} ->
   IOCArray Int Double {- ^ rhs -} ->
   Double {- ^ rdsum -} ->
   Double {- ^ rdscal -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray Int CInt {- ^ jpiv -} ->
   IO (Double, Double)
latdf ijob z rhs rdsum rdscal ipiv jpiv = do
   let (zDim0,zDim1) = Call.sizes2 $ bounds z
   rhsDim0 <- Call.sizes1 <$> getBounds rhs
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let jpivDim0 = Call.sizes1 $ bounds jpiv
   let n = zDim0
   let ldz = zDim1
   Call.assert "latdf: n == rhsDim0" (n == rhsDim0)
   Call.assert "latdf: n == ipivDim0" (n == ipivDim0)
   Call.assert "latdf: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      ijobPtr <- Call.cint ijob
      nPtr <- Call.cint n
      zPtr <- Call.array z
      ldzPtr <- Call.cint ldz
      rhsPtr <- Call.ioarray rhs
      rdsumPtr <- Call.double rdsum
      rdscalPtr <- Call.double rdscal
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      liftIO $ FFI.latdf ijobPtr nPtr zPtr ldzPtr rhsPtr rdsumPtr rdscalPtr ipivPtr jpivPtr
      liftIO $ pure (,)
         <*> peek rdsumPtr
         <*> peek rdscalPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatps.f>
latps ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   CArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ x -} ->
   IOCArray Int Double {- ^ cnorm -} ->
   IO (Double, Int)
latps uplo trans diag normin ap x cnorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = xDim0
   Call.assert "latps: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "latps: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latps uploPtr transPtr diagPtr norminPtr nPtr apPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatrd.f>
latrd ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (CArray Int Double, CArray Int Double, CArray (Int,Int) Double)
latrd uplo nb a ldw = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      liftIO $ FFI.latrd uploPtr nPtr nbPtr aPtr ldaPtr ePtr tauPtr wPtr ldwPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> Call.freezeArray w

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatrs.f>
latrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IOCArray Int Double {- ^ x -} ->
   IOCArray Int Double {- ^ cnorm -} ->
   IO (Double, Int)
latrs uplo trans diag normin a x cnorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = aDim0
   let lda = aDim1
   Call.assert "latrs: n == xDim0" (n == xDim0)
   Call.assert "latrs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latrs uploPtr transPtr diagPtr norminPtr nPtr aPtr ldaPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlatrz.f>
latrz ::
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double)
latrz m l a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      liftIO $ FFI.latrz mPtr nPtr lPtr aPtr ldaPtr tauPtr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlauu2.f>
lauu2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
lauu2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauu2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlauum.f>
lauum ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
lauum uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauum uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorbdb.f>
orbdb ::
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) Double {- ^ x11 -} ->
   IOCArray (Int,Int) Double {- ^ x12 -} ->
   IOCArray (Int,Int) Double {- ^ x21 -} ->
   IOCArray (Int,Int) Double {- ^ x22 -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, CArray Int Double, Int)
orbdb trans signs m p x11 x12 x21 x22 lwork = do
   (x11Dim0,x11Dim1) <- Call.sizes2 <$> getBounds x11
   (x12Dim0,x12Dim1) <- Call.sizes2 <$> getBounds x12
   (x21Dim0,x21Dim1) <- Call.sizes2 <$> getBounds x21
   (x22Dim0,x22Dim1) <- Call.sizes2 <$> getBounds x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "orbdb: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "orbdb: q == x21Dim0" (q == x21Dim0)
   Call.assert "orbdb: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 q
   phi <- Call.newArray1 (q-1)
   taup1 <- Call.newArray1 p
   taup2 <- Call.newArray1 (m-p)
   tauq1 <- Call.newArray1 q
   tauq2 <- Call.newArray1 (m-q)
   work <- Call.newArray1 lwork
   evalContT $ do
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      taup1Ptr <- Call.ioarray taup1
      taup2Ptr <- Call.ioarray taup2
      tauq1Ptr <- Call.ioarray tauq1
      tauq2Ptr <- Call.ioarray tauq2
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orbdb transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr phiPtr taup1Ptr taup2Ptr tauq1Ptr tauq2Ptr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray phi
         <*> Call.freezeArray taup1
         <*> Call.freezeArray taup2
         <*> Call.freezeArray tauq1
         <*> Call.freezeArray tauq2
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorcsd.f>
orcsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) Double {- ^ x11 -} ->
   IOCArray (Int,Int) Double {- ^ x12 -} ->
   IOCArray (Int,Int) Double {- ^ x21 -} ->
   IOCArray (Int,Int) Double {- ^ x22 -} ->
   Int {- ^ r -} ->
   Int {- ^ ldu1 -} ->
   Int {- ^ ldu2 -} ->
   Int {- ^ ldv1t -} ->
   Int {- ^ ldv2t -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, CArray (Int,Int) Double, Int)
orcsd jobu1 jobu2 jobv1t jobv2t trans signs m p x11 x12 x21 x22 r ldu1 ldu2 ldv1t ldv2t lwork = do
   (x11Dim0,x11Dim1) <- Call.sizes2 <$> getBounds x11
   (x12Dim0,x12Dim1) <- Call.sizes2 <$> getBounds x12
   (x21Dim0,x21Dim1) <- Call.sizes2 <$> getBounds x21
   (x22Dim0,x22Dim1) <- Call.sizes2 <$> getBounds x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "orcsd: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "orcsd: q == x21Dim0" (q == x21Dim0)
   Call.assert "orcsd: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 r
   u1 <- Call.newArray2 p ldu1
   u2 <- Call.newArray2 (m-p) ldu2
   v1t <- Call.newArray2 q ldv1t
   v2t <- Call.newArray2 (m-q) ldv2t
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (m-minimum[p,m-p,q,m-q])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orcsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray u1
         <*> Call.freezeArray u2
         <*> Call.freezeArray v1t
         <*> Call.freezeArray v2t
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbcon.f>
pbcon ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
pbcon uplo kd ab anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbcon uploPtr nPtr kdPtr abPtr ldabPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbequ.f>
pbequ ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IO (CArray Int Double, Double, Double, Int)
pbequ uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.pbequ uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbrfs.f>
pbrfs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   CArray (Int,Int) Double {- ^ afb -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
pbrfs uplo kd ab afb b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (afbDim0,afbDim1) = Call.sizes2 $ bounds afb
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "pbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbrfs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbstf.f>
pbstf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IO (Int)
pbstf uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbstf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbsv.f>
pbsv ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
pbsv uplo kd ab b = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsv uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbsvx.f>
pbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ afb -} ->
   Char {- ^ equed -} ->
   IOCArray Int Double {- ^ s -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
pbsvx fact uplo kd ab afb equed s b ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (afbDim0,afbDim1) <- Call.sizes2 <$> getBounds afb
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "pbsvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsvx factPtr uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbtf2.f>
pbtf2 ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IO (Int)
pbtf2 uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtf2 uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbtrf.f>
pbtrf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) Double {- ^ ab -} ->
   IO (Int)
pbtrf uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpbtrs.f>
pbtrs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
pbtrs uplo kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpftrf.f>
pftrf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ a -} ->
   IO (Int)
pftrf transr uplo n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.assert "pftrf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrf transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpftri.f>
pftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ a -} ->
   IO (Int)
pftri transr uplo n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.assert "pftri: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftri transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpftrs.f>
pftrs ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
pftrs transr uplo n a b = do
   let aDim0 = Call.sizes1 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pftrs: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrs transrPtr uploPtr nPtr nrhsPtr aPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpocon.f>
pocon ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
pocon uplo a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pocon uploPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpoequ.f>
poequ ::
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Double, Double, Int)
poequ a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequ nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpoequb.f>
poequb ::
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Double, Double, Int)
poequb a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequb nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dporfs.f>
porfs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ af -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
porfs uplo a af b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "porfs: n == afDim0" (n == afDim0)
   Call.assert "porfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.porfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dposv.f>
posv ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
posv uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.posv uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dposvx.f>
posvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ af -} ->
   Char {- ^ equed -} ->
   IOCArray Int Double {- ^ s -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
posvx fact uplo a af equed s b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "posvx: n == afDim0" (n == afDim0)
   Call.assert "posvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.posvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpotf2.f>
potf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
potf2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potf2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpotrf.f>
potrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
potrf uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potrf uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpotri.f>
potri ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
potri uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potri uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpotrs.f>
potrs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
potrs uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.potrs uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dppcon.f>
ppcon ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
ppcon uplo n ap anorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "ppcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppcon uploPtr nPtr apPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dppequ.f>
ppequ ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   IO (CArray Int Double, Double, Double, Int)
ppequ uplo n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "ppequ: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.ppequ uploPtr nPtr apPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpprfs.f>
pprfs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ afp -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
pprfs uplo n ap afp b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let afpDim0 = Call.sizes1 $ bounds afp
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "pprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "pprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pprfs uploPtr nPtr nrhsPtr apPtr afpPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dppsv.f>
ppsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
ppsv uplo n ap b = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsv uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dppsvx.f>
ppsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ afp -} ->
   Char {- ^ equed -} ->
   IOCArray Int Double {- ^ s -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
ppsvx fact uplo ap afp equed s b ldx = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   afpDim0 <- Call.sizes1 <$> getBounds afp
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = sDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "ppsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      afpPtr <- Call.ioarray afp
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpptrf.f>
pptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IO (Int)
pptrf uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "pptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrf uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpptri.f>
pptri ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IO (Int)
pptri uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "pptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptri uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpptrs.f>
pptrs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
pptrs uplo n ap b = do
   let apDim0 = Call.sizes1 $ bounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrs uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpstf2.f>
pstf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ tol -} ->
   IO (CArray Int CInt, Int, Int)
pstf2 uplo a tol = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.double tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstf2 uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpstrf.f>
pstrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Double {- ^ tol -} ->
   IO (CArray Int CInt, Int, Int)
pstrf uplo a tol = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.double tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstrf uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dptcon.f>
ptcon ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
ptcon d e anorm = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "ptcon: n-1 == eDim0" (n-1 == eDim0)
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptcon nPtr dPtr ePtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpteqr.f>
pteqr ::
   Char {- ^ compz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   IO (Int)
pteqr compz d e z = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "pteqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "pteqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pteqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dptrfs.f>
ptrfs ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   CArray Int Double {- ^ df -} ->
   CArray Int Double {- ^ ef -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
ptrfs d e df ef b x = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let dfDim0 = Call.sizes1 $ bounds df
   let efDim0 = Call.sizes1 $ bounds ef
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "ptrfs: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptrfs: n == dfDim0" (n == dfDim0)
   Call.assert "ptrfs: n-1 == efDim0" (n-1 == efDim0)
   Call.assert "ptrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.array df
      efPtr <- Call.array ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptrfs nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dptsv.f>
ptsv ::
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
ptsv d e b = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsv: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsv nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dptsvx.f>
ptsvx ::
   Char {- ^ fact -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IOCArray Int Double {- ^ df -} ->
   IOCArray Int Double {- ^ ef -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
ptsvx fact d e df ef b ldx = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   dfDim0 <- Call.sizes1 <$> getBounds df
   efDim0 <- Call.sizes1 <$> getBounds ef
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsvx: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptsvx: n == dfDim0" (n == dfDim0)
   Call.assert "ptsvx: n-1 == efDim0" (n-1 == efDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   evalContT $ do
      factPtr <- Call.char fact
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.ioarray df
      efPtr <- Call.ioarray ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsvx factPtr nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpttrf.f>
pttrf ::
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IO (Int)
pttrf d e = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "pttrf: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrf nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dpttrs.f>
pttrs ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
pttrs d e b = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pttrs: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrs nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dptts2.f>
ptts2 ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO ()
ptts2 d e b = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptts2: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.ptts2 nPtr nrhsPtr dPtr ePtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/drscl.f>
rscl ::
   Int {- ^ n -} ->
   Double {- ^ sa -} ->
   IOCArray Int Double {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO ()
rscl n sa sx incx = do
   sxDim0 <- Call.sizes1 <$> getBounds sx
   let _sxSize = sxDim0
   evalContT $ do
      nPtr <- Call.cint n
      saPtr <- Call.double sa
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.rscl nPtr saPtr sxPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsgesv.f>
sgesv ::
   Int {- ^ n -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray Int CInt, CArray (Int,Int) Double, Int, Int)
sgesv n a b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let _aSize = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   x <- Call.newArray2 nrhs ldx
   work <- Call.newArray2 nrhs n
   swork <- Call.newArray1 (n*(n+nrhs))
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      workPtr <- Call.ioarray work
      sworkPtr <- Call.ioarray swork
      iterPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.sgesv nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr xPtr ldxPtr workPtr sworkPtr iterPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek iterPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspcon.f>
spcon ::
   Char {- ^ uplo -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
spcon uplo ap ipiv anorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "spcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spcon uploPtr nPtr apPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsposv.f>
sposv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Int, Int)
sposv uplo n a b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let _aSize = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   x <- Call.newArray2 nrhs ldx
   work <- Call.newArray2 nrhs n
   swork <- Call.newArray1 (n*(n+nrhs))
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      workPtr <- Call.ioarray work
      sworkPtr <- Call.ioarray swork
      iterPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.sposv uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr xPtr ldxPtr workPtr sworkPtr iterPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek iterPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsprfs.f>
sprfs ::
   Char {- ^ uplo -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ afp -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
sprfs uplo ap afp ipiv b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let afpDim0 = Call.sizes1 $ bounds afp
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "sprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "sprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "sprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sprfs uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspsv.f>
spsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (CArray Int CInt, Int)
spsv uplo n ap b = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.spsv uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dspsvx.f>
spsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray Int Double {- ^ ap -} ->
   IOCArray Int Double {- ^ afp -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
spsvx fact uplo ap afp ipiv b ldx = do
   let apDim0 = Call.sizes1 $ bounds ap
   afpDim0 <- Call.sizes1 <$> getBounds afp
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.ioarray afp
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsptrf.f>
sptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IO (CArray Int CInt, Int)
sptrf uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "sptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrf uploPtr nPtr apPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsptri.f>
sptri ::
   Char {- ^ uplo -} ->
   IOCArray Int Double {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
sptri uplo ap ipiv = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "sptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sptri uploPtr nPtr apPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsptrs.f>
sptrs ::
   Char {- ^ uplo -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
sptrs uplo ap ipiv b = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrs uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstebz.f>
stebz ::
   Char {- ^ range -} ->
   Char {- ^ order -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   IO (Int, Int, CArray Int Double, CArray Int CInt, CArray Int CInt, Int)
stebz range order vl vu il iu abstol d e = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "stebz: n-1 == eDim0" (n-1 == eDim0)
   w <- Call.newArray1 n
   iblock <- Call.newArray1 n
   isplit <- Call.newArray1 n
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      rangePtr <- Call.char range
      orderPtr <- Call.char order
      nPtr <- Call.cint n
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      dPtr <- Call.array d
      ePtr <- Call.array e
      mPtr <- Call.alloca
      nsplitPtr <- Call.alloca
      wPtr <- Call.ioarray w
      iblockPtr <- Call.ioarray iblock
      isplitPtr <- Call.ioarray isplit
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stebz rangePtr orderPtr nPtr vlPtr vuPtr ilPtr iuPtr abstolPtr dPtr ePtr mPtr nsplitPtr wPtr iblockPtr isplitPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray iblock
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstedc.f>
stedc ::
   Char {- ^ compz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int)
stedc compz d e z lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "stedc: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stedc: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stedc compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstegr.f>
stegr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
stegr jobz range d e vl vu il iu abstol m ldz lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stegr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stegr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstein.f>
stein ::
   CArray Int Double {- ^ d -} ->
   CArray Int Double {- ^ e -} ->
   Int {- ^ m -} ->
   CArray Int Double {- ^ w -} ->
   CArray Int CInt {- ^ iblock -} ->
   CArray Int CInt {- ^ isplit -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) Double, CArray Int CInt, Int)
stein d e m w iblock isplit ldz = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let wDim0 = Call.sizes1 $ bounds w
   let iblockDim0 = Call.sizes1 $ bounds iblock
   let isplitDim0 = Call.sizes1 $ bounds isplit
   let n = dDim0
   Call.assert "stein: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stein: n == wDim0" (n == wDim0)
   Call.assert "stein: n == iblockDim0" (n == iblockDim0)
   Call.assert "stein: n == isplitDim0" (n == isplitDim0)
   z <- Call.newArray2 m ldz
   work <- Call.newArray1 (5*n)
   iwork <- Call.newArray1 n
   ifail <- Call.newArray1 m
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      mPtr <- Call.cint m
      wPtr <- Call.array w
      iblockPtr <- Call.array iblock
      isplitPtr <- Call.array isplit
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.stein nPtr dPtr ePtr mPtr wPtr iblockPtr isplitPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstemr.f>
stemr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ nzc -} ->
   Bool {- ^ tryrac -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Bool, Int)
stemr jobz range d e vl vu il iu m ldz nzc tryrac lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stemr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nzcPtr <- Call.cint nzc
      isuppzPtr <- Call.ioarray isuppz
      tryracPtr <- Call.bool tryrac
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stemr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr mPtr wPtr zPtr ldzPtr nzcPtr isuppzPtr tryracPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> peek tryracPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsteqr.f>
steqr ::
   Char {- ^ compz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   IO (Int)
steqr compz d e z = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "steqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "steqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,2*n-2])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.steqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsterf.f>
sterf ::
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   IO (Int)
sterf d e = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "sterf: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.sterf nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstev.f>
stev ::
   Char {- ^ jobz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) Double, Int)
stev jobz d e ldz = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stev: n-1 == eDim0" (n-1 == eDim0)
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,2*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.stev jobzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstevd.f>
stevd ::
   Char {- ^ jobz -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Int {- ^ ldz -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray (Int,Int) Double, Int)
stevd jobz d e ldz workSize lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stevd: n-1 == eDim0" (n-1 == eDim0)
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stevd jobzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstevr.f>
stevr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
stevr jobz range d e vl vu il iu abstol m ldz lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stevr: maximum[1,n-1] == eDim0" (maximum[1,n-1] == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stevr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dstevx.f>
stevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Double {- ^ d -} ->
   IOCArray Int Double {- ^ e -} ->
   Double {- ^ vl -} ->
   Double {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Double {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, CArray Int Double, CArray (Int,Int) Double, CArray Int CInt, Int)
stevx jobz range d e vl vu il iu abstol m ldz = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stevx: maximum[1,n-1] == eDim0" (maximum[1,n-1] == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (5*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.double vl
      vuPtr <- Call.double vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.double abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.stevx jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsycon.f>
sycon ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Double {- ^ anorm -} ->
   IO (Double, Int)
sycon uplo a ipiv anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sycon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.double anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sycon uploPtr nPtr aPtr ldaPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyconv.f>
syconv ::
   Char {- ^ uplo -} ->
   Char {- ^ way -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (CArray Int Double, Int)
syconv uplo way a ipiv = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "syconv: n == ipivDim0" (n == ipivDim0)
   e <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      wayPtr <- Call.char way
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.syconv uploPtr wayPtr nPtr aPtr ldaPtr ipivPtr ePtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyequb.f>
syequb ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Double, Double, Int)
syequb uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.syequb uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyrfs.f>
syrfs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ af -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
syrfs uplo a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "syrfs: n == afDim0" (n == afDim0)
   Call.assert "syrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "syrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syrfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsysv.f>
sysv ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
sysv uplo a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysv uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsysvx.f>
sysvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ af -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   Int {- ^ ldx -} ->
   Int {- ^ lwork -} ->
   IO (CArray (Int,Int) Double, Double, CArray Int Double, CArray Int Double, Int)
sysvx fact uplo a af ipiv b ldx lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sysvx: n == afDim0" (n == afDim0)
   Call.assert "sysvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsyswapr.f>
syswapr ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ i1 -} ->
   Int {- ^ i2 -} ->
   IO ()
syswapr uplo a i1 i2 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      i1Ptr <- Call.cint i1
      i2Ptr <- Call.cint i2
      liftIO $ FFI.syswapr uploPtr nPtr aPtr ldaPtr i1Ptr i2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytd2.f>
sytd2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Int)
sytd2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.sytd2 uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytf2.f>
sytf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int CInt, Int)
sytf2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sytf2 uploPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytrd.f>
sytrd ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Int)
sytrd uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrd uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytrf.f>
sytrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
sytrf uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrf uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytri.f>
sytri ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
sytri uplo a ipiv = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri uploPtr nPtr aPtr ldaPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytri2.f>
sytri2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   Int {- ^ lwork -} ->
   IO (Int)
sytri2 uplo a ipiv nb lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2 uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytri2x.f>
sytri2x ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   IO (Int)
sytri2x uplo a ipiv nb = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2x: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray2 (nb+3) (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      nbPtr <- Call.cint nb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2x uploPtr nPtr aPtr ldaPtr ipivPtr workPtr nbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytrs.f>
sytrs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
sytrs uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dsytrs2.f>
sytrs2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
sytrs2 uplo a ipiv b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs2 uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtbcon.f>
tbcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IO (Double, Int)
tbcon norm uplo diag kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbcon normPtr uploPtr diagPtr nPtr kdPtr abPtr ldabPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtbrfs.f>
tbrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   CArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
tbrfs uplo trans diag kd ab b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbrfs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtbtrs.f>
tbtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) Double {- ^ ab -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
tbtrs uplo trans diag kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tbtrs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtfsm.f>
tfsm ::
   Char {- ^ transr -} ->
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   CArray Int Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO ()
tfsm transr side uplo trans diag m alpha a b = do
   let aDim0 = Call.sizes1 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let _nt = aDim0
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      transrPtr <- Call.char transr
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.tfsm transrPtr sidePtr uploPtr transPtr diagPtr mPtr nPtr alphaPtr aPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtftri.f>
tftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ a -} ->
   IO (Int)
tftri transr uplo diag n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.ignore "tftri: 0:nt-1 == aDim0" aDim0
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.tftri transrPtr uploPtr diagPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtfttp.f>
tfttp ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ arf -} ->
   IO (CArray Int Double, Int)
tfttp transr uplo n arf = do
   let arfDim0 = Call.sizes1 $ bounds arf
   Call.assert "tfttp: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttp transrPtr uploPtr nPtr arfPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtfttr.f>
tfttr ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ arf -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) Double, Int)
tfttr transr uplo n arf lda = do
   let arfDim0 = Call.sizes1 $ bounds arf
   Call.assert "tfttr: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttr transrPtr uploPtr nPtr arfPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgevc.f>
tgevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) Double {- ^ s -} ->
   CArray (Int,Int) Double {- ^ p -} ->
   IOCArray (Int,Int) Double {- ^ vl -} ->
   IOCArray (Int,Int) Double {- ^ vr -} ->
   IO (Int, Int)
tgevc side howmny select s p vl vr = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (sDim0,sDim1) = Call.sizes2 $ bounds s
   let (pDim0,pDim1) = Call.sizes2 $ bounds p
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let lds = sDim1
   let ldp = pDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgevc: n == sDim0" (n == sDim0)
   Call.assert "tgevc: n == pDim0" (n == pDim0)
   Call.assert "tgevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (6*n)
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      sPtr <- Call.array s
      ldsPtr <- Call.cint lds
      pPtr <- Call.array p
      ldpPtr <- Call.cint ldp
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.tgevc sidePtr howmnyPtr selectPtr nPtr sPtr ldsPtr pPtr ldpPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgex2.f>
tgex2 ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ j1 -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   Int {- ^ lwork -} ->
   IO (Int)
tgex2 wantq wantz a b q z j1 n1 n2 lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let _aSize = aDim0
   let lda = aDim1
   let _bSize = bDim0
   let ldb = bDim1
   let n = qDim0
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgex2: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      j1Ptr <- Call.cint j1
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgex2 wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr j1Ptr n1Ptr n2Ptr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgexc.f>
tgexc ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, Int)
tgexc wantq wantz a b q z ifst ilst lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgexc: n == bDim0" (n == bDim0)
   Call.assert "tgexc: n == qDim0" (n == qDim0)
   Call.assert "tgexc: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgexc wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr ifstPtr ilstPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek ifstPtr)
         <*> fmap fromIntegral (peek ilstPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgsen.f>
tgsen ::
   Int {- ^ ijob -} ->
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   CArray Int Bool {- ^ select -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IOCArray (Int,Int) Double {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray Int Double, CArray Int Double, Int, Double, Double, CArray Int Double, Int)
tgsen ijob wantq wantz select a b q z lwork liwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgsen: n == aDim0" (n == aDim0)
   Call.assert "tgsen: n == bDim0" (n == bDim0)
   Call.assert "tgsen: n == qDim0" (n == qDim0)
   Call.assert "tgsen: n == zDim0" (n == zDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   dif <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      ijobPtr <- Call.cint ijob
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      mPtr <- Call.alloca
      plPtr <- Call.alloca
      prPtr <- Call.alloca
      difPtr <- Call.ioarray dif
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsen ijobPtr wantqPtr wantzPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr qPtr ldqPtr zPtr ldzPtr mPtr plPtr prPtr difPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek mPtr)
         <*> peek plPtr
         <*> peek prPtr
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgsja.f>
tgsja ::
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Char {- ^ jobq -} ->
   Int {- ^ k -} ->
   Int {- ^ l -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   Double {- ^ tola -} ->
   Double {- ^ tolb -} ->
   IOCArray (Int,Int) Double {- ^ u -} ->
   IOCArray (Int,Int) Double {- ^ v -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   IO (CArray Int Double, CArray Int Double, Int, Int)
tgsja jobu jobv jobq k l a b tola tolb u v q = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = uDim0
   let ldu = uDim1
   let p = vDim0
   let ldv = vDim1
   let ldq = qDim1
   Call.assert "tgsja: n == bDim0" (n == bDim0)
   Call.assert "tgsja: n == qDim0" (n == qDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      jobqPtr <- Call.char jobq
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      tolaPtr <- Call.double tola
      tolbPtr <- Call.double tolb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      ncyclePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsja jobuPtr jobvPtr jobqPtr mPtr pPtr nPtr kPtr lPtr aPtr ldaPtr bPtr ldbPtr tolaPtr tolbPtr alphaPtr betaPtr uPtr lduPtr vPtr ldvPtr qPtr ldqPtr workPtr ncyclePtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek ncyclePtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgsna.f>
tgsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   CArray (Int,Int) Double {- ^ vl -} ->
   CArray (Int,Int) Double {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, CArray Int Double, Int, Int)
tgsna job howmny select a b vl vr mm lwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (vlDim0,vlDim1) = Call.sizes2 $ bounds vl
   let (vrDim0,vrDim1) = Call.sizes2 $ bounds vr
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgsna: n == aDim0" (n == aDim0)
   Call.assert "tgsna: n == bDim0" (n == bDim0)
   Call.assert "tgsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   dif <- Call.newArray1 mm
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (n+6)
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      difPtr <- Call.ioarray dif
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsna jobPtr howmnyPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr difPtr mmPtr mPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgsy2.f>
tgsy2 ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   CArray (Int,Int) Double {- ^ d -} ->
   CArray (Int,Int) Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ f -} ->
   Double {- ^ rdsum -} ->
   Double {- ^ rdscal -} ->
   IO (Double, Double, Double, Int, Int)
tgsy2 trans ijob a b c d e f rdsum rdscal = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let (dDim0,dDim1) = Call.sizes2 $ bounds d
   let (eDim0,eDim1) = Call.sizes2 $ bounds e
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsy2: n == cDim0" (n == cDim0)
   Call.assert "tgsy2: m == dDim0" (m == dDim0)
   Call.assert "tgsy2: n == eDim0" (n == eDim0)
   Call.assert "tgsy2: n == fDim0" (n == fDim0)
   iwork <- Call.newArray1 (m+n+2)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      rdsumPtr <- Call.double rdsum
      rdscalPtr <- Call.double rdscal
      iworkPtr <- Call.ioarray iwork
      pqPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsy2 transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr rdsumPtr rdscalPtr iworkPtr pqPtr infoPtr
      liftIO $ pure (,,,,)
         <*> peek scalePtr
         <*> peek rdsumPtr
         <*> peek rdscalPtr
         <*> fmap fromIntegral (peek pqPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtgsyl.f>
tgsyl ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   CArray (Int,Int) Double {- ^ d -} ->
   CArray (Int,Int) Double {- ^ e -} ->
   IOCArray (Int,Int) Double {- ^ f -} ->
   Int {- ^ lwork -} ->
   IO (Double, Double, Int)
tgsyl trans ijob a b c d e f lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let (dDim0,dDim1) = Call.sizes2 $ bounds d
   let (eDim0,eDim1) = Call.sizes2 $ bounds e
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsyl: n == cDim0" (n == cDim0)
   Call.assert "tgsyl: m == dDim0" (m == dDim0)
   Call.assert "tgsyl: n == eDim0" (n == eDim0)
   Call.assert "tgsyl: n == fDim0" (n == fDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (m+n+6)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      difPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsyl transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr difPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> peek scalePtr
         <*> peek difPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtpcon.f>
tpcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   IO (Double, Int)
tpcon norm uplo diag n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tpcon normPtr uploPtr diagPtr nPtr apPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtprfs.f>
tprfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   CArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
tprfs uplo trans diag n ap b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "tprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tprfs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtptri.f>
tptri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOCArray Int Double {- ^ ap -} ->
   IO (Int)
tptri uplo diag n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "tptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tptri uploPtr diagPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtptrs.f>
tptrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
tptrs uplo trans diag n ap b = do
   let apDim0 = Call.sizes1 $ bounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "tptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tptrs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtpttf.f>
tpttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   IO (CArray Int Double, Int)
tpttf transr uplo n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpttf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   arf <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttf transrPtr uploPtr nPtr apPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtpttr.f>
tpttr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) Double, Int)
tpttr uplo n ap lda = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpttr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttr uploPtr nPtr apPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrcon.f>
trcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO (Double, Int)
trcon norm uplo diag a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trcon normPtr uploPtr diagPtr nPtr aPtr ldaPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrevc.f>
trevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   IOCArray Int Bool {- ^ select -} ->
   CArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ vl -} ->
   IOCArray (Int,Int) Double {- ^ vr -} ->
   IO (Int, Int)
trevc side howmny select t vl vr = do
   selectDim0 <- Call.sizes1 <$> getBounds select
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let ldt = tDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trevc: n == tDim0" (n == tDim0)
   Call.assert "trevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (3*n)
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.ioarray select
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.trevc sidePtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrexc.f>
trexc ::
   Char {- ^ compq -} ->
   IOCArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   IO (Int, Int, Int)
trexc compq t q ifst ilst = do
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = tDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trexc: n == qDim0" (n == qDim0)
   work <- Call.newArray1 n
   evalContT $ do
      compqPtr <- Call.char compq
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.trexc compqPtr nPtr tPtr ldtPtr qPtr ldqPtr ifstPtr ilstPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek ifstPtr)
         <*> fmap fromIntegral (peek ilstPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrrfs.f>
trrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   CArray (Int,Int) Double {- ^ x -} ->
   IO (CArray Int Double, CArray Int Double, Int)
trrfs uplo trans diag a b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "trrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trrfs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrsen.f>
trsen ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   CArray Int Bool {- ^ select -} ->
   IOCArray (Int,Int) Double {- ^ t -} ->
   IOCArray (Int,Int) Double {- ^ q -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Double, CArray Int Double, Int, Double, Double, Int)
trsen job compq select t q lwork liwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = selectDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trsen: n == tDim0" (n == tDim0)
   Call.assert "trsen: n == qDim0" (n == qDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      mPtr <- Call.alloca
      sPtr <- Call.alloca
      sepPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsen jobPtr compqPtr selectPtr nPtr tPtr ldtPtr qPtr ldqPtr wrPtr wiPtr mPtr sPtr sepPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek mPtr)
         <*> peek sPtr
         <*> peek sepPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrsna.f>
trsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) Double {- ^ t -} ->
   CArray (Int,Int) Double {- ^ vl -} ->
   CArray (Int,Int) Double {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ ldwork -} ->
   IO (CArray Int Double, CArray Int Double, Int, Int)
trsna job howmny select t vl vr mm ldwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   let (vlDim0,vlDim1) = Call.sizes2 $ bounds vl
   let (vrDim0,vrDim1) = Call.sizes2 $ bounds vr
   let n = selectDim0
   let ldt = tDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trsna: n == tDim0" (n == tDim0)
   Call.assert "trsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   sep <- Call.newArray1 mm
   work <- Call.newArray2 (n+6) ldwork
   iwork <- Call.newArray1 (2*(n-1))
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      sepPtr <- Call.ioarray sep
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsna jobPtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr sepPtr mmPtr mPtr workPtr ldworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray sep
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrsyl.f>
trsyl ::
   Char {- ^ trana -} ->
   Char {- ^ tranb -} ->
   Int {- ^ isgn -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray (Int,Int) Double {- ^ b -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   IO (Double, Int)
trsyl trana tranb isgn a b c = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   Call.assert "trsyl: n == cDim0" (n == cDim0)
   evalContT $ do
      tranaPtr <- Call.char trana
      tranbPtr <- Call.char tranb
      isgnPtr <- Call.cint isgn
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      scalePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.trsyl tranaPtr tranbPtr isgnPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr scalePtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrti2.f>
trti2 ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
trti2 uplo diag a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trti2 uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrtri.f>
trtri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   IO (Int)
trtri uplo diag a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trtri uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrtrs.f>
trtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IOCArray (Int,Int) Double {- ^ b -} ->
   IO (Int)
trtrs uplo trans diag a b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.trtrs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrttf.f>
trttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ nt -} ->
   IO (CArray Int Double, Int)
trttf transr uplo a nt = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   arf <- Call.newArray1 nt
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.trttf transrPtr uploPtr nPtr aPtr ldaPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtrttp.f>
trttp ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   IO (CArray Int Double, Int)
trttp uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.trttp uploPtr nPtr aPtr ldaPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dtzrzf.f>
tzrzf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Double, Int)
tzrzf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tzrzf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorg2l.f>
org2l ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IO (Int)
org2l m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.org2l mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorg2r.f>
org2r ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IO (Int)
org2r m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.org2r mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgbr.f>
orgbr ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgbr vect m k a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgbr vectPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorghr.f>
orghr ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orghr ilo ihi a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   Call.assert "orghr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orghr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgl2.f>
orgl2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IO (Int)
orgl2 m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orgl2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorglq.f>
orglq ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orglq m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orglq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgql.f>
orgql ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgql m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgql mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgqr.f>
orgqr ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgqr m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgqr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgr2.f>
orgr2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IO (Int)
orgr2 m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orgr2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgrq.f>
orgrq ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgrq m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgrq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorgtr.f>
orgtr ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgtr uplo a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   Call.assert "orgtr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgtr uploPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorm2l.f>
orm2l ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orm2l side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "orm2l: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orm2l sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorm2r.f>
orm2r ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orm2r side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "orm2r: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orm2r sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormbr.f>
ormbr ::
   Char {- ^ vect -} ->
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormbr vect side trans m k a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.ignore "ormbr: minimum[nq,k] == tauDim0" tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormbr vectPtr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormhr.f>
ormhr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormhr side trans m ilo ihi a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormhr sidePtr transPtr mPtr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorml2.f>
orml2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orml2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orml2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormlq.f>
ormlq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormlq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormlq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormql.f>
ormql ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormql side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "ormql: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormql sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormqr.f>
ormqr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormqr side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "ormqr: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormqr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormr2.f>
ormr2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
ormr2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ormr2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormr3.f>
ormr3 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
ormr3 side trans m l a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ormr3 sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormrq.f>
ormrq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormrq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormrq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormrz.f>
ormrz ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormrz side trans m l a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormrz sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormtr.f>
ormtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Double {- ^ a -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormtr side uplo trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormtr sidePtr uploPtr transPtr mPtr nPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dopgtr.f>
opgtr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ tau -} ->
   Int {- ^ ldq -} ->
   IO (CArray (Int,Int) Double, Int)
opgtr uplo n ap tau ldq = do
   let apDim0 = Call.sizes1 $ bounds ap
   let tauDim0 = Call.sizes1 $ bounds tau
   Call.assert "opgtr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "opgtr: n-1 == tauDim0" (n-1 == tauDim0)
   q <- Call.newArray2 n ldq
   work <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.opgtr uploPtr nPtr apPtr tauPtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dopmtr.f>
opmtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray Int Double {- ^ ap -} ->
   CArray Int Double {- ^ tau -} ->
   IOCArray (Int,Int) Double {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
opmtr side uplo trans m ap tau c workSize = do
   let apDim0 = Call.sizes1 $ bounds ap
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _apSize = apDim0
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.opmtr sidePtr uploPtr transPtr mPtr nPtr apPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)
