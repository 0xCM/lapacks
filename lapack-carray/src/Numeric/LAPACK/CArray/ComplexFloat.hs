-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.CArray.ComplexFloat where

import qualified Numeric.LAPACK.FFI.ComplexFloat as FFI
import qualified Numeric.Netlib.CArray.Utility as Call
import Numeric.Netlib.CArray.Utility ((^!))

import Data.Array.IOCArray (IOCArray, getBounds)
import Data.Array.CArray (CArray, bounds)

import Data.Complex (Complex)

import Foreign.Storable.Complex ()
import Foreign.Storable (peek)
import Foreign.Ptr (Ptr, FunPtr)
import Foreign.C.String (castCCharToChar)
import Foreign.C.Types (CInt)

import Control.Monad.Trans.Cont (evalContT)
import Control.Monad.IO.Class (liftIO)
import Control.Applicative (pure, (<*>), (<$>))


-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cbbcsd.f>
bbcsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOCArray Int Float {- ^ theta -} ->
   IOCArray Int Float {- ^ phi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ u1 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ u2 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v1t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v2t -} ->
   Int {- ^ lrwork -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int Float, CArray Int Float, CArray Int Float, CArray Int Float, CArray Int Float, CArray Int Float, Int)
bbcsd jobu1 jobu2 jobv1t jobv2t trans m theta phi u1 u2 v1t v2t lrwork = do
   thetaDim0 <- Call.sizes1 <$> getBounds theta
   phiDim0 <- Call.sizes1 <$> getBounds phi
   (u1Dim0,u1Dim1) <- Call.sizes2 <$> getBounds u1
   (u2Dim0,u2Dim1) <- Call.sizes2 <$> getBounds u2
   (v1tDim0,v1tDim1) <- Call.sizes2 <$> getBounds v1t
   (v2tDim0,v2tDim1) <- Call.sizes2 <$> getBounds v2t
   let q = thetaDim0
   let p = u1Dim0
   let ldu1 = u1Dim1
   let ldu2 = u2Dim1
   let ldv1t = v1tDim1
   let ldv2t = v2tDim1
   Call.assert "bbcsd: q-1 == phiDim0" (q-1 == phiDim0)
   Call.assert "bbcsd: m-p == u2Dim0" (m-p == u2Dim0)
   Call.assert "bbcsd: q == v1tDim0" (q == v1tDim0)
   Call.assert "bbcsd: m-q == v2tDim0" (m-q == v2tDim0)
   b11d <- Call.newArray1 q
   b11e <- Call.newArray1 (q-1)
   b12d <- Call.newArray1 q
   b12e <- Call.newArray1 (q-1)
   b21d <- Call.newArray1 q
   b21e <- Call.newArray1 (q-1)
   b22d <- Call.newArray1 q
   b22e <- Call.newArray1 (q-1)
   rwork <- Call.newArray1 (maximum[1,lrwork])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      b11dPtr <- Call.ioarray b11d
      b11ePtr <- Call.ioarray b11e
      b12dPtr <- Call.ioarray b12d
      b12ePtr <- Call.ioarray b12e
      b21dPtr <- Call.ioarray b21d
      b21ePtr <- Call.ioarray b21e
      b22dPtr <- Call.ioarray b22d
      b22ePtr <- Call.ioarray b22e
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bbcsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr mPtr pPtr qPtr thetaPtr phiPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr b11dPtr b11ePtr b12dPtr b12ePtr b21dPtr b21ePtr b22dPtr b22ePtr rworkPtr lrworkPtr infoPtr
      liftIO $ pure (,,,,,,,,)
         <*> Call.freezeArray b11d
         <*> Call.freezeArray b11e
         <*> Call.freezeArray b12d
         <*> Call.freezeArray b12e
         <*> Call.freezeArray b21d
         <*> Call.freezeArray b21e
         <*> Call.freezeArray b22d
         <*> Call.freezeArray b22e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cbdsqr.f>
bdsqr ::
   Char {- ^ uplo -} ->
   Int {- ^ nru -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vt -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ u -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   IO (Int)
bdsqr uplo nru d e vt u c = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (vtDim0,vtDim1) <- Call.sizes2 <$> getBounds vt
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = dDim0
   let ncvt = vtDim0
   let ldvt = vtDim1
   let ldu = uDim1
   let ncc = cDim0
   let ldc = cDim1
   Call.assert "bdsqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "bdsqr: n == uDim0" (n == uDim0)
   rwork <- Call.newArray1 (4*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      ncvtPtr <- Call.cint ncvt
      nruPtr <- Call.cint nru
      nccPtr <- Call.cint ncc
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bdsqr uploPtr nPtr ncvtPtr nruPtr nccPtr dPtr ePtr vtPtr ldvtPtr uPtr lduPtr cPtr ldcPtr rworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbbrd.f>
gbbrd ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Int {- ^ ldpt -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   IO (CArray Int Float, CArray Int Float, CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
gbbrd vect m kl ku ab ldq ldpt c = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = abDim0
   let ldab = abDim1
   let ncc = cDim0
   let ldc = cDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   q <- Call.newArray2 m ldq
   pt <- Call.newArray2 n ldpt
   work <- Call.newArray1 (maximum[m,n])
   rwork <- Call.newArray1 (maximum[m,n])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nccPtr <- Call.cint ncc
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ptPtr <- Call.ioarray pt
      ldptPtr <- Call.cint ldpt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbbrd vectPtr mPtr nPtr nccPtr klPtr kuPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr ptPtr ldptPtr cPtr ldcPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray q
         <*> Call.freezeArray pt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbcon.f>
gbcon ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gbcon norm kl ku ab ipiv anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = abDim0
   let ldab = abDim1
   Call.assert "gbcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbcon normPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr anormPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbequ.f>
gbequ ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (CArray Int Float, CArray Int Float, Float, Float, Float, Int)
gbequ m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequ mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbequb.f>
gbequb ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (CArray Int Float, CArray Int Float, Float, Float, Float, Int)
gbequb m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbrfs.f>
gbrfs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray (Int,Int) (Complex Float) {- ^ afb -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
gbrfs trans kl ku ab afb ipiv b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (afbDim0,afbDim1) = Call.sizes2 $ bounds afb
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "gbrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbrfs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbsv.f>
gbsv ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (CArray Int CInt, Int)
gbsv kl ku ab b = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsv nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbsvx.f>
gbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ afb -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOCArray Int Float {- ^ r -} ->
   IOCArray Int Float {- ^ c -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
gbsvx fact trans kl ku ab afb ipiv equed r c b ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (afbDim0,afbDim1) <- Call.sizes2 <$> getBounds afb
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   rDim0 <- Call.sizes1 <$> getBounds r
   cDim0 <- Call.sizes1 <$> getBounds c
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "gbsvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbsvx: n == rDim0" (n == rDim0)
   Call.assert "gbsvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsvx factPtr transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbtf2.f>
gbtf2 ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (CArray Int CInt, Int)
gbtf2 m kl ku ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtf2 mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbtrf.f>
gbtrf ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (CArray Int CInt, Int)
gbtrf m kl ku ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrf mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgbtrs.f>
gbtrs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
gbtrs trans kl ku ab ipiv b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbtrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgebak.f>
gebak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray Int Float {- ^ scale -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v -} ->
   IO (Int)
gebak job side ilo ihi scale v = do
   let scaleDim0 = Call.sizes1 $ bounds scale
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = scaleDim0
   let m = vDim0
   let ldv = vDim1
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      scalePtr <- Call.array scale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.gebak jobPtr sidePtr nPtr iloPtr ihiPtr scalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgebal.f>
gebal ::
   Char {- ^ job -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int, Int, CArray Int Float, Int)
gebal job a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   scale <- Call.newArray1 n
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      infoPtr <- Call.alloca
      liftIO $ FFI.gebal jobPtr nPtr aPtr ldaPtr iloPtr ihiPtr scalePtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgebd2.f>
gebd2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), CArray Int (Complex Float), Int)
gebd2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gebd2 mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgebrd.f>
gebrd ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), CArray Int (Complex Float), Int)
gebrd m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gebrd mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgecon.f>
gecon ::
   Char {- ^ norm -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gecon norm a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gecon normPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeequ.f>
geequ ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, CArray Int Float, Float, Float, Float, Int)
geequ m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequ mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeequb.f>
geequb ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, CArray Int Float, Float, Float, Float, Int)
geequb m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequb mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgees.f>
gees ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr (Complex Float) -> IO Bool) {- ^ select -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int (Complex Float), CArray (Int,Int) (Complex Float), Int)
gees jobvs sort select a ldvs lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 n
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wPtr <- Call.ioarray w
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gees jobvsPtr sortPtr selectPtr nPtr aPtr ldaPtr sdimPtr wPtr vsPtr ldvsPtr workPtr lworkPtr rworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray vs
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeesx.f>
geesx ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr (Complex Float) -> IO Bool) {- ^ select -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int (Complex Float), CArray (Int,Int) (Complex Float), Float, Float, Int)
geesx jobvs sort select sense a ldvs lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 n
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wPtr <- Call.ioarray w
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      rcondePtr <- Call.alloca
      rcondvPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geesx jobvsPtr sortPtr selectPtr sensePtr nPtr aPtr ldaPtr sdimPtr wPtr vsPtr ldvsPtr rcondePtr rcondvPtr workPtr lworkPtr rworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray vs
         <*> peek rcondePtr
         <*> peek rcondvPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeev.f>
geev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
geev jobvl jobvr a ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geev jobvlPtr jobvrPtr nPtr aPtr ldaPtr wPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeevx.f>
geevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int, Int, CArray Int Float, Float, CArray Int Float, CArray Int Float, Int)
geevx balanc jobvl jobvr sense a ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   scale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      abnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr wPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr scalePtr abnrmPtr rcondePtr rcondvPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> peek abnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgehd2.f>
gehd2 ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
gehd2 ilo ihi a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gehd2 nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgehrd.f>
gehrd ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
gehrd ilo ihi a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 lwork
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gehrd nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgelq2.f>
gelq2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
gelq2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gelq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgelqf.f>
gelqf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
gelqf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgels.f>
gels ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gels trans m a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gels transPtr mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgelsd.f>
gelsd ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, Int, Int)
gelsd m a b rcond lwork lrwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsd mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgelss.f>
gelss ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, Int, Int)
gelss m a b rcond lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (5*minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelss mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgelsy.f>
gelsy ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int)
gelsy m a b jpvt rcond lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gelsy: n == jpvtDim0" (n == jpvtDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      jpvtPtr <- Call.ioarray jpvt
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsy mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr jpvtPtr rcondPtr rankPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeql2.f>
geql2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
geql2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geql2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqlf.f>
geqlf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
geqlf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqlf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqp3.f>
geqp3 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
geqp3 m a jpvt lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   let n = aDim0
   let lda = aDim1
   Call.assert "geqp3: n == jpvtDim0" (n == jpvtDim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqp3 mPtr nPtr aPtr ldaPtr jpvtPtr tauPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqr2.f>
geqr2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
geqr2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqr2p.f>
geqr2p ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
geqr2p m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2p mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqrf.f>
geqrf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
geqrf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgeqrfp.f>
geqrfp ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
geqrfp m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrfp mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgerfs.f>
gerfs ::
   Char {- ^ trans -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ af -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
gerfs trans a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gerfs: n == afDim0" (n == afDim0)
   Call.assert "gerfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gerfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerfs transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgerq2.f>
gerq2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
gerq2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gerq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgerqf.f>
gerqf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
gerqf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgesc2.f>
gesc2 ::
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray Int (Complex Float) {- ^ rhs -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray Int CInt {- ^ jpiv -} ->
   IO (Float)
gesc2 a rhs ipiv jpiv = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   rhsDim0 <- Call.sizes1 <$> getBounds rhs
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let jpivDim0 = Call.sizes1 $ bounds jpiv
   let n = aDim0
   let lda = aDim1
   let _rhsSize = rhsDim0
   Call.assert "gesc2: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesc2: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rhsPtr <- Call.ioarray rhs
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      scalePtr <- Call.alloca
      liftIO $ FFI.gesc2 nPtr aPtr ldaPtr rhsPtr ipivPtr jpivPtr scalePtr
      liftIO $ peek scalePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgesdd.f>
gesdd ::
   Char {- ^ jobz -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
gesdd jobz m a ucol ldu ldvt lwork lrwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (8*minimum[m,n])
   evalContT $ do
      jobzPtr <- Call.char jobz
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesdd jobzPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgesv.f>
gesv ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (CArray Int CInt, Int)
gesv a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gesv nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgesvd.f>
gesvd ::
   Char {- ^ jobu -} ->
   Char {- ^ jobvt -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
gesvd jobu jobvt m a ucol ldu ldvt lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (5*minimum[m,n])
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvtPtr <- Call.char jobvt
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvd jobuPtr jobvtPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgesvx.f>
gesvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ af -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOCArray Int Float {- ^ r -} ->
   IOCArray Int Float {- ^ c -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
gesvx fact trans a af ipiv equed r c b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   rDim0 <- Call.sizes1 <$> getBounds r
   cDim0 <- Call.sizes1 <$> getBounds c
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gesvx: n == afDim0" (n == afDim0)
   Call.assert "gesvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesvx: n == rDim0" (n == rDim0)
   Call.assert "gesvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvx factPtr transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgetc2.f>
getc2 ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int CInt, CArray Int CInt, Int)
getc2 a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   jpiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      jpivPtr <- Call.ioarray jpiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getc2 nPtr aPtr ldaPtr ipivPtr jpivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray jpiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgetf2.f>
getf2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int CInt, Int)
getf2 m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getf2 mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgetrf.f>
getrf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int CInt, Int)
getrf m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getrf mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgetri.f>
getri ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ lwork -} ->
   IO (Int)
getri a ipiv lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "getri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.getri nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgetrs.f>
getrs ::
   Char {- ^ trans -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
getrs trans a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "getrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.getrs transPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggbak.f>
ggbak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray Int Float {- ^ lscale -} ->
   CArray Int Float {- ^ rscale -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v -} ->
   IO (Int)
ggbak job side ilo ihi lscale rscale v = do
   let lscaleDim0 = Call.sizes1 $ bounds lscale
   let rscaleDim0 = Call.sizes1 $ bounds rscale
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let n = lscaleDim0
   let m = vDim0
   let ldv = vDim1
   Call.assert "ggbak: n == rscaleDim0" (n == rscaleDim0)
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      lscalePtr <- Call.array lscale
      rscalePtr <- Call.array rscale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbak jobPtr sidePtr nPtr iloPtr ihiPtr lscalePtr rscalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggbal.f>
ggbal ::
   Char {- ^ job -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int Float, CArray Int Float, Int)
ggbal job a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggbal: n == bDim0" (n == bDim0)
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbal jobPtr nPtr aPtr ldaPtr bPtr ldbPtr iloPtr ihiPtr lscalePtr rscalePtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgges.f>
gges ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr (Complex Float) -> Ptr (Complex Float) -> IO Bool) {- ^ selctg -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int (Complex Float), CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
gges jobvsl jobvsr sort selctg a b ldvsl ldvsr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "gges: n == bDim0" (n == bDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (8*n)
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gges jobvslPtr jobvsrPtr sortPtr selctgPtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alphaPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr workPtr lworkPtr rworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggesx.f>
ggesx ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr (Complex Float) -> Ptr (Complex Float) -> IO Bool) {- ^ selctg -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int (Complex Float), CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray Int Float, CArray Int Float, Int)
ggesx jobvsl jobvsr sort selctg sense a b ldvsl ldvsr lwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggesx: n == bDim0" (n == bDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   rconde <- Call.newArray1 2
   rcondv <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (8*n)
   iwork <- Call.newArray1 (maximum[1,liwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggesx jobvslPtr jobvsrPtr sortPtr selctgPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alphaPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr rcondePtr rcondvPtr workPtr lworkPtr rworkPtr iworkPtr liworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggev.f>
ggev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
ggev jobvl jobvr a b ldvl ldvr lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggev: n == bDim0" (n == bDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (8*n)
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggev jobvlPtr jobvrPtr nPtr aPtr ldaPtr bPtr ldbPtr alphaPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggevx.f>
ggevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int, Int, CArray Int Float, CArray Int Float, Float, Float, CArray Int Float, CArray Int Float, Int)
ggevx balanc jobvl jobvr sense a b ldvl ldvr lwork lrwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggevx: n == bDim0" (n == bDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 lrwork
   iwork <- Call.newArray1 (n+2)
   bwork <- Call.newArray1 n
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      abnrmPtr <- Call.alloca
      bbnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr alphaPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr lscalePtr rscalePtr abnrmPtr bbnrmPtr rcondePtr rcondvPtr workPtr lworkPtr rworkPtr iworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> peek abnrmPtr
         <*> peek bbnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggglm.f>
ggglm ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray Int (Complex Float) {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), Int)
ggglm a b d lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   dDim0 <- Call.sizes1 <$> getBounds d
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   let n = dDim0
   x <- Call.newArray1 m
   y <- Call.newArray1 p
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggglm nPtr mPtr pPtr aPtr ldaPtr bPtr ldbPtr dPtr xPtr yPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray x
         <*> Call.freezeArray y
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgghrd.f>
gghrd ::
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   IO (Int)
gghrd compq compz ilo ihi a b q z = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "gghrd: n == bDim0" (n == bDim0)
   Call.assert "gghrd: n == qDim0" (n == qDim0)
   Call.assert "gghrd: n == zDim0" (n == zDim0)
   evalContT $ do
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.gghrd compqPtr compzPtr nPtr iloPtr ihiPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgglse.f>
gglse ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray Int (Complex Float) {- ^ c -} ->
   IOCArray Int (Complex Float) {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
gglse a b c d lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   cDim0 <- Call.sizes1 <$> getBounds c
   dDim0 <- Call.sizes1 <$> getBounds d
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = cDim0
   let p = dDim0
   Call.assert "gglse: n == bDim0" (n == bDim0)
   x <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gglse mPtr nPtr pPtr aPtr ldaPtr bPtr ldbPtr cPtr dPtr xPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggqrf.f>
ggqrf ::
   Int {- ^ n -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), Int)
ggqrf n a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   taua <- Call.newArray1 (minimum[n,m])
   taub <- Call.newArray1 (minimum[n,p])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggqrf nPtr mPtr pPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cggrqf.f>
ggrqf ::
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), Int)
ggrqf m p a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggrqf: n == bDim0" (n == bDim0)
   taua <- Call.newArray1 (minimum[m,n])
   taub <- Call.newArray1 (minimum[p,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggrqf mPtr pPtr nPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgtcon.f>
gtcon ::
   Char {- ^ norm -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   CArray Int (Complex Float) {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gtcon norm dl d du du2 ipiv anorm = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = dDim0
   Call.assert "gtcon: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtcon: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtcon: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gtcon normPtr nPtr dlPtr dPtr duPtr du2Ptr ipivPtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgtrfs.f>
gtrfs ::
   Char {- ^ trans -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   CArray Int (Complex Float) {- ^ dlf -} ->
   CArray Int (Complex Float) {- ^ df -} ->
   CArray Int (Complex Float) {- ^ duf -} ->
   CArray Int (Complex Float) {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
gtrfs trans dl d du dlf df duf du2 ipiv b x = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let dlfDim0 = Call.sizes1 $ bounds dlf
   let dfDim0 = Call.sizes1 $ bounds df
   let dufDim0 = Call.sizes1 $ bounds duf
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gtrfs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtrfs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtrfs: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtrfs: n == dfDim0" (n == dfDim0)
   Call.assert "gtrfs: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtrfs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gtrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.array dlf
      dfPtr <- Call.array df
      dufPtr <- Call.array duf
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtrfs transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgtsv.f>
gtsv ::
   IOCArray Int (Complex Float) {- ^ dl -} ->
   IOCArray Int (Complex Float) {- ^ d -} ->
   IOCArray Int (Complex Float) {- ^ du -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
gtsv dl d du b = do
   dlDim0 <- Call.sizes1 <$> getBounds dl
   dDim0 <- Call.sizes1 <$> getBounds d
   duDim0 <- Call.sizes1 <$> getBounds du
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsv: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsv: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsv nPtr nrhsPtr dlPtr dPtr duPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgtsvx.f>
gtsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   IOCArray Int (Complex Float) {- ^ dlf -} ->
   IOCArray Int (Complex Float) {- ^ df -} ->
   IOCArray Int (Complex Float) {- ^ duf -} ->
   IOCArray Int (Complex Float) {- ^ du2 -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
gtsvx fact trans dl d du dlf df duf du2 ipiv b ldx = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   dlfDim0 <- Call.sizes1 <$> getBounds dlf
   dfDim0 <- Call.sizes1 <$> getBounds df
   dufDim0 <- Call.sizes1 <$> getBounds duf
   du2Dim0 <- Call.sizes1 <$> getBounds du2
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsvx: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsvx: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtsvx: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtsvx: n == dfDim0" (n == dfDim0)
   Call.assert "gtsvx: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtsvx: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtsvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.ioarray dlf
      dfPtr <- Call.ioarray df
      dufPtr <- Call.ioarray duf
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsvx factPtr transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgttrf.f>
gttrf ::
   IOCArray Int (Complex Float) {- ^ dl -} ->
   IOCArray Int (Complex Float) {- ^ d -} ->
   IOCArray Int (Complex Float) {- ^ du -} ->
   IO (CArray Int (Complex Float), CArray Int CInt, Int)
gttrf dl d du = do
   dlDim0 <- Call.sizes1 <$> getBounds dl
   dDim0 <- Call.sizes1 <$> getBounds d
   duDim0 <- Call.sizes1 <$> getBounds du
   let n = dDim0
   Call.assert "gttrf: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrf: n-1 == duDim0" (n-1 == duDim0)
   du2 <- Call.newArray1 (n-2)
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrf nPtr dlPtr dPtr duPtr du2Ptr ipivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray du2
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgttrs.f>
gttrs ::
   Char {- ^ trans -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   CArray Int (Complex Float) {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
gttrs trans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gttrs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gttrs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gttrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrs transPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cgtts2.f>
gtts2 ::
   Int {- ^ itrans -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   CArray Int (Complex Float) {- ^ du2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO ()
gtts2 itrans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let du2Dim0 = Call.sizes1 $ bounds du2
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtts2: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtts2: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtts2: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtts2: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      itransPtr <- Call.cint itrans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.gtts2 itransPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbev.f>
hbev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hbev jobz uplo kd ab ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 n
   rwork <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hbev jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbevd.f>
hbevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ rworkSize -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hbevd jobz uplo kd ab ldz lwork rworkSize lrwork liwork = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hbevd jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbevx.f>
hbevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) (Complex Float), Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
hbevx jobz range uplo kd ab ldq vl vu il iu abstol m ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 n
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.hbevx jobzPtr rangePtr uploPtr nPtr kdPtr abPtr ldabPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbgst.f>
hbgst ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray (Int,Int) (Complex Float) {- ^ bb -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
hbgst vect uplo ka kb ab bb ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let (bbDim0,bbDim1) = Call.sizes2 $ bounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "hbgst: n == bbDim0" (n == bbDim0)
   x <- Call.newArray2 n ldx
   work <- Call.newArray1 n
   rwork <- Call.newArray1 n
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.array bb
      ldbbPtr <- Call.cint ldbb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hbgst vectPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr xPtr ldxPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbgv.f>
hbgv ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ bb -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hbgv jobz uplo ka kb ab bb ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "hbgv: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 n
   rwork <- Call.newArray1 (3*n)
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hbgv jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbgvd.f>
hbgvd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ bb -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hbgvd jobz uplo ka kb ab bb ldz lwork lrwork liwork = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "hbgvd: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hbgvd jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbgvx.f>
hbgvx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ bb -} ->
   Int {- ^ ldq -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) (Complex Float), Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
hbgvx jobz range uplo ka kb ab bb ldq vl vu il iu abstol ldz = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bbDim0,bbDim1) <- Call.sizes2 <$> getBounds bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "hbgvx: n == bbDim0" (n == bbDim0)
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 n
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.hbgvx jobzPtr rangePtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chbtrd.f>
hbtrd ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IO (CArray Int Float, CArray Int Float, Int)
hbtrd vect uplo kd ab q = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = abDim0
   let ldab = abDim1
   let ldq = qDim1
   Call.assert "hbtrd: n == qDim0" (n == qDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hbtrd vectPtr uploPtr nPtr kdPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/checon.f>
hecon ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
hecon uplo a ipiv anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "hecon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hecon uploPtr nPtr aPtr ldaPtr ipivPtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheequb.f>
heequb ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, Float, Float, Int)
heequb uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.heequb uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheev.f>
heev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, Int)
heev jobz uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.heev jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheevd.f>
heevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   Int {- ^ rworkSize -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, Int)
heevd jobz uplo a lwork rworkSize lrwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.heevd jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheevr.f>
heevr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
heevr jobz range uplo a vl vu il iu abstol m ldz lwork lrwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.heevr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheevx.f>
heevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
heevx jobz range uplo a vl vu il iu abstol m ldz lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.heevx jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chegs2.f>
hegs2 ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
hegs2 itype uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "hegs2: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.hegs2 itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chegst.f>
hegst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
hegst itype uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "hegst: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.hegst itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chegv.f>
hegv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, Int)
hegv itype jobz uplo a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "hegv: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hegv itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chegvd.f>
hegvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, Int)
hegvd itype jobz uplo a b lwork lrwork liwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "hegvd: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hegvd itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chegvx.f>
hegvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
hegvx itype jobz range uplo a b vl vu il iu abstol m ldz lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "hegvx: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.hegvx itypePtr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cherfs.f>
herfs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ af -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
herfs uplo a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "herfs: n == afDim0" (n == afDim0)
   Call.assert "herfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "herfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.herfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chesv.f>
hesv ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
hesv uplo a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hesv uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chesvx.f>
hesvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ af -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   Int {- ^ lwork -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
hesvx fact uplo a af ipiv b ldx lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hesvx: n == afDim0" (n == afDim0)
   Call.assert "hesvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hesvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cheswapr.f>
heswapr ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ i1 -} ->
   Int {- ^ i2 -} ->
   IO ()
heswapr uplo a i1 i2 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      i1Ptr <- Call.cint i1
      i2Ptr <- Call.cint i2
      liftIO $ FFI.heswapr uploPtr nPtr aPtr ldaPtr i1Ptr i2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetd2.f>
hetd2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), Int)
hetd2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.hetd2 uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetf2.f>
hetf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int CInt, Int)
hetf2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.hetf2 uploPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetrd.f>
hetrd ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), Int)
hetrd uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hetrd uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetrf.f>
hetrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
hetrf uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hetrf uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetri.f>
hetri ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
hetri uplo a ipiv = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "hetri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hetri uploPtr nPtr aPtr ldaPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetri2.f>
hetri2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   Int {- ^ lwork -} ->
   IO (Int)
hetri2 uplo a ipiv nb lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "hetri2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hetri2 uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetri2x.f>
hetri2x ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   IO (Int)
hetri2x uplo a ipiv nb = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "hetri2x: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray2 (nb+3) (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      nbPtr <- Call.cint nb
      infoPtr <- Call.alloca
      liftIO $ FFI.hetri2x uploPtr nPtr aPtr ldaPtr ipivPtr workPtr nbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetrs.f>
hetrs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
hetrs uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hetrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.hetrs uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chetrs2.f>
hetrs2 ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
hetrs2 uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hetrs2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hetrs2 uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chfrk.f>
hfrk ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ beta -} ->
   IOCArray Int (Complex Float) {- ^ c -} ->
   IO ()
hfrk transr uplo trans n k alpha a beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   cDim0 <- Call.sizes1 <$> getBounds c
   let _ka = aDim0
   let lda = aDim1
   Call.assert "hfrk: n*(n+1)`div`2 == cDim0" (n*(n+1)`div`2 == cDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      liftIO $ FFI.hfrk transrPtr uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr betaPtr cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chgeqz.f>
hgeqz ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), Int)
hgeqz job compq compz ilo ihi h t q z lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldt = tDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "hgeqz: n == tDim0" (n == tDim0)
   Call.assert "hgeqz: n == qDim0" (n == qDim0)
   Call.assert "hgeqz: n == zDim0" (n == zDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 n
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hgeqz jobPtr compqPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr tPtr ldtPtr alphaPtr betaPtr qPtr ldqPtr zPtr ldzPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpcon.f>
hpcon ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
hpcon uplo ap ipiv anorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "hpcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hpcon uploPtr nPtr apPtr ipivPtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpev.f>
hpev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hpev jobz uplo n ap ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "hpev: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,2*n-1])
   rwork <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hpev jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpevd.f>
hpevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hpevd jobz uplo n ap ldz lwork lrwork liwork = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "hpevd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hpevd jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpevx.f>
hpevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
hpevx jobz range uplo n ap vl vu il iu abstol m ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "hpevx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.hpevx jobzPtr rangePtr uploPtr nPtr apPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpgst.f>
hpgst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ bp -} ->
   IO (Int)
hpgst itype uplo n ap bp = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let bpDim0 = Call.sizes1 $ bounds bp
   Call.assert "hpgst: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hpgst: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.array bp
      infoPtr <- Call.alloca
      liftIO $ FFI.hpgst itypePtr uploPtr nPtr apPtr bpPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpgv.f>
hpgv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ bp -} ->
   Int {- ^ ldz -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hpgv itype jobz uplo n ap bp ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "hpgv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hpgv: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,2*n-1])
   rwork <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hpgv itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpgvd.f>
hpgvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ bp -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), Int)
hpgvd itype jobz uplo n ap bp ldz lwork lrwork liwork = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "hpgvd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hpgvd: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hpgvd itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpgvx.f>
hpgvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ bp -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ ldz -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
hpgvx itype jobz range uplo n ap bp vl vu il iu abstol ldz = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   bpDim0 <- Call.sizes1 <$> getBounds bp
   Call.assert "hpgvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hpgvx: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.hpgvx itypePtr jobzPtr rangePtr uploPtr nPtr apPtr bpPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr rworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chprfs.f>
hprfs ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ afp -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
hprfs uplo ap afp ipiv b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let afpDim0 = Call.sizes1 $ bounds afp
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "hprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "hprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hprfs uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpsv.f>
hpsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (CArray Int CInt, Int)
hpsv uplo n ap b = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hpsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.hpsv uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chpsvx.f>
hpsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ afp -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
hpsvx fact uplo ap afp ipiv b ldx = do
   let apDim0 = Call.sizes1 $ bounds ap
   afpDim0 <- Call.sizes1 <$> getBounds afp
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hpsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "hpsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.ioarray afp
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hpsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chptrd.f>
hptrd ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), Int)
hptrd uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "hptrd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.hptrd uploPtr nPtr apPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chptrf.f>
hptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (CArray Int CInt, Int)
hptrf uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "hptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.hptrf uploPtr nPtr apPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chptri.f>
hptri ::
   Char {- ^ uplo -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
hptri uplo ap ipiv = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "hptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.hptri uploPtr nPtr apPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chptrs.f>
hptrs ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
hptrs uplo ap ipiv b = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "hptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.hptrs uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chsein.f>
hsein ::
   Char {- ^ side -} ->
   Char {- ^ eigsrc -} ->
   Char {- ^ initv -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) (Complex Float) {- ^ h -} ->
   IOCArray Int (Complex Float) {- ^ w -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vl -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vr -} ->
   IO (Int, CArray Int CInt, CArray Int CInt, Int)
hsein side eigsrc initv select h w vl vr = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   wDim0 <- Call.sizes1 <$> getBounds w
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let ldh = hDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "hsein: n == hDim0" (n == hDim0)
   Call.assert "hsein: n == wDim0" (n == wDim0)
   Call.assert "hsein: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (n*n)
   rwork <- Call.newArray1 n
   ifaill <- Call.newArray1 mm
   ifailr <- Call.newArray1 mm
   evalContT $ do
      sidePtr <- Call.char side
      eigsrcPtr <- Call.char eigsrc
      initvPtr <- Call.char initv
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.ioarray w
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      ifaillPtr <- Call.ioarray ifaill
      ifailrPtr <- Call.ioarray ifailr
      infoPtr <- Call.alloca
      liftIO $ FFI.hsein sidePtr eigsrcPtr initvPtr selectPtr nPtr hPtr ldhPtr wPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr rworkPtr ifaillPtr ifailrPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray ifaill
         <*> Call.freezeArray ifailr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/chseqr.f>
hseqr ::
   Char {- ^ job -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
hseqr job compz ilo ihi h z lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "hseqr: n == zDim0" (n == zDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hseqr jobPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaclc.f>
ilalc ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO CInt
ilalc m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalc mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaclr.f>
ilalr ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO CInt
ilalr m a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalr mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/icmax1.f>
imax1 ::
   CArray Int (Complex Float) {- ^ cx -} ->
   Int {- ^ incx -} ->
   IO CInt
imax1 cx incx = do
   let cxDim0 = Call.sizes1 $ bounds cx
   let n = cxDim0
   evalContT $ do
      nPtr <- Call.cint n
      cxPtr <- Call.array cx
      incxPtr <- Call.cint incx
      liftIO $ FFI.imax1 nPtr cxPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clabrd.f>
labrd ::
   Int {- ^ m -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldx -} ->
   Int {- ^ ldy -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float))
labrd m nb a ldx ldy = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 nb
   e <- Call.newArray1 nb
   tauq <- Call.newArray1 nb
   taup <- Call.newArray1 nb
   x <- Call.newArray2 nb ldx
   y <- Call.newArray2 nb ldy
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.labrd mPtr nPtr nbPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr xPtr ldxPtr yPtr ldyPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> Call.freezeArray x
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacgv.f>
lacgv ::
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
lacgv n x incx = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.lacgv nPtr xPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacn2.f>
lacn2 ::
   IOCArray Int (Complex Float) {- ^ x -} ->
   Float {- ^ est -} ->
   Int {- ^ kase -} ->
   IOCArray Int CInt {- ^ isave -} ->
   IO (CArray Int (Complex Float), Float, Int)
lacn2 x est kase isave = do
   xDim0 <- Call.sizes1 <$> getBounds x
   isaveDim0 <- Call.sizes1 <$> getBounds isave
   let n = xDim0
   Call.assert "lacn2: 3 == isaveDim0" (3 == isaveDim0)
   v <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      estPtr <- Call.float est
      kasePtr <- Call.cint kase
      isavePtr <- Call.ioarray isave
      liftIO $ FFI.lacn2 nPtr vPtr xPtr estPtr kasePtr isavePtr
      liftIO $ pure (,,)
         <*> Call.freezeArray v
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacon.f>
lacon ::
   IOCArray Int (Complex Float) {- ^ x -} ->
   Float {- ^ est -} ->
   Int {- ^ kase -} ->
   IO (CArray Int (Complex Float), Float, Int)
lacon x est kase = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let n = xDim0
   v <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      estPtr <- Call.float est
      kasePtr <- Call.cint kase
      liftIO $ FFI.lacon nPtr vPtr xPtr estPtr kasePtr
      liftIO $ pure (,,)
         <*> Call.freezeArray v
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacp2.f>
lacp2 ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) Float {- ^ a -} ->
   Int {- ^ ldb -} ->
   IO (CArray (Int,Int) (Complex Float))
lacp2 uplo m a ldb = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   b <- Call.newArray2 n ldb
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lacp2 uploPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr
      liftIO $ Call.freezeArray b

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacpy.f>
lacpy ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldb -} ->
   IO (CArray (Int,Int) (Complex Float))
lacpy uplo m a ldb = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   b <- Call.newArray2 n ldb
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lacpy uploPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr
      liftIO $ Call.freezeArray b

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacrm.f>
lacrm ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) Float {- ^ b -} ->
   Int {- ^ ldc -} ->
   IO (CArray (Int,Int) (Complex Float))
lacrm m a b ldc = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "lacrm: n == bDim0" (n == bDim0)
   c <- Call.newArray2 n ldc
   rwork <- Call.newArray1 (2*m*n)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      rworkPtr <- Call.ioarray rwork
      liftIO $ FFI.lacrm mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr rworkPtr
      liftIO $ Call.freezeArray c

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clacrt.f>
lacrt ::
   IOCArray Int (Complex Float) {- ^ cx -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ cy -} ->
   Int {- ^ incy -} ->
   Complex Float {- ^ c -} ->
   Complex Float {- ^ s -} ->
   IO ()
lacrt cx incx cy incy c s = do
   cxDim0 <- Call.sizes1 <$> getBounds cx
   cyDim0 <- Call.sizes1 <$> getBounds cy
   let n = cxDim0
   Call.assert "lacrt: n == cyDim0" (n == cyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      cxPtr <- Call.ioarray cx
      incxPtr <- Call.cint incx
      cyPtr <- Call.ioarray cy
      incyPtr <- Call.cint incy
      cPtr <- Call.complexFloat c
      sPtr <- Call.complexFloat s
      liftIO $ FFI.lacrt nPtr cxPtr incxPtr cyPtr incyPtr cPtr sPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claed0.f>
laed0 ::
   Int {- ^ qsiz -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   Int {- ^ ldqs -} ->
   Int {- ^ rworkSize -} ->
   Int {- ^ iworkSize -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
laed0 qsiz d e q ldqs rworkSize iworkSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed0: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "laed0: n == qDim0" (n == qDim0)
   qstore <- Call.newArray2 n ldqs
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 iworkSize
   evalContT $ do
      qsizPtr <- Call.cint qsiz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      qstorePtr <- Call.ioarray qstore
      ldqsPtr <- Call.cint ldqs
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed0 qsizPtr nPtr dPtr ePtr qPtr ldqPtr qstorePtr ldqsPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray qstore
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claed7.f>
laed7 ::
   Int {- ^ cutpnt -} ->
   Int {- ^ qsiz -} ->
   Int {- ^ tlvls -} ->
   Int {- ^ curlvl -} ->
   Int {- ^ curpbm -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   Float {- ^ rho -} ->
   IOCArray Int Float {- ^ qstore -} ->
   IOCArray Int CInt {- ^ qptr -} ->
   CArray Int CInt {- ^ prmptr -} ->
   CArray Int CInt {- ^ perm -} ->
   CArray Int CInt {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) Float {- ^ givnum -} ->
   Int {- ^ rworkSize -} ->
   IO (CArray Int CInt, Int)
laed7 cutpnt qsiz tlvls curlvl curpbm d q rho qstore qptr prmptr perm givptr givcol givnum rworkSize = do
   dDim0 <- Call.sizes1 <$> getBounds d
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   qstoreDim0 <- Call.sizes1 <$> getBounds qstore
   qptrDim0 <- Call.sizes1 <$> getBounds qptr
   let prmptrDim0 = Call.sizes1 $ bounds prmptr
   let permDim0 = Call.sizes1 $ bounds perm
   let givptrDim0 = Call.sizes1 $ bounds givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let n = dDim0
   let ldq = qDim1
   let nlgn = prmptrDim0
   Call.assert "laed7: n == qDim0" (n == qDim0)
   Call.assert "laed7: n^!2+1 == qstoreDim0" (n^!2+1 == qstoreDim0)
   Call.assert "laed7: n+2 == qptrDim0" (n+2 == qptrDim0)
   Call.assert "laed7: nlgn == permDim0" (nlgn == permDim0)
   Call.assert "laed7: nlgn == givptrDim0" (nlgn == givptrDim0)
   Call.assert "laed7: nlgn == givcolDim0" (nlgn == givcolDim0)
   Call.assert "laed7: 2 == givcolDim1" (2 == givcolDim1)
   Call.assert "laed7: nlgn == givnumDim0" (nlgn == givnumDim0)
   Call.assert "laed7: 2 == givnumDim1" (2 == givnumDim1)
   indxq <- Call.newArray1 n
   work <- Call.newArray1 (qsiz*n)
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      cutpntPtr <- Call.cint cutpnt
      qsizPtr <- Call.cint qsiz
      tlvlsPtr <- Call.cint tlvls
      curlvlPtr <- Call.cint curlvl
      curpbmPtr <- Call.cint curpbm
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      rhoPtr <- Call.float rho
      indxqPtr <- Call.ioarray indxq
      qstorePtr <- Call.ioarray qstore
      qptrPtr <- Call.ioarray qptr
      prmptrPtr <- Call.array prmptr
      permPtr <- Call.array perm
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      givnumPtr <- Call.array givnum
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed7 nPtr cutpntPtr qsizPtr tlvlsPtr curlvlPtr curpbmPtr dPtr qPtr ldqPtr rhoPtr indxqPtr qstorePtr qptrPtr prmptrPtr permPtr givptrPtr givcolPtr givnumPtr workPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray indxq
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claed8.f>
laed8 ::
   Int {- ^ qsiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray Int Float {- ^ d -} ->
   Float {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   CArray Int Float {- ^ z -} ->
   Int {- ^ ldq2 -} ->
   CArray Int CInt {- ^ indxq -} ->
   IO (Int, Float, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int Float, CArray Int CInt, CArray Int CInt, CArray Int CInt, Int, CArray (Int,Int) CInt, CArray (Int,Int) Float, Int)
laed8 qsiz q d rho cutpnt z ldq2 indxq = do
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   dDim0 <- Call.sizes1 <$> getBounds d
   let zDim0 = Call.sizes1 $ bounds z
   let indxqDim0 = Call.sizes1 $ bounds indxq
   let n = qDim0
   let ldq = qDim1
   Call.assert "laed8: n == dDim0" (n == dDim0)
   Call.assert "laed8: n == zDim0" (n == zDim0)
   Call.assert "laed8: n == indxqDim0" (n == indxqDim0)
   dlamda <- Call.newArray1 n
   q2 <- Call.newArray2 n ldq2
   w <- Call.newArray1 n
   indxp <- Call.newArray1 n
   indx <- Call.newArray1 n
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 n 2
   givnum <- Call.newArray2 n 2
   evalContT $ do
      kPtr <- Call.alloca
      nPtr <- Call.cint n
      qsizPtr <- Call.cint qsiz
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      dPtr <- Call.ioarray d
      rhoPtr <- Call.float rho
      cutpntPtr <- Call.cint cutpnt
      zPtr <- Call.array z
      dlamdaPtr <- Call.ioarray dlamda
      q2Ptr <- Call.ioarray q2
      ldq2Ptr <- Call.cint ldq2
      wPtr <- Call.ioarray w
      indxpPtr <- Call.ioarray indxp
      indxPtr <- Call.ioarray indx
      indxqPtr <- Call.array indxq
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      givnumPtr <- Call.ioarray givnum
      infoPtr <- Call.alloca
      liftIO $ FFI.laed8 kPtr nPtr qsizPtr qPtr ldqPtr dPtr rhoPtr cutpntPtr zPtr dlamdaPtr q2Ptr ldq2Ptr wPtr indxpPtr indxPtr indxqPtr permPtr givptrPtr givcolPtr givnumPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> peek rhoPtr
         <*> Call.freezeArray dlamda
         <*> Call.freezeArray q2
         <*> Call.freezeArray w
         <*> Call.freezeArray indxp
         <*> Call.freezeArray indx
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claein.f>
laein ::
   Bool {- ^ rightv -} ->
   Bool {- ^ noinit -} ->
   CArray (Int,Int) (Complex Float) {- ^ h -} ->
   Complex Float {- ^ w -} ->
   IOCArray Int (Complex Float) {- ^ v -} ->
   Int {- ^ ldb -} ->
   Float {- ^ eps3 -} ->
   Float {- ^ smlnum -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
laein rightv noinit h w v ldb eps3 smlnum = do
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   vDim0 <- Call.sizes1 <$> getBounds v
   let n = hDim0
   let ldh = hDim1
   Call.assert "laein: n == vDim0" (n == vDim0)
   b <- Call.newArray2 n ldb
   rwork <- Call.newArray1 n
   evalContT $ do
      rightvPtr <- Call.bool rightv
      noinitPtr <- Call.bool noinit
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.complexFloat w
      vPtr <- Call.ioarray v
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      rworkPtr <- Call.ioarray rwork
      eps3Ptr <- Call.float eps3
      smlnumPtr <- Call.float smlnum
      infoPtr <- Call.alloca
      liftIO $ FFI.laein rightvPtr noinitPtr nPtr hPtr ldhPtr wPtr vPtr bPtr ldbPtr rworkPtr eps3Ptr smlnumPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray b
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claesy.f>
laesy ::
   Complex Float {- ^ a -} ->
   Complex Float {- ^ b -} ->
   Complex Float {- ^ c -} ->
   IO (Complex Float, Complex Float, Complex Float, Complex Float, Complex Float)
laesy a b c = do
   evalContT $ do
      aPtr <- Call.complexFloat a
      bPtr <- Call.complexFloat b
      cPtr <- Call.complexFloat c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      evscalPtr <- Call.alloca
      cs1Ptr <- Call.alloca
      sn1Ptr <- Call.alloca
      liftIO $ FFI.laesy aPtr bPtr cPtr rt1Ptr rt2Ptr evscalPtr cs1Ptr sn1Ptr
      liftIO $ pure (,,,,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr
         <*> peek evscalPtr
         <*> peek cs1Ptr
         <*> peek sn1Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claev2.f>
laev2 ::
   Complex Float {- ^ a -} ->
   Complex Float {- ^ b -} ->
   Complex Float {- ^ c -} ->
   IO (Float, Float, Float, Complex Float)
laev2 a b c = do
   evalContT $ do
      aPtr <- Call.complexFloat a
      bPtr <- Call.complexFloat b
      cPtr <- Call.complexFloat c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      cs1Ptr <- Call.alloca
      sn1Ptr <- Call.alloca
      liftIO $ FFI.laev2 aPtr bPtr cPtr rt1Ptr rt2Ptr cs1Ptr sn1Ptr
      liftIO $ pure (,,,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr
         <*> peek cs1Ptr
         <*> peek sn1Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clag2z.f>
lag2z ::
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ sa -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) (Complex Double), Int)
lag2z m sa lda = do
   let (saDim0,saDim1) = Call.sizes2 $ bounds sa
   let n = saDim0
   let ldsa = saDim1
   a <- Call.newArray2 n lda
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      saPtr <- Call.array sa
      ldsaPtr <- Call.cint ldsa
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lag2z mPtr nPtr saPtr ldsaPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clags2.f>
lags2 ::
   Bool {- ^ upper -} ->
   Float {- ^ a1 -} ->
   Complex Float {- ^ a2 -} ->
   Float {- ^ a3 -} ->
   Float {- ^ b1 -} ->
   Complex Float {- ^ b2 -} ->
   Float {- ^ b3 -} ->
   IO (Float, Complex Float, Float, Complex Float, Float, Complex Float)
lags2 upper a1 a2 a3 b1 b2 b3 = do
   evalContT $ do
      upperPtr <- Call.bool upper
      a1Ptr <- Call.float a1
      a2Ptr <- Call.complexFloat a2
      a3Ptr <- Call.float a3
      b1Ptr <- Call.float b1
      b2Ptr <- Call.complexFloat b2
      b3Ptr <- Call.float b3
      csuPtr <- Call.alloca
      snuPtr <- Call.alloca
      csvPtr <- Call.alloca
      snvPtr <- Call.alloca
      csqPtr <- Call.alloca
      snqPtr <- Call.alloca
      liftIO $ FFI.lags2 upperPtr a1Ptr a2Ptr a3Ptr b1Ptr b2Ptr b3Ptr csuPtr snuPtr csvPtr snvPtr csqPtr snqPtr
      liftIO $ pure (,,,,,)
         <*> peek csuPtr
         <*> peek snuPtr
         <*> peek csvPtr
         <*> peek snvPtr
         <*> peek csqPtr
         <*> peek snqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clagtm.f>
lagtm ::
   Char {- ^ trans -} ->
   Float {- ^ alpha -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   CArray (Int,Int) (Complex Float) {- ^ x -} ->
   Float {- ^ beta -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO ()
lagtm trans alpha dl d du x beta b = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = xDim0
   let ldx = xDim1
   let ldb = bDim1
   Call.assert "lagtm: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "lagtm: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "lagtm: nrhs == bDim0" (nrhs == bDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      alphaPtr <- Call.float alpha
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      betaPtr <- Call.float beta
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lagtm transPtr nPtr nrhsPtr alphaPtr dlPtr dPtr duPtr xPtr ldxPtr betaPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clahef.f>
lahef ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (Int, CArray Int CInt, CArray (Int,Int) (Complex Float), Int)
lahef uplo nb a ldw = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      infoPtr <- Call.alloca
      liftIO $ FFI.lahef uploPtr nPtr nbPtr kbPtr aPtr ldaPtr ipivPtr wPtr ldwPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clahqr.f>
lahqr ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   IO (CArray Int (Complex Float), Int)
lahqr wantt wantz ilo ihi h iloz ihiz z = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "lahqr: n == zDim0" (n == zDim0)
   w <- Call.newArray1 n
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.ioarray w
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.lahqr wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wPtr ilozPtr ihizPtr zPtr ldzPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clahr2.f>
lahr2 ::
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldt -} ->
   Int {- ^ ldy -} ->
   IO (CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float))
lahr2 n k nb a ldt ldy = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let lda = aDim1
   Call.assert "lahr2: n-k+1 == aDim0" (n-k+1 == aDim0)
   tau <- Call.newArray1 nb
   t <- Call.newArray2 nb ldt
   y <- Call.newArray2 nb ldy
   evalContT $ do
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.lahr2 nPtr kPtr nbPtr aPtr ldaPtr tauPtr tPtr ldtPtr yPtr ldyPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray tau
         <*> Call.freezeArray t
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claic1.f>
laic1 ::
   Int {- ^ job -} ->
   CArray Int (Complex Float) {- ^ x -} ->
   Float {- ^ sest -} ->
   CArray Int (Complex Float) {- ^ w -} ->
   Complex Float {- ^ gamma -} ->
   IO (Float, Complex Float, Complex Float)
laic1 job x sest w gamma = do
   let xDim0 = Call.sizes1 $ bounds x
   let wDim0 = Call.sizes1 $ bounds w
   let j = xDim0
   Call.assert "laic1: j == wDim0" (j == wDim0)
   evalContT $ do
      jobPtr <- Call.cint job
      jPtr <- Call.cint j
      xPtr <- Call.array x
      sestPtr <- Call.float sest
      wPtr <- Call.array w
      gammaPtr <- Call.complexFloat gamma
      sestprPtr <- Call.alloca
      sPtr <- Call.alloca
      cPtr <- Call.alloca
      liftIO $ FFI.laic1 jobPtr jPtr xPtr sestPtr wPtr gammaPtr sestprPtr sPtr cPtr
      liftIO $ pure (,,)
         <*> peek sestprPtr
         <*> peek sPtr
         <*> peek cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clals0.f>
lals0 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldbx -} ->
   CArray Int CInt {- ^ perm -} ->
   Int {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) Float {- ^ givnum -} ->
   CArray (Int,Int) Float {- ^ poles -} ->
   CArray Int Float {- ^ difl -} ->
   CArray (Int,Int) Float {- ^ difr -} ->
   CArray Int Float {- ^ z -} ->
   Float {- ^ c -} ->
   Float {- ^ s -} ->
   Int {- ^ rworkSize -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
lals0 icompq nl nr sqre b ldbx perm givptr givcol givnum poles difl difr z c s rworkSize = do
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let permDim0 = Call.sizes1 $ bounds perm
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let (polesDim0,polesDim1) = Call.sizes2 $ bounds poles
   let diflDim0 = Call.sizes1 $ bounds difl
   let (difrDim0,difrDim1) = Call.sizes2 $ bounds difr
   let zDim0 = Call.sizes1 $ bounds z
   let nrhs = bDim0
   let ldb = bDim1
   let _n = permDim0
   let ldgcol = givcolDim1
   let ldgnum = givnumDim1
   let k = diflDim0
   Call.assert "lals0: 2 == givcolDim0" (2 == givcolDim0)
   Call.assert "lals0: 2 == givnumDim0" (2 == givnumDim0)
   Call.assert "lals0: 2 == polesDim0" (2 == polesDim0)
   Call.assert "lals0: ldgnum == polesDim1" (ldgnum == polesDim1)
   Call.assert "lals0: 2 == difrDim0" (2 == difrDim0)
   Call.assert "lals0: ldgnum == difrDim1" (ldgnum == difrDim1)
   Call.assert "lals0: k == zDim0" (k == zDim0)
   bx <- Call.newArray2 nrhs ldbx
   rwork <- Call.newArray1 rworkSize
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      permPtr <- Call.array perm
      givptrPtr <- Call.cint givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.array givnum
      ldgnumPtr <- Call.cint ldgnum
      polesPtr <- Call.array poles
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      kPtr <- Call.cint k
      cPtr <- Call.float c
      sPtr <- Call.float s
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lals0 icompqPtr nlPtr nrPtr sqrePtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr polesPtr diflPtr difrPtr zPtr kPtr cPtr sPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clalsa.f>
lalsa ::
   Int {- ^ icompq -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldbx -} ->
   CArray (Int,Int) Float {- ^ u -} ->
   CArray (Int,Int) Float {- ^ vt -} ->
   CArray Int CInt {- ^ k -} ->
   CArray (Int,Int) Float {- ^ difl -} ->
   CArray (Int,Int) Float {- ^ difr -} ->
   CArray (Int,Int) Float {- ^ z -} ->
   CArray (Int,Int) Float {- ^ poles -} ->
   CArray Int CInt {- ^ givptr -} ->
   CArray (Int,Int) CInt {- ^ givcol -} ->
   CArray (Int,Int) CInt {- ^ perm -} ->
   CArray (Int,Int) Float {- ^ givnum -} ->
   CArray Int Float {- ^ c -} ->
   CArray Int Float {- ^ s -} ->
   Int {- ^ rworkSize -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
lalsa icompq b ldbx u vt k difl difr z poles givptr givcol perm givnum c s rworkSize = do
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let (uDim0,uDim1) = Call.sizes2 $ bounds u
   let (vtDim0,vtDim1) = Call.sizes2 $ bounds vt
   let kDim0 = Call.sizes1 $ bounds k
   let (diflDim0,diflDim1) = Call.sizes2 $ bounds difl
   let (difrDim0,difrDim1) = Call.sizes2 $ bounds difr
   let (zDim0,zDim1) = Call.sizes2 $ bounds z
   let (polesDim0,polesDim1) = Call.sizes2 $ bounds poles
   let givptrDim0 = Call.sizes1 $ bounds givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ bounds givcol
   let (permDim0,permDim1) = Call.sizes2 $ bounds perm
   let (givnumDim0,givnumDim1) = Call.sizes2 $ bounds givnum
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   let nrhs = bDim0
   let ldb = bDim1
   let smlsiz = uDim0
   let ldu = uDim1
   let n = kDim0
   let nlvl = diflDim0
   let ldgcol = givcolDim1
   Call.assert "lalsa: smlsiz+1 == vtDim0" (smlsiz+1 == vtDim0)
   Call.assert "lalsa: ldu == vtDim1" (ldu == vtDim1)
   Call.assert "lalsa: ldu == diflDim1" (ldu == diflDim1)
   Call.assert "lalsa: 2*nlvl == difrDim0" (2*nlvl == difrDim0)
   Call.assert "lalsa: ldu == difrDim1" (ldu == difrDim1)
   Call.assert "lalsa: nlvl == zDim0" (nlvl == zDim0)
   Call.assert "lalsa: ldu == zDim1" (ldu == zDim1)
   Call.assert "lalsa: 2*nlvl == polesDim0" (2*nlvl == polesDim0)
   Call.assert "lalsa: ldu == polesDim1" (ldu == polesDim1)
   Call.assert "lalsa: n == givptrDim0" (n == givptrDim0)
   Call.assert "lalsa: 2*nlvl == givcolDim0" (2*nlvl == givcolDim0)
   Call.assert "lalsa: nlvl == permDim0" (nlvl == permDim0)
   Call.assert "lalsa: ldgcol == permDim1" (ldgcol == permDim1)
   Call.assert "lalsa: 2*nlvl == givnumDim0" (2*nlvl == givnumDim0)
   Call.assert "lalsa: ldu == givnumDim1" (ldu == givnumDim1)
   Call.assert "lalsa: n == cDim0" (n == cDim0)
   Call.assert "lalsa: n == sDim0" (n == sDim0)
   bx <- Call.newArray2 nrhs ldbx
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      uPtr <- Call.array u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.array vt
      kPtr <- Call.array k
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      polesPtr <- Call.array poles
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      permPtr <- Call.array perm
      givnumPtr <- Call.array givnum
      cPtr <- Call.array c
      sPtr <- Call.array s
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsa icompqPtr smlsizPtr nPtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr uPtr lduPtr vtPtr kPtr diflPtr difrPtr zPtr polesPtr givptrPtr givcolPtr ldgcolPtr permPtr givnumPtr cPtr sPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clalsd.f>
lalsd ::
   Char {- ^ uplo -} ->
   Int {- ^ smlsiz -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ rworkSize -} ->
   Int {- ^ nlvl -} ->
   IO (Int, Int)
lalsd uplo smlsiz d e b rcond rworkSize nlvl = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "lalsd: n-1 == eDim0" (n-1 == eDim0)
   work <- Call.newArray1 (n*nrhs)
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (3*n*nlvl+11*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsd uploPtr smlsizPtr nPtr nrhsPtr dPtr ePtr bPtr ldbPtr rcondPtr rankPtr workPtr rworkPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clangb.f>
langb ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
langb norm kl ku ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.langb normPtr nPtr klPtr kuPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clange.f>
lange ::
   Char {- ^ norm -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lange norm m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lange normPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clangt.f>
langt ::
   Char {- ^ norm -} ->
   CArray Int (Complex Float) {- ^ dl -} ->
   CArray Int (Complex Float) {- ^ d -} ->
   CArray Int (Complex Float) {- ^ du -} ->
   IO Float
langt norm dl d du = do
   let dlDim0 = Call.sizes1 $ bounds dl
   let dDim0 = Call.sizes1 $ bounds d
   let duDim0 = Call.sizes1 $ bounds du
   let n = dDim0
   Call.assert "langt: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "langt: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      liftIO $ FFI.langt normPtr nPtr dlPtr dPtr duPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanhb.f>
lanhb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhb norm uplo k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhb normPtr uploPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanhe.f>
lanhe ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhe norm uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhe normPtr uploPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanhf.f>
lanhf ::
   Char {- ^ norm -} ->
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhf norm transr uplo n a lwork = do
   let aDim0 = Call.sizes1 $ bounds a
   Call.assert "lanhf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   work <- Call.newArray1 lwork
   evalContT $ do
      normPtr <- Call.char norm
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhf normPtr transrPtr uploPtr nPtr aPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanhp.f>
lanhp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhp norm uplo n ap lwork = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "lanhp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhp normPtr uploPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanhs.f>
lanhs ::
   Char {- ^ norm -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhs norm a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhs normPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clanht.f>
lanht ::
   Char {- ^ norm -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   IO Float
lanht norm d e = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "lanht: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      liftIO $ FFI.lanht normPtr nPtr dPtr ePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clansb.f>
lansb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
lansb norm uplo k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansb normPtr uploPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clansp.f>
lansp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Float
lansp norm uplo n ap lwork = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "lansp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansp normPtr uploPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clansy.f>
lansy ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lansy norm uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansy normPtr uploPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clantb.f>
lantb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
lantb norm uplo diag k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantb normPtr uploPtr diagPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clantp.f>
lantp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Float
lantp norm uplo diag n ap lwork = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "lantp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantp normPtr uploPtr diagPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clantr.f>
lantr ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lantr norm uplo diag m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantr normPtr uploPtr diagPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clapll.f>
lapll ::
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   Int {- ^ incy -} ->
   IO (Float)
lapll n x incx y incy = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   Call.assert "lapll: 1+(n-1)*incx == xDim0" (1+(n-1)*incx == xDim0)
   Call.assert "lapll: 1+(n-1)*incy == yDim0" (1+(n-1)*incy == yDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      ssminPtr <- Call.alloca
      liftIO $ FFI.lapll nPtr xPtr incxPtr yPtr incyPtr ssminPtr
      liftIO $ peek ssminPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clapmr.f>
lapmr ::
   Bool {- ^ forwrd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IOCArray Int CInt {- ^ k -} ->
   IO ()
lapmr forwrd x k = do
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   kDim0 <- Call.sizes1 <$> getBounds k
   let n = xDim0
   let ldx = xDim1
   let m = kDim0
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmr forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clapmt.f>
lapmt ::
   Bool {- ^ forwrd -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IOCArray Int CInt {- ^ k -} ->
   IO ()
lapmt forwrd m x k = do
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   kDim0 <- Call.sizes1 <$> getBounds k
   let n = xDim0
   let ldx = xDim1
   Call.assert "lapmt: n == kDim0" (n == kDim0)
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmt forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqgb.f>
laqgb ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray Int Float {- ^ r -} ->
   CArray Int Float {- ^ c -} ->
   Float {- ^ rowcnd -} ->
   Float {- ^ colcnd -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqgb kl ku ab r c rowcnd colcnd amax = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let rDim0 = Call.sizes1 $ bounds r
   let cDim0 = Call.sizes1 $ bounds c
   let n = abDim0
   let ldab = abDim1
   let m = rDim0
   Call.assert "laqgb: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.float rowcnd
      colcndPtr <- Call.float colcnd
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqgb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqge.f>
laqge ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int Float {- ^ r -} ->
   CArray Int Float {- ^ c -} ->
   Float {- ^ rowcnd -} ->
   Float {- ^ colcnd -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqge a r c rowcnd colcnd amax = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let rDim0 = Call.sizes1 $ bounds r
   let cDim0 = Call.sizes1 $ bounds c
   let n = aDim0
   let lda = aDim1
   let m = rDim0
   Call.assert "laqge: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.float rowcnd
      colcndPtr <- Call.float colcnd
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqge mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqhb.f>
laqhb ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (CArray Int Float, Char)
laqhb uplo kd ab scond amax = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.ioarray s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqhb uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ pure (,)
         <*> Call.freezeArray s
         <*> fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqhe.f>
laqhe ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqhe uplo a s scond amax = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let sDim0 = Call.sizes1 $ bounds s
   let n = aDim0
   let lda = aDim1
   Call.assert "laqhe: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqhe uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqhp.f>
laqhp ::
   Char {- ^ uplo -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   CArray Int Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqhp uplo ap s scond amax = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let sDim0 = Call.sizes1 $ bounds s
   let n = sDim0
   Call.assert "laqhp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqhp uploPtr nPtr apPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqp2.f>
laqp2 ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   IOCArray Int Float {- ^ vn1 -} ->
   IOCArray Int Float {- ^ vn2 -} ->
   IO (CArray Int (Complex Float))
laqp2 m offset a jpvt vn1 vn2 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   vn1Dim0 <- Call.sizes1 <$> getBounds vn1
   vn2Dim0 <- Call.sizes1 <$> getBounds vn2
   let n = aDim0
   let lda = aDim1
   Call.assert "laqp2: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqp2: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqp2: n == vn2Dim0" (n == vn2Dim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      workPtr <- Call.ioarray work
      liftIO $ FFI.laqp2 mPtr nPtr offsetPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqps.f>
laqps ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray Int CInt {- ^ jpvt -} ->
   Int {- ^ kb -} ->
   IOCArray Int Float {- ^ vn1 -} ->
   IOCArray Int Float {- ^ vn2 -} ->
   IOCArray Int (Complex Float) {- ^ auxv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ f -} ->
   IO (Int, CArray Int (Complex Float))
laqps m offset a jpvt kb vn1 vn2 auxv f = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   jpvtDim0 <- Call.sizes1 <$> getBounds jpvt
   vn1Dim0 <- Call.sizes1 <$> getBounds vn1
   vn2Dim0 <- Call.sizes1 <$> getBounds vn2
   auxvDim0 <- Call.sizes1 <$> getBounds auxv
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let n = aDim0
   let lda = aDim1
   let nb = auxvDim0
   let ldf = fDim1
   Call.assert "laqps: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqps: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqps: n == vn2Dim0" (n == vn2Dim0)
   Call.assert "laqps: nb == fDim0" (nb == fDim0)
   tau <- Call.newArray1 kb
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      auxvPtr <- Call.ioarray auxv
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      liftIO $ FFI.laqps mPtr nPtr offsetPtr nbPtr kbPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr auxvPtr fPtr ldfPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr0.f>
laqr0 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
laqr0 wantt wantz ilo h iloz ihiz z workSize lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.ioarray w
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr0 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr1.f>
laqr1 ::
   CArray (Int,Int) (Complex Float) {- ^ h -} ->
   Complex Float {- ^ s1 -} ->
   Complex Float {- ^ s2 -} ->
   IO (CArray Int (Complex Float))
laqr1 h s1 s2 = do
   let (hDim0,hDim1) = Call.sizes2 $ bounds h
   let n = hDim0
   let ldh = hDim1
   v <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      s1Ptr <- Call.complexFloat s1
      s2Ptr <- Call.complexFloat s2
      vPtr <- Call.ioarray v
      liftIO $ FFI.laqr1 nPtr hPtr ldhPtr s1Ptr s2Ptr vPtr
      liftIO $ Call.freezeArray v

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr2.f>
laqr2 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float))
laqr2 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr2: n == zDim0" (n == zDim0)
   sh <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      shPtr <- Call.ioarray sh
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr2 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr shPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sh
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr3.f>
laqr3 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, CArray Int (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float))
laqr3 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr3: n == zDim0" (n == zDim0)
   sh <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      shPtr <- Call.ioarray sh
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr3 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr shPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sh
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr4.f>
laqr4 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
laqr4 wantt wantz ilo h iloz ihiz z workSize lwork = do
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wPtr <- Call.ioarray w
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr4 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqr5.f>
laqr5 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ kacc22 -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   IOCArray Int (Complex Float) {- ^ s -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ h -} ->
   Int {- ^ iloz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ ldu -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldwh -} ->
   IO (CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float))
laqr5 wantt wantz kacc22 ktop kbot s h iloz z ldv ldu nv ldwv nh ldwh = do
   sDim0 <- Call.sizes1 <$> getBounds s
   (hDim0,hDim1) <- Call.sizes2 <$> getBounds h
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let nshfts = sDim0
   let n = hDim0
   let ldh = hDim1
   let ihiz = zDim0
   let ldz = zDim1
   v <- Call.newArray2 (nshfts`div`2) ldv
   u <- Call.newArray2 (3*nshfts-3) ldu
   wv <- Call.newArray2 (3*nshfts-3) ldwv
   wh <- Call.newArray2 nh ldwh
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      kacc22Ptr <- Call.cint kacc22
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nshftsPtr <- Call.cint nshfts
      sPtr <- Call.ioarray s
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      nhPtr <- Call.cint nh
      whPtr <- Call.ioarray wh
      ldwhPtr <- Call.cint ldwh
      liftIO $ FFI.laqr5 wanttPtr wantzPtr kacc22Ptr nPtr ktopPtr kbotPtr nshftsPtr sPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr vPtr ldvPtr uPtr lduPtr nvPtr wvPtr ldwvPtr nhPtr whPtr ldwhPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray u
         <*> Call.freezeArray wv
         <*> Call.freezeArray wh

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqsb.f>
laqsb ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray Int Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsb uplo kd ab s scond amax = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let sDim0 = Call.sizes1 $ bounds s
   let n = abDim0
   let ldab = abDim1
   Call.assert "laqsb: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsb uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqsp.f>
laqsp ::
   Char {- ^ uplo -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   CArray Int Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsp uplo ap s scond amax = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let sDim0 = Call.sizes1 $ bounds s
   let n = sDim0
   Call.assert "laqsp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsp uploPtr nPtr apPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqsy.f>
laqsy ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsy uplo a s scond amax = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let sDim0 = Call.sizes1 $ bounds s
   let n = aDim0
   let lda = aDim1
   Call.assert "laqsy: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsy uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clar1v.f>
lar1v ::
   Int {- ^ b1 -} ->
   Int {- ^ bn -} ->
   Float {- ^ lambda -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int Float {- ^ l -} ->
   CArray Int Float {- ^ ld -} ->
   CArray Int Float {- ^ lld -} ->
   Float {- ^ pivmin -} ->
   Float {- ^ gaptol -} ->
   IOCArray Int (Complex Float) {- ^ z -} ->
   Bool {- ^ wantnc -} ->
   Int {- ^ r -} ->
   IO (Int, Float, Float, Int, CArray Int CInt, Float, Float, Float)
lar1v b1 bn lambda d l ld lld pivmin gaptol z wantnc r = do
   let dDim0 = Call.sizes1 $ bounds d
   let lDim0 = Call.sizes1 $ bounds l
   let ldDim0 = Call.sizes1 $ bounds ld
   let lldDim0 = Call.sizes1 $ bounds lld
   zDim0 <- Call.sizes1 <$> getBounds z
   let n = dDim0
   Call.assert "lar1v: n-1 == lDim0" (n-1 == lDim0)
   Call.assert "lar1v: n-1 == ldDim0" (n-1 == ldDim0)
   Call.assert "lar1v: n-1 == lldDim0" (n-1 == lldDim0)
   Call.assert "lar1v: n == zDim0" (n == zDim0)
   isuppz <- Call.newArray1 2
   work <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      b1Ptr <- Call.cint b1
      bnPtr <- Call.cint bn
      lambdaPtr <- Call.float lambda
      dPtr <- Call.array d
      lPtr <- Call.array l
      ldPtr <- Call.array ld
      lldPtr <- Call.array lld
      pivminPtr <- Call.float pivmin
      gaptolPtr <- Call.float gaptol
      zPtr <- Call.ioarray z
      wantncPtr <- Call.bool wantnc
      negcntPtr <- Call.alloca
      ztzPtr <- Call.alloca
      mingmaPtr <- Call.alloca
      rPtr <- Call.cint r
      isuppzPtr <- Call.ioarray isuppz
      nrminvPtr <- Call.alloca
      residPtr <- Call.alloca
      rqcorrPtr <- Call.alloca
      workPtr <- Call.ioarray work
      liftIO $ FFI.lar1v nPtr b1Ptr bnPtr lambdaPtr dPtr lPtr ldPtr lldPtr pivminPtr gaptolPtr zPtr wantncPtr negcntPtr ztzPtr mingmaPtr rPtr isuppzPtr nrminvPtr residPtr rqcorrPtr workPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek negcntPtr)
         <*> peek ztzPtr
         <*> peek mingmaPtr
         <*> fmap fromIntegral (peek rPtr)
         <*> Call.freezeArray isuppz
         <*> peek nrminvPtr
         <*> peek residPtr
         <*> peek rqcorrPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clar2v.f>
lar2v ::
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   IOCArray Int (Complex Float) {- ^ z -} ->
   Int {- ^ incx -} ->
   CArray Int Float {- ^ c -} ->
   CArray Int (Complex Float) {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lar2v n x y z incx c s incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   zDim0 <- Call.sizes1 <$> getBounds z
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   Call.assert "lar2v: 1+(n-1)*incx == xDim0" (1+(n-1)*incx == xDim0)
   Call.assert "lar2v: 1+(n-1)*incx == yDim0" (1+(n-1)*incx == yDim0)
   Call.assert "lar2v: 1+(n-1)*incx == zDim0" (1+(n-1)*incx == zDim0)
   Call.assert "lar2v: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lar2v: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      zPtr <- Call.ioarray z
      incxPtr <- Call.cint incx
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lar2v nPtr xPtr yPtr zPtr incxPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarcm.f>
larcm ::
   CArray (Int,Int) Float {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldc -} ->
   IO (CArray (Int,Int) (Complex Float))
larcm a b ldc = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   c <- Call.newArray2 n ldc
   rwork <- Call.newArray1 (2*m*n)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      rworkPtr <- Call.ioarray rwork
      liftIO $ FFI.larcm mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr rworkPtr
      liftIO $ Call.freezeArray c

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarf.f>
larf ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   CArray Int (Complex Float) {- ^ v -} ->
   Int {- ^ incv -} ->
   Complex Float {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larf side m v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.complexFloat tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larf sidePtr mPtr nPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarfb.f>
larfb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ v -} ->
   CArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larfb side trans direct storev m v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larfb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarfg.f>
larfg ::
   Int {- ^ n -} ->
   Complex Float {- ^ alpha -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Complex Float, Complex Float)
larfg n alpha x incx = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfg nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarfgp.f>
larfgp ::
   Int {- ^ n -} ->
   Complex Float {- ^ alpha -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Complex Float, Complex Float)
larfgp n alpha x incx = do
   xDim0 <- Call.sizes1 <$> getBounds x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfgp nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarft.f>
larft ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   CArray (Int,Int) (Complex Float) {- ^ v -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (CArray (Int,Int) (Complex Float))
larft direct storev n v tau ldt = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let tauDim0 = Call.sizes1 $ bounds tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larft directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarfx.f>
larfx ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   CArray Int (Complex Float) {- ^ v -} ->
   Complex Float {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larfx side m v tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      tauPtr <- Call.complexFloat tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larfx sidePtr mPtr nPtr vPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clargv.f>
largv ::
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   Int {- ^ incy -} ->
   Int {- ^ incc -} ->
   IO (CArray Int Float)
largv n x incx y incy incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   Call.assert "largv: 1+(n-1)*incx == xDim0" (1+(n-1)*incx == xDim0)
   Call.assert "largv: 1+(n-1)*incy == yDim0" (1+(n-1)*incy == yDim0)
   c <- Call.newArray1 (1+(n-1)*incc)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.ioarray c
      inccPtr <- Call.cint incc
      liftIO $ FFI.largv nPtr xPtr incxPtr yPtr incyPtr cPtr inccPtr
      liftIO $ Call.freezeArray c

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarnv.f>
larnv ::
   Int {- ^ idist -} ->
   IOCArray Int CInt {- ^ iseed -} ->
   Int {- ^ n -} ->
   IO (CArray Int (Complex Float))
larnv idist iseed n = do
   iseedDim0 <- Call.sizes1 <$> getBounds iseed
   Call.assert "larnv: 4 == iseedDim0" (4 == iseedDim0)
   x <- Call.newArray1 n
   evalContT $ do
      idistPtr <- Call.cint idist
      iseedPtr <- Call.ioarray iseed
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      liftIO $ FFI.larnv idistPtr iseedPtr nPtr xPtr
      liftIO $ Call.freezeArray x

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarrv.f>
larrv ::
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ l -} ->
   Float {- ^ pivmin -} ->
   CArray Int CInt {- ^ isplit -} ->
   Int {- ^ m -} ->
   Int {- ^ dol -} ->
   Int {- ^ dou -} ->
   Float {- ^ minrgp -} ->
   Float {- ^ rtol1 -} ->
   Float {- ^ rtol2 -} ->
   IOCArray Int Float {- ^ w -} ->
   IOCArray Int Float {- ^ werr -} ->
   IOCArray Int Float {- ^ wgap -} ->
   CArray Int CInt {- ^ iblock -} ->
   CArray Int CInt {- ^ indexw -} ->
   CArray Int Float {- ^ gers -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
larrv vl vu d l pivmin isplit m dol dou minrgp rtol1 rtol2 w werr wgap iblock indexw gers ldz = do
   dDim0 <- Call.sizes1 <$> getBounds d
   lDim0 <- Call.sizes1 <$> getBounds l
   let isplitDim0 = Call.sizes1 $ bounds isplit
   wDim0 <- Call.sizes1 <$> getBounds w
   werrDim0 <- Call.sizes1 <$> getBounds werr
   wgapDim0 <- Call.sizes1 <$> getBounds wgap
   let iblockDim0 = Call.sizes1 $ bounds iblock
   let indexwDim0 = Call.sizes1 $ bounds indexw
   let gersDim0 = Call.sizes1 $ bounds gers
   let n = dDim0
   Call.assert "larrv: n == lDim0" (n == lDim0)
   Call.assert "larrv: n == isplitDim0" (n == isplitDim0)
   Call.assert "larrv: n == wDim0" (n == wDim0)
   Call.assert "larrv: n == werrDim0" (n == werrDim0)
   Call.assert "larrv: n == wgapDim0" (n == wgapDim0)
   Call.assert "larrv: n == iblockDim0" (n == iblockDim0)
   Call.assert "larrv: n == indexwDim0" (n == indexwDim0)
   Call.assert "larrv: 2*n == gersDim0" (2*n == gersDim0)
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (12*n)
   iwork <- Call.newArray1 (7*n)
   evalContT $ do
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      dPtr <- Call.ioarray d
      lPtr <- Call.ioarray l
      pivminPtr <- Call.float pivmin
      isplitPtr <- Call.array isplit
      mPtr <- Call.cint m
      dolPtr <- Call.cint dol
      douPtr <- Call.cint dou
      minrgpPtr <- Call.float minrgp
      rtol1Ptr <- Call.float rtol1
      rtol2Ptr <- Call.float rtol2
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wgapPtr <- Call.ioarray wgap
      iblockPtr <- Call.array iblock
      indexwPtr <- Call.array indexw
      gersPtr <- Call.array gers
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larrv nPtr vlPtr vuPtr dPtr lPtr pivminPtr isplitPtr mPtr dolPtr douPtr minrgpPtr rtol1Ptr rtol2Ptr wPtr werrPtr wgapPtr iblockPtr indexwPtr gersPtr zPtr ldzPtr isuppzPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clartg.f>
lartg ::
   Complex Float {- ^ f -} ->
   Complex Float {- ^ g -} ->
   IO (Float, Complex Float, Complex Float)
lartg f g = do
   evalContT $ do
      fPtr <- Call.complexFloat f
      gPtr <- Call.complexFloat g
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      rPtr <- Call.alloca
      liftIO $ FFI.lartg fPtr gPtr csPtr snPtr rPtr
      liftIO $ pure (,,)
         <*> peek csPtr
         <*> peek snPtr
         <*> peek rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clartv.f>
lartv ::
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   Int {- ^ incy -} ->
   CArray Int Float {- ^ c -} ->
   CArray Int (Complex Float) {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lartv n x incx y incy c s incc = do
   xDim0 <- Call.sizes1 <$> getBounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   Call.assert "lartv: 1+(n-1)*incx == xDim0" (1+(n-1)*incx == xDim0)
   Call.assert "lartv: 1+(n-1)*incy == yDim0" (1+(n-1)*incy == yDim0)
   Call.assert "lartv: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lartv: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lartv nPtr xPtr incxPtr yPtr incyPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarz.f>
larz ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray Int (Complex Float) {- ^ v -} ->
   Int {- ^ incv -} ->
   Complex Float {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larz side m l v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ bounds v
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let n = cDim0
   let ldc = cDim1
   Call.assert "larz: 1+(l-1)*abs(incv) == vDim0" (1+(l-1)*abs(incv) == vDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.complexFloat tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larz sidePtr mPtr nPtr lPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarzb.f>
larzb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) (Complex Float) {- ^ v -} ->
   CArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larzb side trans direct storev m l v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ bounds v
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _nv = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larzb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr lPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clarzt.f>
larzt ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (CArray (Int,Int) (Complex Float))
larzt direct storev n v tau ldt = do
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   let tauDim0 = Call.sizes1 $ bounds tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larzt directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clascl.f>
lascl ::
   Char {- ^ type_ -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Float {- ^ cfrom -} ->
   Float {- ^ cto -} ->
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
lascl type_ kl ku cfrom cto m a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      type_Ptr <- Call.char type_
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      cfromPtr <- Call.float cfrom
      ctoPtr <- Call.float cto
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lascl type_Ptr klPtr kuPtr cfromPtr ctoPtr mPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claset.f>
laset ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Int {- ^ n -} ->
   Complex Float {- ^ alpha -} ->
   Complex Float {- ^ beta -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) (Complex Float))
laset uplo m n alpha beta lda = do
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      betaPtr <- Call.complexFloat beta
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.laset uploPtr mPtr nPtr alphaPtr betaPtr aPtr ldaPtr
      liftIO $ Call.freezeArray a

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clasr.f>
lasr ::
   Char {- ^ side -} ->
   Char {- ^ pivot -} ->
   Char {- ^ direct -} ->
   Int {- ^ m -} ->
   CArray Int Float {- ^ c -} ->
   CArray Int Float {- ^ s -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO ()
lasr side pivot direct m c s a = do
   let cDim0 = Call.sizes1 $ bounds c
   let sDim0 = Call.sizes1 $ bounds s
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let _cSize = cDim0
   let _sSize = sDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      sidePtr <- Call.char side
      pivotPtr <- Call.char pivot
      directPtr <- Call.char direct
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      cPtr <- Call.array c
      sPtr <- Call.array s
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.lasr sidePtr pivotPtr directPtr mPtr nPtr cPtr sPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/classq.f>
lassq ::
   CArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ scale -} ->
   Float {- ^ sumsq -} ->
   IO (Float, Float)
lassq x incx scale sumsq = do
   let xDim0 = Call.sizes1 $ bounds x
   let n = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      scalePtr <- Call.float scale
      sumsqPtr <- Call.float sumsq
      liftIO $ FFI.lassq nPtr xPtr incxPtr scalePtr sumsqPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> peek sumsqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claswp.f>
laswp ::
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ k1 -} ->
   Int {- ^ k2 -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ incx -} ->
   IO ()
laswp a k1 k2 ipiv incx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "laswp: k1+(k2-k1)*abs(incx) == ipivDim0" (k1+(k2-k1)*abs(incx) == ipivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      k1Ptr <- Call.cint k1
      k2Ptr <- Call.cint k2
      ipivPtr <- Call.array ipiv
      incxPtr <- Call.cint incx
      liftIO $ FFI.laswp nPtr aPtr ldaPtr k1Ptr k2Ptr ipivPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clasyf.f>
lasyf ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (Int, CArray Int CInt, CArray (Int,Int) (Complex Float), Int)
lasyf uplo nb a ldw = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      infoPtr <- Call.alloca
      liftIO $ FFI.lasyf uploPtr nPtr nbPtr kbPtr aPtr ldaPtr ipivPtr wPtr ldwPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatbs.f>
latbs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   IOCArray Int Float {- ^ cnorm -} ->
   IO (Float, Int)
latbs uplo trans diag normin kd ab x cnorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = abDim0
   let ldab = abDim1
   Call.assert "latbs: n == xDim0" (n == xDim0)
   Call.assert "latbs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latbs uploPtr transPtr diagPtr norminPtr nPtr kdPtr abPtr ldabPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatdf.f>
latdf ::
   Int {- ^ ijob -} ->
   CArray (Int,Int) (Complex Float) {- ^ z -} ->
   IOCArray Int (Complex Float) {- ^ rhs -} ->
   Float {- ^ rdsum -} ->
   Float {- ^ rdscal -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray Int CInt {- ^ jpiv -} ->
   IO (Float, Float)
latdf ijob z rhs rdsum rdscal ipiv jpiv = do
   let (zDim0,zDim1) = Call.sizes2 $ bounds z
   rhsDim0 <- Call.sizes1 <$> getBounds rhs
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let jpivDim0 = Call.sizes1 $ bounds jpiv
   let n = zDim0
   let ldz = zDim1
   Call.assert "latdf: n == rhsDim0" (n == rhsDim0)
   Call.assert "latdf: n == ipivDim0" (n == ipivDim0)
   Call.assert "latdf: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      ijobPtr <- Call.cint ijob
      nPtr <- Call.cint n
      zPtr <- Call.array z
      ldzPtr <- Call.cint ldz
      rhsPtr <- Call.ioarray rhs
      rdsumPtr <- Call.float rdsum
      rdscalPtr <- Call.float rdscal
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      liftIO $ FFI.latdf ijobPtr nPtr zPtr ldzPtr rhsPtr rdsumPtr rdscalPtr ipivPtr jpivPtr
      liftIO $ pure (,)
         <*> peek rdsumPtr
         <*> peek rdscalPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatps.f>
latps ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   IOCArray Int Float {- ^ cnorm -} ->
   IO (Float, Int)
latps uplo trans diag normin ap x cnorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = xDim0
   Call.assert "latps: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "latps: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latps uploPtr transPtr diagPtr norminPtr nPtr apPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatrd.f>
latrd ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (CArray Int Float, CArray Int (Complex Float), CArray (Int,Int) (Complex Float))
latrd uplo nb a ldw = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      liftIO $ FFI.latrd uploPtr nPtr nbPtr aPtr ldaPtr ePtr tauPtr wPtr ldwPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> Call.freezeArray w

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatrs.f>
latrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray Int (Complex Float) {- ^ x -} ->
   IOCArray Int Float {- ^ cnorm -} ->
   IO (Float, Int)
latrs uplo trans diag normin a x cnorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   xDim0 <- Call.sizes1 <$> getBounds x
   cnormDim0 <- Call.sizes1 <$> getBounds cnorm
   let n = aDim0
   let lda = aDim1
   Call.assert "latrs: n == xDim0" (n == xDim0)
   Call.assert "latrs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latrs uploPtr transPtr diagPtr norminPtr nPtr aPtr ldaPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clatrz.f>
latrz ::
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float))
latrz m l a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      liftIO $ FFI.latrz mPtr nPtr lPtr aPtr ldaPtr tauPtr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clauu2.f>
lauu2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
lauu2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauu2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clauum.f>
lauum ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
lauum uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauum uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbcon.f>
pbcon ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
pbcon uplo kd ab anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbcon uploPtr nPtr kdPtr abPtr ldabPtr anormPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbequ.f>
pbequ ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (CArray Int Float, Float, Float, Int)
pbequ uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.pbequ uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbrfs.f>
pbrfs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray (Int,Int) (Complex Float) {- ^ afb -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
pbrfs uplo kd ab afb b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (afbDim0,afbDim1) = Call.sizes2 $ bounds afb
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "pbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbrfs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbstf.f>
pbstf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (Int)
pbstf uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbstf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbsv.f>
pbsv ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
pbsv uplo kd ab b = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsv uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbsvx.f>
pbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ afb -} ->
   Char {- ^ equed -} ->
   IOCArray Int Float {- ^ s -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
pbsvx fact uplo kd ab afb equed s b ldx = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   (afbDim0,afbDim1) <- Call.sizes2 <$> getBounds afb
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "pbsvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsvx factPtr uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbtf2.f>
pbtf2 ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (Int)
pbtf2 uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtf2 uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbtrf.f>
pbtrf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (Int)
pbtrf uplo kd ab = do
   (abDim0,abDim1) <- Call.sizes2 <$> getBounds ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpbtrs.f>
pbtrs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
pbtrs uplo kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpftrf.f>
pftrf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ a -} ->
   IO (Int)
pftrf transr uplo n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.assert "pftrf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrf transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpftri.f>
pftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ a -} ->
   IO (Int)
pftri transr uplo n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.assert "pftri: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftri transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpftrs.f>
pftrs ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
pftrs transr uplo n a b = do
   let aDim0 = Call.sizes1 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pftrs: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrs transrPtr uploPtr nPtr nrhsPtr aPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpocon.f>
pocon ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
pocon uplo a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pocon uploPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpoequ.f>
poequ ::
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, Float, Float, Int)
poequ a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequ nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpoequb.f>
poequb ::
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, Float, Float, Int)
poequb a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequb nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cporfs.f>
porfs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ af -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
porfs uplo a af b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "porfs: n == afDim0" (n == afDim0)
   Call.assert "porfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.porfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cposv.f>
posv ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
posv uplo a b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.posv uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cposvx.f>
posvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ af -} ->
   Char {- ^ equed -} ->
   IOCArray Int Float {- ^ s -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
posvx fact uplo a af equed s b ldx = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "posvx: n == afDim0" (n == afDim0)
   Call.assert "posvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.posvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpotf2.f>
potf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
potf2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potf2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpotrf.f>
potrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
potrf uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potrf uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpotri.f>
potri ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
potri uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potri uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpotrs.f>
potrs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
potrs uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.potrs uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cppcon.f>
ppcon ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
ppcon uplo n ap anorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "ppcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppcon uploPtr nPtr apPtr anormPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cppequ.f>
ppequ ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IO (CArray Int Float, Float, Float, Int)
ppequ uplo n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "ppequ: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.ppequ uploPtr nPtr apPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpprfs.f>
pprfs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ afp -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
pprfs uplo n ap afp b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let afpDim0 = Call.sizes1 $ bounds afp
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "pprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "pprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pprfs uploPtr nPtr nrhsPtr apPtr afpPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cppsv.f>
ppsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
ppsv uplo n ap b = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsv uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cppsvx.f>
ppsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ afp -} ->
   Char {- ^ equed -} ->
   IOCArray Int Float {- ^ s -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
ppsvx fact uplo ap afp equed s b ldx = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   afpDim0 <- Call.sizes1 <$> getBounds afp
   sDim0 <- Call.sizes1 <$> getBounds s
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = sDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "ppsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      afpPtr <- Call.ioarray afp
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpptrf.f>
pptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (Int)
pptrf uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "pptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrf uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpptri.f>
pptri ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (Int)
pptri uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "pptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptri uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpptrs.f>
pptrs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
pptrs uplo n ap b = do
   let apDim0 = Call.sizes1 $ bounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrs uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpstf2.f>
pstf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ tol -} ->
   IO (CArray Int CInt, Int, Int)
pstf2 uplo a tol = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.float tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstf2 uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpstrf.f>
pstrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Float {- ^ tol -} ->
   IO (CArray Int CInt, Int, Int)
pstrf uplo a tol = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.float tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstrf uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cptcon.f>
ptcon ::
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
ptcon d e anorm = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let n = dDim0
   Call.assert "ptcon: n-1 == eDim0" (n-1 == eDim0)
   rwork <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ptcon nPtr dPtr ePtr anormPtr rcondPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpteqr.f>
pteqr ::
   Char {- ^ compz -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   IO (Int)
pteqr compz d e z = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "pteqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "pteqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pteqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cptrfs.f>
ptrfs ::
   Char {- ^ uplo -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   CArray Int Float {- ^ df -} ->
   CArray Int (Complex Float) {- ^ ef -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
ptrfs uplo d e df ef b x = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let dfDim0 = Call.sizes1 $ bounds df
   let efDim0 = Call.sizes1 $ bounds ef
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "ptrfs: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptrfs: n == dfDim0" (n == dfDim0)
   Call.assert "ptrfs: n-1 == efDim0" (n-1 == efDim0)
   Call.assert "ptrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 n
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.array df
      efPtr <- Call.array ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ptrfs uploPtr nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cptsv.f>
ptsv ::
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int (Complex Float) {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
ptsv d e b = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsv: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsv nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cptsvx.f>
ptsvx ::
   Char {- ^ fact -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   IOCArray Int Float {- ^ df -} ->
   IOCArray Int (Complex Float) {- ^ ef -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
ptsvx fact d e df ef b ldx = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   dfDim0 <- Call.sizes1 <$> getBounds df
   efDim0 <- Call.sizes1 <$> getBounds ef
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsvx: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptsvx: n == dfDim0" (n == dfDim0)
   Call.assert "ptsvx: n-1 == efDim0" (n-1 == efDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 n
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.ioarray df
      efPtr <- Call.ioarray ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsvx factPtr nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpttrf.f>
pttrf ::
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int (Complex Float) {- ^ e -} ->
   IO (Int)
pttrf d e = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "pttrf: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrf nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cpttrs.f>
pttrs ::
   Char {- ^ uplo -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
pttrs uplo d e b = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pttrs: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrs uploPtr nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cptts2.f>
ptts2 ::
   Int {- ^ iuplo -} ->
   CArray Int Float {- ^ d -} ->
   CArray Int (Complex Float) {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO ()
ptts2 iuplo d e b = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptts2: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      iuploPtr <- Call.cint iuplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.ptts2 iuploPtr nPtr nrhsPtr dPtr ePtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/crot.f>
rot ::
   IOCArray Int (Complex Float) {- ^ cx -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ cy -} ->
   Int {- ^ incy -} ->
   Float {- ^ c -} ->
   Complex Float {- ^ s -} ->
   IO ()
rot cx incx cy incy c s = do
   cxDim0 <- Call.sizes1 <$> getBounds cx
   cyDim0 <- Call.sizes1 <$> getBounds cy
   let n = cxDim0
   Call.assert "rot: n == cyDim0" (n == cyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      cxPtr <- Call.ioarray cx
      incxPtr <- Call.cint incx
      cyPtr <- Call.ioarray cy
      incyPtr <- Call.cint incy
      cPtr <- Call.float c
      sPtr <- Call.complexFloat s
      liftIO $ FFI.rot nPtr cxPtr incxPtr cyPtr incyPtr cPtr sPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csrscl.f>
rscl ::
   Int {- ^ n -} ->
   Float {- ^ sa -} ->
   IOCArray Int (Complex Float) {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO ()
rscl n sa sx incx = do
   sxDim0 <- Call.sizes1 <$> getBounds sx
   let _sxSize = sxDim0
   evalContT $ do
      nPtr <- Call.cint n
      saPtr <- Call.float sa
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.rscl nPtr saPtr sxPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cspcon.f>
spcon ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
spcon uplo ap ipiv anorm = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "spcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.spcon uploPtr nPtr apPtr ipivPtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cspmv.f>
spmv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Complex Float {- ^ alpha -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   Complex Float {- ^ beta -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
spmv uplo n alpha ap x incx beta y incy = do
   let apDim0 = Call.sizes1 $ bounds ap
   let xDim0 = Call.sizes1 $ bounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let _apSize = apDim0
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      apPtr <- Call.array ap
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.complexFloat beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.spmv uploPtr nPtr alphaPtr apPtr xPtr incxPtr betaPtr yPtr incyPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cspr.f>
spr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Complex Float {- ^ alpha -} ->
   CArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO ()
spr uplo n alpha x incx ap = do
   let xDim0 = Call.sizes1 $ bounds x
   apDim0 <- Call.sizes1 <$> getBounds ap
   let _xSize = xDim0
   let _apSize = apDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      apPtr <- Call.ioarray ap
      liftIO $ FFI.spr uploPtr nPtr alphaPtr xPtr incxPtr apPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csprfs.f>
sprfs ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ afp -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
sprfs uplo ap afp ipiv b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let afpDim0 = Call.sizes1 $ bounds afp
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "sprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "sprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "sprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sprfs uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cspsv.f>
spsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (CArray Int CInt, Int)
spsv uplo n ap b = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.spsv uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cspsvx.f>
spsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IOCArray Int (Complex Float) {- ^ afp -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
spsvx fact uplo ap afp ipiv b ldx = do
   let apDim0 = Call.sizes1 $ bounds ap
   afpDim0 <- Call.sizes1 <$> getBounds afp
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.ioarray afp
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csptrf.f>
sptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (CArray Int CInt, Int)
sptrf uplo n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "sptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrf uploPtr nPtr apPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csptri.f>
sptri ::
   Char {- ^ uplo -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
sptri uplo ap ipiv = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = ipivDim0
   Call.assert "sptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sptri uploPtr nPtr apPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csptrs.f>
sptrs ::
   Char {- ^ uplo -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
sptrs uplo ap ipiv b = do
   let apDim0 = Call.sizes1 $ bounds ap
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrs uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cstedc.f>
stedc ::
   Char {- ^ compz -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ lrwork -} ->
   Int {- ^ liwork -} ->
   IO (Int)
stedc compz d e z lwork lrwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "stedc: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stedc: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 (maximum[1,lrwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stedc compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cstegr.f>
stegr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
stegr jobz range d e vl vu il iu abstol m ldz lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stegr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stegr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cstein.f>
stein ::
   CArray Int Float {- ^ d -} ->
   CArray Int Float {- ^ e -} ->
   Int {- ^ m -} ->
   CArray Int Float {- ^ w -} ->
   CArray Int CInt {- ^ iblock -} ->
   CArray Int CInt {- ^ isplit -} ->
   Int {- ^ ldz -} ->
   IO (CArray (Int,Int) (Complex Float), CArray Int CInt, Int)
stein d e m w iblock isplit ldz = do
   let dDim0 = Call.sizes1 $ bounds d
   let eDim0 = Call.sizes1 $ bounds e
   let wDim0 = Call.sizes1 $ bounds w
   let iblockDim0 = Call.sizes1 $ bounds iblock
   let isplitDim0 = Call.sizes1 $ bounds isplit
   let n = dDim0
   Call.assert "stein: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stein: n == wDim0" (n == wDim0)
   Call.assert "stein: n == iblockDim0" (n == iblockDim0)
   Call.assert "stein: n == isplitDim0" (n == isplitDim0)
   z <- Call.newArray2 m ldz
   work <- Call.newArray1 (5*n)
   iwork <- Call.newArray1 n
   ifail <- Call.newArray1 m
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      mPtr <- Call.cint m
      wPtr <- Call.array w
      iblockPtr <- Call.array iblock
      isplitPtr <- Call.array isplit
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.stein nPtr dPtr ePtr mPtr wPtr iblockPtr isplitPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cstemr.f>
stemr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ nzc -} ->
   Bool {- ^ tryrac -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, CArray Int Float, CArray (Int,Int) (Complex Float), CArray Int CInt, Bool, Int)
stemr jobz range d e vl vu il iu m ldz nzc tryrac lwork liwork = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   let n = dDim0
   Call.assert "stemr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nzcPtr <- Call.cint nzc
      isuppzPtr <- Call.ioarray isuppz
      tryracPtr <- Call.bool tryrac
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stemr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr mPtr wPtr zPtr ldzPtr nzcPtr isuppzPtr tryracPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> peek tryracPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csteqr.f>
steqr ::
   Char {- ^ compz -} ->
   IOCArray Int Float {- ^ d -} ->
   IOCArray Int Float {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   IO (Int)
steqr compz d e z = do
   dDim0 <- Call.sizes1 <$> getBounds d
   eDim0 <- Call.sizes1 <$> getBounds e
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = dDim0
   let ldz = zDim1
   Call.assert "steqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "steqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,2*n-2])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.steqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/scsum1.f>
sum1 ::
   CArray Int (Complex Float) {- ^ cx -} ->
   Int {- ^ incx -} ->
   IO Float
sum1 cx incx = do
   let cxDim0 = Call.sizes1 $ bounds cx
   let n = cxDim0
   evalContT $ do
      nPtr <- Call.cint n
      cxPtr <- Call.array cx
      incxPtr <- Call.cint incx
      liftIO $ FFI.sum1 nPtr cxPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csycon.f>
sycon ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
sycon uplo a ipiv anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sycon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sycon uploPtr nPtr aPtr ldaPtr ipivPtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyconv.f>
syconv ::
   Char {- ^ uplo -} ->
   Char {- ^ way -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (CArray Int (Complex Float), Int)
syconv uplo way a ipiv = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "syconv: n == ipivDim0" (n == ipivDim0)
   e <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      wayPtr <- Call.char way
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.syconv uploPtr wayPtr nPtr aPtr ldaPtr ipivPtr ePtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyequb.f>
syequb ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int Float, Float, Float, Int)
syequb uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.syequb uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csymv.f>
symv ::
   Char {- ^ uplo -} ->
   Complex Float {- ^ alpha -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   Complex Float {- ^ beta -} ->
   IOCArray Int (Complex Float) {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
symv uplo alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let xDim0 = Call.sizes1 $ bounds x
   yDim0 <- Call.sizes1 <$> getBounds y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.complexFloat beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.symv uploPtr nPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyr.f>
syr ::
   Char {- ^ uplo -} ->
   Complex Float {- ^ alpha -} ->
   CArray Int (Complex Float) {- ^ x -} ->
   Int {- ^ incx -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO ()
syr uplo alpha x incx a = do
   let xDim0 = Call.sizes1 $ bounds x
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let _xSize = xDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.syr uploPtr nPtr alphaPtr xPtr incxPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyrfs.f>
syrfs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ af -} ->
   CArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
syrfs uplo a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (afDim0,afDim1) = Call.sizes2 $ bounds af
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (xDim0,xDim1) <- Call.sizes2 <$> getBounds x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "syrfs: n == afDim0" (n == afDim0)
   Call.assert "syrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "syrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syrfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csysv.f>
sysv ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
sysv uplo a b lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysv uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csysvx.f>
sysvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ af -} ->
   IOCArray Int CInt {- ^ ipiv -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   Int {- ^ ldx -} ->
   Int {- ^ lwork -} ->
   IO (CArray (Int,Int) (Complex Float), Float, CArray Int Float, CArray Int Float, Int)
sysvx fact uplo a af ipiv b ldx lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (afDim0,afDim1) <- Call.sizes2 <$> getBounds af
   ipivDim0 <- Call.sizes1 <$> getBounds ipiv
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sysvx: n == afDim0" (n == afDim0)
   Call.assert "sysvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr lworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyswapr.f>
syswapr ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ i1 -} ->
   Int {- ^ i2 -} ->
   IO ()
syswapr uplo a i1 i2 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      i1Ptr <- Call.cint i1
      i2Ptr <- Call.cint i2
      liftIO $ FFI.syswapr uploPtr nPtr aPtr ldaPtr i1Ptr i2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytf2.f>
sytf2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int CInt, Int)
sytf2 uplo a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sytf2 uploPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytrf.f>
sytrf ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int CInt, Int)
sytrf uplo a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrf uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytri.f>
sytri ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IO (Int)
sytri uplo a ipiv = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri uploPtr nPtr aPtr ldaPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytri2.f>
sytri2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   Int {- ^ lwork -} ->
   IO (Int)
sytri2 uplo a ipiv nb lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2 uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytri2x.f>
sytri2x ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   IO (Int)
sytri2x uplo a ipiv nb = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2x: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray2 (nb+3) (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      nbPtr <- Call.cint nb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2x uploPtr nPtr aPtr ldaPtr ipivPtr workPtr nbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytrs.f>
sytrs ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
sytrs uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csytrs2.f>
sytrs2 ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int CInt {- ^ ipiv -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
sytrs2 uplo a ipiv b = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let ipivDim0 = Call.sizes1 $ bounds ipiv
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs2 uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctbcon.f>
tbcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IO (Float, Int)
tbcon norm uplo diag kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbcon normPtr uploPtr diagPtr nPtr kdPtr abPtr ldabPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctbrfs.f>
tbrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   CArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
tbrfs uplo trans diag kd ab b x = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbrfs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctbtrs.f>
tbtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   CArray (Int,Int) (Complex Float) {- ^ ab -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
tbtrs uplo trans diag kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ bounds ab
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tbtrs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctfsm.f>
tfsm ::
   Char {- ^ transr -} ->
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Complex Float {- ^ alpha -} ->
   CArray Int (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO ()
tfsm transr side uplo trans diag m alpha a b = do
   let aDim0 = Call.sizes1 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = bDim0
   let ldb = bDim1
   Call.assert "tfsm: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.complexFloat alpha
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.tfsm transrPtr sidePtr uploPtr transPtr diagPtr mPtr nPtr alphaPtr aPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctftri.f>
tftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ a -} ->
   IO (Int)
tftri transr uplo diag n a = do
   aDim0 <- Call.sizes1 <$> getBounds a
   Call.assert "tftri: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.tftri transrPtr uploPtr diagPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctfttp.f>
tfttp ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ arf -} ->
   IO (CArray Int (Complex Float), Int)
tfttp transr uplo n arf = do
   let arfDim0 = Call.sizes1 $ bounds arf
   Call.assert "tfttp: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttp transrPtr uploPtr nPtr arfPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctfttr.f>
tfttr ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ arf -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
tfttr transr uplo n arf lda = do
   let arfDim0 = Call.sizes1 $ bounds arf
   Call.assert "tfttr: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttr transrPtr uploPtr nPtr arfPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgevc.f>
tgevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) (Complex Float) {- ^ s -} ->
   CArray (Int,Int) (Complex Float) {- ^ p -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vl -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vr -} ->
   IO (Int, Int)
tgevc side howmny select s p vl vr = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (sDim0,sDim1) = Call.sizes2 $ bounds s
   let (pDim0,pDim1) = Call.sizes2 $ bounds p
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let lds = sDim1
   let ldp = pDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgevc: n == sDim0" (n == sDim0)
   Call.assert "tgevc: n == pDim0" (n == pDim0)
   Call.assert "tgevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 (2*n)
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      sPtr <- Call.array s
      ldsPtr <- Call.cint lds
      pPtr <- Call.array p
      ldpPtr <- Call.cint ldp
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgevc sidePtr howmnyPtr selectPtr nPtr sPtr ldsPtr pPtr ldpPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgex2.f>
tgex2 ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ j1 -} ->
   IO (Int)
tgex2 wantq wantz a b q z j1 = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgex2: n == bDim0" (n == bDim0)
   Call.assert "tgex2: n == qDim0" (n == qDim0)
   Call.assert "tgex2: n == zDim0" (n == zDim0)
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      j1Ptr <- Call.cint j1
      infoPtr <- Call.alloca
      liftIO $ FFI.tgex2 wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr j1Ptr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgexc.f>
tgexc ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   IO (Int, Int)
tgexc wantq wantz a b q z ifst ilst = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgexc: n == bDim0" (n == bDim0)
   Call.assert "tgexc: n == qDim0" (n == qDim0)
   Call.assert "tgexc: n == zDim0" (n == zDim0)
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      infoPtr <- Call.alloca
      liftIO $ FFI.tgexc wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr ifstPtr ilstPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek ilstPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsen.f>
tgsen ::
   Int {- ^ ijob -} ->
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   CArray Int Bool {- ^ select -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (CArray Int (Complex Float), CArray Int (Complex Float), Int, Float, Float, CArray Int Float, Int)
tgsen ijob wantq wantz select a b q z lwork liwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   (zDim0,zDim1) <- Call.sizes2 <$> getBounds z
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgsen: n == aDim0" (n == aDim0)
   Call.assert "tgsen: n == bDim0" (n == bDim0)
   Call.assert "tgsen: n == qDim0" (n == qDim0)
   Call.assert "tgsen: n == zDim0" (n == zDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   dif <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      ijobPtr <- Call.cint ijob
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      mPtr <- Call.alloca
      plPtr <- Call.alloca
      prPtr <- Call.alloca
      difPtr <- Call.ioarray dif
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsen ijobPtr wantqPtr wantzPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr alphaPtr betaPtr qPtr ldqPtr zPtr ldzPtr mPtr plPtr prPtr difPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek mPtr)
         <*> peek plPtr
         <*> peek prPtr
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsja.f>
tgsja ::
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Char {- ^ jobq -} ->
   Int {- ^ k -} ->
   Int {- ^ l -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   Float {- ^ tola -} ->
   Float {- ^ tolb -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ u -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ v -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   IO (CArray Int Float, CArray Int Float, Int, Int)
tgsja jobu jobv jobq k l a b tola tolb u v q = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   (uDim0,uDim1) <- Call.sizes2 <$> getBounds u
   (vDim0,vDim1) <- Call.sizes2 <$> getBounds v
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = uDim0
   let ldu = uDim1
   let p = vDim0
   let ldv = vDim1
   let ldq = qDim1
   Call.assert "tgsja: n == bDim0" (n == bDim0)
   Call.assert "tgsja: n == qDim0" (n == qDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      jobqPtr <- Call.char jobq
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      tolaPtr <- Call.float tola
      tolbPtr <- Call.float tolb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      ncyclePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsja jobuPtr jobvPtr jobqPtr mPtr pPtr nPtr kPtr lPtr aPtr ldaPtr bPtr ldbPtr tolaPtr tolbPtr alphaPtr betaPtr uPtr lduPtr vPtr ldvPtr qPtr ldqPtr workPtr ncyclePtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek ncyclePtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsna.f>
tgsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   CArray (Int,Int) (Complex Float) {- ^ vl -} ->
   CArray (Int,Int) (Complex Float) {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, CArray Int Float, Int, Int)
tgsna job howmny select a b vl vr mm lwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (vlDim0,vlDim1) = Call.sizes2 $ bounds vl
   let (vrDim0,vrDim1) = Call.sizes2 $ bounds vr
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgsna: n == aDim0" (n == aDim0)
   Call.assert "tgsna: n == bDim0" (n == bDim0)
   Call.assert "tgsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   dif <- Call.newArray1 mm
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (n+2)
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      difPtr <- Call.ioarray dif
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsna jobPtr howmnyPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr difPtr mmPtr mPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsy2.f>
tgsy2 ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   CArray (Int,Int) (Complex Float) {- ^ d -} ->
   CArray (Int,Int) (Complex Float) {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ f -} ->
   Float {- ^ rdsum -} ->
   Float {- ^ rdscal -} ->
   IO (Float, Float, Float, Int)
tgsy2 trans ijob a b c d e f rdsum rdscal = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let (dDim0,dDim1) = Call.sizes2 $ bounds d
   let (eDim0,eDim1) = Call.sizes2 $ bounds e
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsy2: n == cDim0" (n == cDim0)
   Call.assert "tgsy2: m == dDim0" (m == dDim0)
   Call.assert "tgsy2: n == eDim0" (n == eDim0)
   Call.assert "tgsy2: n == fDim0" (n == fDim0)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      rdsumPtr <- Call.float rdsum
      rdscalPtr <- Call.float rdscal
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsy2 transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr rdsumPtr rdscalPtr infoPtr
      liftIO $ pure (,,,)
         <*> peek scalePtr
         <*> peek rdsumPtr
         <*> peek rdscalPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsyl.f>
tgsyl ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   CArray (Int,Int) (Complex Float) {- ^ d -} ->
   CArray (Int,Int) (Complex Float) {- ^ e -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ f -} ->
   Int {- ^ lwork -} ->
   IO (Float, Float, Int)
tgsyl trans ijob a b c d e f lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let (dDim0,dDim1) = Call.sizes2 $ bounds d
   let (eDim0,eDim1) = Call.sizes2 $ bounds e
   (fDim0,fDim1) <- Call.sizes2 <$> getBounds f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsyl: n == cDim0" (n == cDim0)
   Call.assert "tgsyl: m == dDim0" (m == dDim0)
   Call.assert "tgsyl: n == eDim0" (n == eDim0)
   Call.assert "tgsyl: n == fDim0" (n == fDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (m+n+2)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      difPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsyl transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr difPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> peek scalePtr
         <*> peek difPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctpcon.f>
tpcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IO (Float, Int)
tpcon norm uplo diag n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tpcon normPtr uploPtr diagPtr nPtr apPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctprfs.f>
tprfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   CArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
tprfs uplo trans diag n ap b x = do
   let apDim0 = Call.sizes1 $ bounds ap
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "tprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tprfs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctptri.f>
tptri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOCArray Int (Complex Float) {- ^ ap -} ->
   IO (Int)
tptri uplo diag n ap = do
   apDim0 <- Call.sizes1 <$> getBounds ap
   Call.assert "tptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tptri uploPtr diagPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctptrs.f>
tptrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
tptrs uplo trans diag n ap b = do
   let apDim0 = Call.sizes1 $ bounds ap
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "tptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tptrs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctpttf.f>
tpttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   IO (CArray Int (Complex Float), Int)
tpttf transr uplo n ap = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpttf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   arf <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttf transrPtr uploPtr nPtr apPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctpttr.f>
tpttr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   Int {- ^ lda -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
tpttr uplo n ap lda = do
   let apDim0 = Call.sizes1 $ bounds ap
   Call.assert "tpttr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttr uploPtr nPtr apPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrcon.f>
trcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Float, Int)
trcon norm uplo diag a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trcon normPtr uploPtr diagPtr nPtr aPtr ldaPtr rcondPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrevc.f>
trevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vl -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ vr -} ->
   IO (Int, Int)
trevc side howmny select t vl vr = do
   let selectDim0 = Call.sizes1 $ bounds select
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (vlDim0,vlDim1) <- Call.sizes2 <$> getBounds vl
   (vrDim0,vrDim1) <- Call.sizes2 <$> getBounds vr
   let n = selectDim0
   let ldt = tDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trevc: n == tDim0" (n == tDim0)
   Call.assert "trevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trevc sidePtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrexc.f>
trexc ::
   Char {- ^ compq -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   IO (Int)
trexc compq t q ifst ilst = do
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = tDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trexc: n == qDim0" (n == qDim0)
   evalContT $ do
      compqPtr <- Call.char compq
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      infoPtr <- Call.alloca
      liftIO $ FFI.trexc compqPtr nPtr tPtr ldtPtr qPtr ldqPtr ifstPtr ilstPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrrfs.f>
trrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   CArray (Int,Int) (Complex Float) {- ^ x -} ->
   IO (CArray Int Float, CArray Int Float, Int)
trrfs uplo trans diag a b x = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   let (xDim0,xDim1) = Call.sizes2 $ bounds x
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "trrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   rwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trrfs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr rworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrsen.f>
trsen ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   CArray Int Bool {- ^ select -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ t -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ q -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int, Float, Float, Int)
trsen job compq select t q lwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   (tDim0,tDim1) <- Call.sizes2 <$> getBounds t
   (qDim0,qDim1) <- Call.sizes2 <$> getBounds q
   let n = selectDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trsen: n == tDim0" (n == tDim0)
   Call.assert "trsen: n == qDim0" (n == qDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      wPtr <- Call.ioarray w
      mPtr <- Call.alloca
      sPtr <- Call.alloca
      sepPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsen jobPtr compqPtr selectPtr nPtr tPtr ldtPtr qPtr ldqPtr wPtr mPtr sPtr sepPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek mPtr)
         <*> peek sPtr
         <*> peek sepPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrsna.f>
trsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   CArray Int Bool {- ^ select -} ->
   CArray (Int,Int) (Complex Float) {- ^ t -} ->
   CArray (Int,Int) (Complex Float) {- ^ vl -} ->
   CArray (Int,Int) (Complex Float) {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ ldwork -} ->
   IO (CArray Int Float, CArray Int Float, Int, Int)
trsna job howmny select t vl vr mm ldwork = do
   let selectDim0 = Call.sizes1 $ bounds select
   let (tDim0,tDim1) = Call.sizes2 $ bounds t
   let (vlDim0,vlDim1) = Call.sizes2 $ bounds vl
   let (vrDim0,vrDim1) = Call.sizes2 $ bounds vr
   let n = selectDim0
   let ldt = tDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trsna: n == tDim0" (n == tDim0)
   Call.assert "trsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   sep <- Call.newArray1 mm
   work <- Call.newArray2 (n+6) ldwork
   rwork <- Call.newArray1 n
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      sepPtr <- Call.ioarray sep
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      rworkPtr <- Call.ioarray rwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsna jobPtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr sepPtr mmPtr mPtr workPtr ldworkPtr rworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray sep
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrsyl.f>
trsyl ::
   Char {- ^ trana -} ->
   Char {- ^ tranb -} ->
   Int {- ^ isgn -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray (Int,Int) (Complex Float) {- ^ b -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   IO (Float, Int)
trsyl trana tranb isgn a b c = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let (bDim0,bDim1) = Call.sizes2 $ bounds b
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   Call.assert "trsyl: n == cDim0" (n == cDim0)
   evalContT $ do
      tranaPtr <- Call.char trana
      tranbPtr <- Call.char tranb
      isgnPtr <- Call.cint isgn
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      scalePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.trsyl tranaPtr tranbPtr isgnPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr scalePtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrti2.f>
trti2 ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
trti2 uplo diag a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trti2 uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrtri.f>
trtri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (Int)
trtri uplo diag a = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trtri uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrtrs.f>
trtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ b -} ->
   IO (Int)
trtrs uplo trans diag a b = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   (bDim0,bDim1) <- Call.sizes2 <$> getBounds b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.trtrs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrttf.f>
trttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
trttf transr uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   arf <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.trttf transrPtr uploPtr nPtr aPtr ldaPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctrttp.f>
trttp ::
   Char {- ^ uplo -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   IO (CArray Int (Complex Float), Int)
trttp uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let n = aDim0
   let lda = aDim1
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.trttp uploPtr nPtr aPtr ldaPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctzrzf.f>
tzrzf ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int (Complex Float), Int)
tzrzf m a lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tzrzf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunbdb.f>
unbdb ::
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x11 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x12 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x21 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x22 -} ->
   Int {- ^ lwork -} ->
   IO (CArray Int Float, CArray Int Float, CArray Int (Complex Float), CArray Int (Complex Float), CArray Int (Complex Float), CArray Int (Complex Float), Int)
unbdb trans signs m p x11 x12 x21 x22 lwork = do
   (x11Dim0,x11Dim1) <- Call.sizes2 <$> getBounds x11
   (x12Dim0,x12Dim1) <- Call.sizes2 <$> getBounds x12
   (x21Dim0,x21Dim1) <- Call.sizes2 <$> getBounds x21
   (x22Dim0,x22Dim1) <- Call.sizes2 <$> getBounds x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "unbdb: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "unbdb: q == x21Dim0" (q == x21Dim0)
   Call.assert "unbdb: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 q
   phi <- Call.newArray1 (q-1)
   taup1 <- Call.newArray1 p
   taup2 <- Call.newArray1 (m-p)
   tauq1 <- Call.newArray1 q
   tauq2 <- Call.newArray1 (m-q)
   work <- Call.newArray1 lwork
   evalContT $ do
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      taup1Ptr <- Call.ioarray taup1
      taup2Ptr <- Call.ioarray taup2
      tauq1Ptr <- Call.ioarray tauq1
      tauq2Ptr <- Call.ioarray tauq2
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unbdb transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr phiPtr taup1Ptr taup2Ptr tauq1Ptr tauq2Ptr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray phi
         <*> Call.freezeArray taup1
         <*> Call.freezeArray taup2
         <*> Call.freezeArray tauq1
         <*> Call.freezeArray tauq2
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cuncsd.f>
uncsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x11 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x12 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x21 -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ x22 -} ->
   Int {- ^ r -} ->
   Int {- ^ ldu1 -} ->
   Int {- ^ ldu2 -} ->
   Int {- ^ ldv1t -} ->
   Int {- ^ ldv2t -} ->
   Int {- ^ lwork -} ->
   Int {- ^ rworkSize -} ->
   Int {- ^ lrwork -} ->
   IO (CArray Int Float, CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), CArray (Int,Int) (Complex Float), Int)
uncsd jobu1 jobu2 jobv1t jobv2t trans signs m p x11 x12 x21 x22 r ldu1 ldu2 ldv1t ldv2t lwork rworkSize lrwork = do
   (x11Dim0,x11Dim1) <- Call.sizes2 <$> getBounds x11
   (x12Dim0,x12Dim1) <- Call.sizes2 <$> getBounds x12
   (x21Dim0,x21Dim1) <- Call.sizes2 <$> getBounds x21
   (x22Dim0,x22Dim1) <- Call.sizes2 <$> getBounds x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "uncsd: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "uncsd: q == x21Dim0" (q == x21Dim0)
   Call.assert "uncsd: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 r
   u1 <- Call.newArray2 p ldu1
   u2 <- Call.newArray2 (m-p) ldu2
   v1t <- Call.newArray2 q ldv1t
   v2t <- Call.newArray2 (m-q) ldv2t
   work <- Call.newArray1 (maximum[1,lwork])
   rwork <- Call.newArray1 rworkSize
   iwork <- Call.newArray1 (m-minimum[p,m-p,q,m-q])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      rworkPtr <- Call.ioarray rwork
      lrworkPtr <- Call.cint lrwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.uncsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr workPtr lworkPtr rworkPtr lrworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray u1
         <*> Call.freezeArray u2
         <*> Call.freezeArray v1t
         <*> Call.freezeArray v2t
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cung2l.f>
ung2l ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IO (Int)
ung2l m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ung2l mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cung2r.f>
ung2r ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IO (Int)
ung2r m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ung2r mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungbr.f>
ungbr ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ungbr vect m k a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ungbr vectPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunghr.f>
unghr ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unghr ilo ihi a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   Call.assert "unghr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unghr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungl2.f>
ungl2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IO (Int)
ungl2 m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ungl2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunglq.f>
unglq ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unglq m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unglq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungql.f>
ungql ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ungql m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ungql mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungqr.f>
ungqr ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ungqr m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ungqr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungr2.f>
ungr2 ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IO (Int)
ungr2 m a tau = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ungr2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungrq.f>
ungrq ::
   Int {- ^ m -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ungrq m a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ungrq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cungtr.f>
ungtr ::
   Char {- ^ uplo -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ungtr uplo a tau lwork = do
   (aDim0,aDim1) <- Call.sizes2 <$> getBounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   let n = aDim0
   let lda = aDim1
   Call.assert "ungtr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ungtr uploPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunm2l.f>
unm2l ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
unm2l side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "unm2l: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.unm2l sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunm2r.f>
unm2r ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
unm2r side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "unm2r: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.unm2r sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmbr.f>
unmbr ::
   Char {- ^ vect -} ->
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmbr vect side trans m k a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.ignore "unmbr: minimum[nq,k] == tauDim0" tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmbr vectPtr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmhr.f>
unmhr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmhr side trans m ilo ihi a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmhr sidePtr transPtr mPtr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunml2.f>
unml2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
unml2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.unml2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmlq.f>
unmlq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmlq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmlq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmql.f>
unmql ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmql side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "unmql: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmql sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmqr.f>
unmqr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmqr side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "unmqr: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmqr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmr2.f>
unmr2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
unmr2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.unmr2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmr3.f>
unmr3 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
unmr3 side trans m l a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.unmr3 sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmrq.f>
unmrq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmrq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmrq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmrz.f>
unmrz ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmrz side trans m l a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmrz sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cunmtr.f>
unmtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray (Int,Int) (Complex Float) {- ^ a -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
unmtr side uplo trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ bounds a
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.unmtr sidePtr uploPtr transPtr mPtr nPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cupgtr.f>
upgtr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   Int {- ^ ldq -} ->
   IO (CArray (Int,Int) (Complex Float), Int)
upgtr uplo n ap tau ldq = do
   let apDim0 = Call.sizes1 $ bounds ap
   let tauDim0 = Call.sizes1 $ bounds tau
   Call.assert "upgtr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "upgtr: n-1 == tauDim0" (n-1 == tauDim0)
   q <- Call.newArray2 n ldq
   work <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.upgtr uploPtr nPtr apPtr tauPtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/cupmtr.f>
upmtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   CArray Int (Complex Float) {- ^ ap -} ->
   CArray Int (Complex Float) {- ^ tau -} ->
   IOCArray (Int,Int) (Complex Float) {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
upmtr side uplo trans m ap tau c workSize = do
   let apDim0 = Call.sizes1 $ bounds ap
   let tauDim0 = Call.sizes1 $ bounds tau
   (cDim0,cDim1) <- Call.sizes2 <$> getBounds c
   let _apSize = apDim0
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.upmtr sidePtr uploPtr transPtr mPtr nPtr apPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)
