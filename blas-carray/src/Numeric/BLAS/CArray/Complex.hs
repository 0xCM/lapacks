-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.BLAS.CArray.Complex (
   axpy,
   casum,
   cnrm2,
   copy,
   gbmv,
   gemm,
   gemv,
   gerc,
   geru,
   hbmv,
   hemm,
   hemv,
   her,
   her2,
   her2k,
   herk,
   hpmv,
   hpr,
   hpr2,
   iamax,
   rotg,
   rrot,
   rscal,
   scal,
   swap,
   symm,
   syr2k,
   syrk,
   tbmv,
   tbsv,
   tpmv,
   tpsv,
   trmm,
   trmv,
   trsm,
   trsv,
   ) where

import qualified Numeric.BLAS.CArray.ComplexDouble as Z
import qualified Numeric.BLAS.CArray.ComplexFloat as C
import qualified Numeric.Netlib.Class as Class

import Data.Complex (Complex)

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.C.Types (CInt)



newtype AXPY a = AXPY {getAXPY :: Int -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO ()}

axpy :: Class.Real a => Int -> (Complex a) -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO ()
axpy = getAXPY $ Class.switchReal (AXPY C.axpy) (AXPY Z.axpy)


newtype CASUM a = CASUM {getCASUM :: Int -> IOCArray Int (Complex a) -> Int -> IO a}

casum :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IO a
casum = getCASUM $ Class.switchReal (CASUM C.casum) (CASUM Z.casum)


newtype CNRM2 a = CNRM2 {getCNRM2 :: CArray Int (Complex a) -> Int -> IO a}

cnrm2 :: Class.Real a => CArray Int (Complex a) -> Int -> IO a
cnrm2 = getCNRM2 $ Class.switchReal (CNRM2 C.cnrm2) (CNRM2 Z.cnrm2)


newtype COPY a = COPY {getCOPY :: Int -> CArray Int (Complex a) -> Int -> Int -> IO (CArray Int (Complex a))}

copy :: Class.Real a => Int -> CArray Int (Complex a) -> Int -> Int -> IO (CArray Int (Complex a))
copy = getCOPY $ Class.switchReal (COPY C.copy) (COPY Z.copy)


newtype GBMV a = GBMV {getGBMV :: Char -> Int -> Int -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

gbmv :: Class.Real a => Char -> Int -> Int -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
gbmv = getGBMV $ Class.switchReal (GBMV C.gbmv) (GBMV Z.gbmv)


newtype GEMM a = GEMM {getGEMM :: Char -> Char -> Int -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

gemm :: Class.Real a => Char -> Char -> Int -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
gemm = getGEMM $ Class.switchReal (GEMM C.gemm) (GEMM Z.gemm)


newtype GEMV a = GEMV {getGEMV :: Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

gemv :: Class.Real a => Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
gemv = getGEMV $ Class.switchReal (GEMV C.gemv) (GEMV Z.gemv)


newtype GERC a = GERC {getGERC :: Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()}

gerc :: Class.Real a => Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()
gerc = getGERC $ Class.switchReal (GERC C.gerc) (GERC Z.gerc)


newtype GERU a = GERU {getGERU :: Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()}

geru :: Class.Real a => Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()
geru = getGERU $ Class.switchReal (GERU C.geru) (GERU Z.geru)


newtype HBMV a = HBMV {getHBMV :: Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

hbmv :: Class.Real a => Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
hbmv = getHBMV $ Class.switchReal (HBMV C.hbmv) (HBMV Z.hbmv)


newtype HEMM a = HEMM {getHEMM :: Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

hemm :: Class.Real a => Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
hemm = getHEMM $ Class.switchReal (HEMM C.hemm) (HEMM Z.hemm)


newtype HEMV a = HEMV {getHEMV :: Char -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

hemv :: Class.Real a => Char -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
hemv = getHEMV $ Class.switchReal (HEMV C.hemv) (HEMV Z.hemv)


newtype HER a = HER {getHER :: Char -> a -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()}

her :: Class.Real a => Char -> a -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()
her = getHER $ Class.switchReal (HER C.her) (HER Z.her)


newtype HER2 a = HER2 {getHER2 :: Char -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()}

her2 :: Class.Real a => Char -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray (Int,Int) (Complex a) -> IO ()
her2 = getHER2 $ Class.switchReal (HER2 C.her2) (HER2 Z.her2)


newtype HER2K a = HER2K {getHER2K :: Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()}

her2k :: Class.Real a => Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()
her2k = getHER2K $ Class.switchReal (HER2K C.her2k) (HER2K Z.her2k)


newtype HERK a = HERK {getHERK :: Char -> Char -> Int -> a -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()}

herk :: Class.Real a => Char -> Char -> Int -> a -> CArray (Int,Int) (Complex a) -> a -> IOCArray (Int,Int) (Complex a) -> IO ()
herk = getHERK $ Class.switchReal (HERK C.herk) (HERK Z.herk)


newtype HPMV a = HPMV {getHPMV :: Char -> Int -> (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

hpmv :: Class.Real a => Char -> Int -> (Complex a) -> CArray Int (Complex a) -> CArray Int (Complex a) -> Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
hpmv = getHPMV $ Class.switchReal (HPMV C.hpmv) (HPMV Z.hpmv)


newtype HPR a = HPR {getHPR :: Char -> Int -> a -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()}

hpr :: Class.Real a => Char -> Int -> a -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()
hpr = getHPR $ Class.switchReal (HPR C.hpr) (HPR Z.hpr)


newtype HPR2 a = HPR2 {getHPR2 :: Char -> Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()}

hpr2 :: Class.Real a => Char -> Int -> (Complex a) -> CArray Int (Complex a) -> Int -> CArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> IO ()
hpr2 = getHPR2 $ Class.switchReal (HPR2 C.hpr2) (HPR2 Z.hpr2)


newtype IAMAX a = IAMAX {getIAMAX :: Int -> CArray Int (Complex a) -> Int -> IO CInt}

iamax :: Class.Real a => Int -> CArray Int (Complex a) -> Int -> IO CInt
iamax = getIAMAX $ Class.switchReal (IAMAX C.iamax) (IAMAX Z.iamax)


newtype ROTG a = ROTG {getROTG :: (Complex a) -> (Complex a) -> IO (a, (Complex a))}

rotg :: Class.Real a => (Complex a) -> (Complex a) -> IO (a, (Complex a))
rotg = getROTG $ Class.switchReal (ROTG C.rotg) (ROTG Z.rotg)


newtype RROT a = RROT {getRROT :: Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> a -> a -> IO ()}

rrot :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> a -> a -> IO ()
rrot = getRROT $ Class.switchReal (RROT C.rrot) (RROT Z.rrot)


newtype RSCAL a = RSCAL {getRSCAL :: Int -> a -> IOCArray Int (Complex a) -> Int -> IO ()}

rscal :: Class.Real a => Int -> a -> IOCArray Int (Complex a) -> Int -> IO ()
rscal = getRSCAL $ Class.switchReal (RSCAL C.rscal) (RSCAL Z.rscal)


newtype SCAL a = SCAL {getSCAL :: Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

scal :: Class.Real a => Int -> (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
scal = getSCAL $ Class.switchReal (SCAL C.scal) (SCAL Z.scal)


newtype SWAP a = SWAP {getSWAP :: Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO ()}

swap :: Class.Real a => Int -> IOCArray Int (Complex a) -> Int -> IOCArray Int (Complex a) -> Int -> IO ()
swap = getSWAP $ Class.switchReal (SWAP C.swap) (SWAP Z.swap)


newtype SYMM a = SYMM {getSYMM :: Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

symm :: Class.Real a => Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
symm = getSYMM $ Class.switchReal (SYMM C.symm) (SYMM Z.symm)


newtype SYR2K a = SYR2K {getSYR2K :: Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

syr2k :: Class.Real a => Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
syr2k = getSYR2K $ Class.switchReal (SYR2K C.syr2k) (SYR2K Z.syr2k)


newtype SYRK a = SYRK {getSYRK :: Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

syrk :: Class.Real a => Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
syrk = getSYRK $ Class.switchReal (SYRK C.syrk) (SYRK Z.syrk)


newtype TBMV a = TBMV {getTBMV :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

tbmv :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
tbmv = getTBMV $ Class.switchReal (TBMV C.tbmv) (TBMV Z.tbmv)


newtype TBSV a = TBSV {getTBSV :: Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

tbsv :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
tbsv = getTBSV $ Class.switchReal (TBSV C.tbsv) (TBSV Z.tbsv)


newtype TPMV a = TPMV {getTPMV :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

tpmv :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
tpmv = getTPMV $ Class.switchReal (TPMV C.tpmv) (TPMV Z.tpmv)


newtype TPSV a = TPSV {getTPSV :: Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

tpsv :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
tpsv = getTPSV $ Class.switchReal (TPSV C.tpsv) (TPSV Z.tpsv)


newtype TRMM a = TRMM {getTRMM :: Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

trmm :: Class.Real a => Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
trmm = getTRMM $ Class.switchReal (TRMM C.trmm) (TRMM Z.trmm)


newtype TRMV a = TRMV {getTRMV :: Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

trmv :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
trmv = getTRMV $ Class.switchReal (TRMV C.trmv) (TRMV Z.trmv)


newtype TRSM a = TRSM {getTRSM :: Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()}

trsm :: Class.Real a => Char -> Char -> Char -> Char -> Int -> (Complex a) -> CArray (Int,Int) (Complex a) -> IOCArray (Int,Int) (Complex a) -> IO ()
trsm = getTRSM $ Class.switchReal (TRSM C.trsm) (TRSM Z.trsm)


newtype TRSV a = TRSV {getTRSV :: Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()}

trsv :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) (Complex a) -> IOCArray Int (Complex a) -> Int -> IO ()
trsv = getTRSV $ Class.switchReal (TRSV C.trsv) (TRSV Z.trsv)
