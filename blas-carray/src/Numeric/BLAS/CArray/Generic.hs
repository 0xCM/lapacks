-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.BLAS.CArray.Generic (
   axpy,
   copy,
   gbmv,
   gemm,
   gemv,
   gerc,
   geru,
   hbmv,
   hemm,
   hemv,
   her2,
   hpmv,
   hpr2,
   iamax,
   scal,
   swap,
   symm,
   syr2k,
   syrk,
   tbmv,
   tbsv,
   tpmv,
   tpsv,
   trmm,
   trmv,
   trsm,
   trsv,
   ) where

import qualified Numeric.BLAS.CArray.ComplexDouble as Z
import qualified Numeric.BLAS.CArray.ComplexFloat as C
import qualified Numeric.BLAS.CArray.Double as D
import qualified Numeric.BLAS.CArray.Float as S
import qualified Numeric.Netlib.Class as Class

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.C.Types (CInt)



newtype AXPY a = AXPY {getAXPY :: Int -> a -> CArray Int a -> Int -> IOCArray Int a -> Int -> IO ()}

axpy :: Class.Floating a => Int -> a -> CArray Int a -> Int -> IOCArray Int a -> Int -> IO ()
axpy = getAXPY $ Class.switchFloating (AXPY S.axpy) (AXPY D.axpy) (AXPY C.axpy) (AXPY Z.axpy)


newtype COPY a = COPY {getCOPY :: Int -> CArray Int a -> Int -> Int -> IO (CArray Int a)}

copy :: Class.Floating a => Int -> CArray Int a -> Int -> Int -> IO (CArray Int a)
copy = getCOPY $ Class.switchFloating (COPY S.copy) (COPY D.copy) (COPY C.copy) (COPY Z.copy)


newtype GBMV a = GBMV {getGBMV :: Char -> Int -> Int -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

gbmv :: Class.Floating a => Char -> Int -> Int -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
gbmv = getGBMV $ Class.switchFloating (GBMV S.gbmv) (GBMV D.gbmv) (GBMV C.gbmv) (GBMV Z.gbmv)


newtype GEMM a = GEMM {getGEMM :: Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

gemm :: Class.Floating a => Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
gemm = getGEMM $ Class.switchFloating (GEMM S.gemm) (GEMM D.gemm) (GEMM C.gemm) (GEMM Z.gemm)


newtype GEMV a = GEMV {getGEMV :: Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

gemv :: Class.Floating a => Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
gemv = getGEMV $ Class.switchFloating (GEMV S.gemv) (GEMV D.gemv) (GEMV C.gemv) (GEMV Z.gemv)


newtype GERC a = GERC {getGERC :: Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

gerc :: Class.Floating a => Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
gerc = getGERC $ Class.switchFloating (GERC S.ger) (GERC D.ger) (GERC C.gerc) (GERC Z.gerc)


newtype GERU a = GERU {getGERU :: Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

geru :: Class.Floating a => Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
geru = getGERU $ Class.switchFloating (GERU S.ger) (GERU D.ger) (GERU C.geru) (GERU Z.geru)


newtype HBMV a = HBMV {getHBMV :: Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

hbmv :: Class.Floating a => Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
hbmv = getHBMV $ Class.switchFloating (HBMV S.sbmv) (HBMV D.sbmv) (HBMV C.hbmv) (HBMV Z.hbmv)


newtype HEMM a = HEMM {getHEMM :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

hemm :: Class.Floating a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
hemm = getHEMM $ Class.switchFloating (HEMM S.symm) (HEMM D.symm) (HEMM C.hemm) (HEMM Z.hemm)


newtype HEMV a = HEMV {getHEMV :: Char -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

hemv :: Class.Floating a => Char -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
hemv = getHEMV $ Class.switchFloating (HEMV S.symv) (HEMV D.symv) (HEMV C.hemv) (HEMV Z.hemv)


newtype HER2 a = HER2 {getHER2 :: Char -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

her2 :: Class.Floating a => Char -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
her2 = getHER2 $ Class.switchFloating (HER2 S.syr2) (HER2 D.syr2) (HER2 C.her2) (HER2 Z.her2)


newtype HPMV a = HPMV {getHPMV :: Char -> Int -> a -> CArray Int a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

hpmv :: Class.Floating a => Char -> Int -> a -> CArray Int a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
hpmv = getHPMV $ Class.switchFloating (HPMV S.spmv) (HPMV D.spmv) (HPMV C.hpmv) (HPMV Z.hpmv)


newtype HPR2 a = HPR2 {getHPR2 :: Char -> Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray Int a -> IO ()}

hpr2 :: Class.Floating a => Char -> Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray Int a -> IO ()
hpr2 = getHPR2 $ Class.switchFloating (HPR2 S.spr2) (HPR2 D.spr2) (HPR2 C.hpr2) (HPR2 Z.hpr2)


newtype IAMAX a = IAMAX {getIAMAX :: Int -> CArray Int a -> Int -> IO CInt}

iamax :: Class.Floating a => Int -> CArray Int a -> Int -> IO CInt
iamax = getIAMAX $ Class.switchFloating (IAMAX S.iamax) (IAMAX D.iamax) (IAMAX C.iamax) (IAMAX Z.iamax)


newtype SCAL a = SCAL {getSCAL :: Int -> a -> IOCArray Int a -> Int -> IO ()}

scal :: Class.Floating a => Int -> a -> IOCArray Int a -> Int -> IO ()
scal = getSCAL $ Class.switchFloating (SCAL S.scal) (SCAL D.scal) (SCAL C.scal) (SCAL Z.scal)


newtype SWAP a = SWAP {getSWAP :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO ()}

swap :: Class.Floating a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO ()
swap = getSWAP $ Class.switchFloating (SWAP S.swap) (SWAP D.swap) (SWAP C.swap) (SWAP Z.swap)


newtype SYMM a = SYMM {getSYMM :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

symm :: Class.Floating a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
symm = getSYMM $ Class.switchFloating (SYMM S.symm) (SYMM D.symm) (SYMM C.symm) (SYMM Z.symm)


newtype SYR2K a = SYR2K {getSYR2K :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

syr2k :: Class.Floating a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
syr2k = getSYR2K $ Class.switchFloating (SYR2K S.syr2k) (SYR2K D.syr2k) (SYR2K C.syr2k) (SYR2K Z.syr2k)


newtype SYRK a = SYRK {getSYRK :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

syrk :: Class.Floating a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
syrk = getSYRK $ Class.switchFloating (SYRK S.syrk) (SYRK D.syrk) (SYRK C.syrk) (SYRK Z.syrk)


newtype TBMV a = TBMV {getTBMV :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

tbmv :: Class.Floating a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
tbmv = getTBMV $ Class.switchFloating (TBMV S.tbmv) (TBMV D.tbmv) (TBMV C.tbmv) (TBMV Z.tbmv)


newtype TBSV a = TBSV {getTBSV :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

tbsv :: Class.Floating a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
tbsv = getTBSV $ Class.switchFloating (TBSV S.tbsv) (TBSV D.tbsv) (TBSV C.tbsv) (TBSV Z.tbsv)


newtype TPMV a = TPMV {getTPMV :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()}

tpmv :: Class.Floating a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()
tpmv = getTPMV $ Class.switchFloating (TPMV S.tpmv) (TPMV D.tpmv) (TPMV C.tpmv) (TPMV Z.tpmv)


newtype TPSV a = TPSV {getTPSV :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()}

tpsv :: Class.Floating a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()
tpsv = getTPSV $ Class.switchFloating (TPSV S.tpsv) (TPSV D.tpsv) (TPSV C.tpsv) (TPSV Z.tpsv)


newtype TRMM a = TRMM {getTRMM :: Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()}

trmm :: Class.Floating a => Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()
trmm = getTRMM $ Class.switchFloating (TRMM S.trmm) (TRMM D.trmm) (TRMM C.trmm) (TRMM Z.trmm)


newtype TRMV a = TRMV {getTRMV :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

trmv :: Class.Floating a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
trmv = getTRMV $ Class.switchFloating (TRMV S.trmv) (TRMV D.trmv) (TRMV C.trmv) (TRMV Z.trmv)


newtype TRSM a = TRSM {getTRSM :: Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()}

trsm :: Class.Floating a => Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()
trsm = getTRSM $ Class.switchFloating (TRSM S.trsm) (TRSM D.trsm) (TRSM C.trsm) (TRSM Z.trsm)


newtype TRSV a = TRSV {getTRSV :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

trsv :: Class.Floating a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
trsv = getTRSV $ Class.switchFloating (TRSV S.trsv) (TRSV D.trsv) (TRSV C.trsv) (TRSV Z.trsv)
