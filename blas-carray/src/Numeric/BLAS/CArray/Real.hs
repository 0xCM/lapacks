-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.BLAS.CArray.Real (
   asum,
   axpy,
   copy,
   dot,
   gbmv,
   gemm,
   gemv,
   ger,
   sbmv,
   symv,
   syr,
   syr2,
   spmv,
   spr,
   spr2,
   iamax,
   nrm2,
   rot,
   rotg,
   rotm,
   rotmg,
   scal,
   swap,
   symm,
   syr2k,
   syrk,
   tbmv,
   tbsv,
   tpmv,
   tpsv,
   trmm,
   trmv,
   trsm,
   trsv,
   ) where

import qualified Numeric.BLAS.CArray.Double as D
import qualified Numeric.BLAS.CArray.Float as S
import qualified Numeric.Netlib.Class as Class

import Data.Array.IOCArray (IOCArray)
import Data.Array.CArray (CArray)

import Foreign.C.Types (CInt)



newtype ASUM a = ASUM {getASUM :: Int -> CArray Int a -> Int -> IO a}

asum :: Class.Real a => Int -> CArray Int a -> Int -> IO a
asum = getASUM $ Class.switchReal (ASUM S.asum) (ASUM D.asum)


newtype AXPY a = AXPY {getAXPY :: Int -> a -> CArray Int a -> Int -> IOCArray Int a -> Int -> IO ()}

axpy :: Class.Real a => Int -> a -> CArray Int a -> Int -> IOCArray Int a -> Int -> IO ()
axpy = getAXPY $ Class.switchReal (AXPY S.axpy) (AXPY D.axpy)


newtype COPY a = COPY {getCOPY :: Int -> CArray Int a -> Int -> Int -> IO (CArray Int a)}

copy :: Class.Real a => Int -> CArray Int a -> Int -> Int -> IO (CArray Int a)
copy = getCOPY $ Class.switchReal (COPY S.copy) (COPY D.copy)


newtype DOT a = DOT {getDOT :: Int -> CArray Int a -> Int -> CArray Int a -> Int -> IO a}

dot :: Class.Real a => Int -> CArray Int a -> Int -> CArray Int a -> Int -> IO a
dot = getDOT $ Class.switchReal (DOT S.dot) (DOT D.dot)


newtype GBMV a = GBMV {getGBMV :: Char -> Int -> Int -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

gbmv :: Class.Real a => Char -> Int -> Int -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
gbmv = getGBMV $ Class.switchReal (GBMV S.gbmv) (GBMV D.gbmv)


newtype GEMM a = GEMM {getGEMM :: Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

gemm :: Class.Real a => Char -> Char -> Int -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
gemm = getGEMM $ Class.switchReal (GEMM S.gemm) (GEMM D.gemm)


newtype GEMV a = GEMV {getGEMV :: Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

gemv :: Class.Real a => Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
gemv = getGEMV $ Class.switchReal (GEMV S.gemv) (GEMV D.gemv)


newtype GER a = GER {getGER :: Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

ger :: Class.Real a => Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
ger = getGER $ Class.switchReal (GER S.ger) (GER D.ger)


newtype SBMV a = SBMV {getSBMV :: Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

sbmv :: Class.Real a => Char -> Int -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
sbmv = getSBMV $ Class.switchReal (SBMV S.sbmv) (SBMV D.sbmv)


newtype SYMV a = SYMV {getSYMV :: Char -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

symv :: Class.Real a => Char -> a -> CArray (Int,Int) a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
symv = getSYMV $ Class.switchReal (SYMV S.symv) (SYMV D.symv)


newtype SYR a = SYR {getSYR :: Char -> a -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

syr :: Class.Real a => Char -> a -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
syr = getSYR $ Class.switchReal (SYR S.syr) (SYR D.syr)


newtype SYR2 a = SYR2 {getSYR2 :: Char -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()}

syr2 :: Class.Real a => Char -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray (Int,Int) a -> IO ()
syr2 = getSYR2 $ Class.switchReal (SYR2 S.syr2) (SYR2 D.syr2)


newtype SPMV a = SPMV {getSPMV :: Char -> Int -> a -> CArray Int a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()}

spmv :: Class.Real a => Char -> Int -> a -> CArray Int a -> CArray Int a -> Int -> a -> IOCArray Int a -> Int -> IO ()
spmv = getSPMV $ Class.switchReal (SPMV S.spmv) (SPMV D.spmv)


newtype SPR a = SPR {getSPR :: Char -> Int -> a -> CArray Int a -> Int -> IOCArray Int a -> IO ()}

spr :: Class.Real a => Char -> Int -> a -> CArray Int a -> Int -> IOCArray Int a -> IO ()
spr = getSPR $ Class.switchReal (SPR S.spr) (SPR D.spr)


newtype SPR2 a = SPR2 {getSPR2 :: Char -> Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray Int a -> IO ()}

spr2 :: Class.Real a => Char -> Int -> a -> CArray Int a -> Int -> CArray Int a -> Int -> IOCArray Int a -> IO ()
spr2 = getSPR2 $ Class.switchReal (SPR2 S.spr2) (SPR2 D.spr2)


newtype IAMAX a = IAMAX {getIAMAX :: Int -> CArray Int a -> Int -> IO CInt}

iamax :: Class.Real a => Int -> CArray Int a -> Int -> IO CInt
iamax = getIAMAX $ Class.switchReal (IAMAX S.iamax) (IAMAX D.iamax)


newtype NRM2 a = NRM2 {getNRM2 :: Int -> CArray Int a -> Int -> IO a}

nrm2 :: Class.Real a => Int -> CArray Int a -> Int -> IO a
nrm2 = getNRM2 $ Class.switchReal (NRM2 S.nrm2) (NRM2 D.nrm2)


newtype ROT a = ROT {getROT :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> a -> a -> IO ()}

rot :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> a -> a -> IO ()
rot = getROT $ Class.switchReal (ROT S.rot) (ROT D.rot)


newtype ROTG a = ROTG {getROTG :: a -> a -> IO (a, a)}

rotg :: Class.Real a => a -> a -> IO (a, a)
rotg = getROTG $ Class.switchReal (ROTG S.rotg) (ROTG D.rotg)


newtype ROTM a = ROTM {getROTM :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> CArray Int a -> IO ()}

rotm :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> CArray Int a -> IO ()
rotm = getROTM $ Class.switchReal (ROTM S.rotm) (ROTM D.rotm)


newtype ROTMG a = ROTMG {getROTMG :: a -> a -> a -> a -> IO (a, a, a, CArray Int a)}

rotmg :: Class.Real a => a -> a -> a -> a -> IO (a, a, a, CArray Int a)
rotmg = getROTMG $ Class.switchReal (ROTMG S.rotmg) (ROTMG D.rotmg)


newtype SCAL a = SCAL {getSCAL :: Int -> a -> IOCArray Int a -> Int -> IO ()}

scal :: Class.Real a => Int -> a -> IOCArray Int a -> Int -> IO ()
scal = getSCAL $ Class.switchReal (SCAL S.scal) (SCAL D.scal)


newtype SWAP a = SWAP {getSWAP :: Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO ()}

swap :: Class.Real a => Int -> IOCArray Int a -> Int -> IOCArray Int a -> Int -> IO ()
swap = getSWAP $ Class.switchReal (SWAP S.swap) (SWAP D.swap)


newtype SYMM a = SYMM {getSYMM :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

symm :: Class.Real a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
symm = getSYMM $ Class.switchReal (SYMM S.symm) (SYMM D.symm)


newtype SYR2K a = SYR2K {getSYR2K :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

syr2k :: Class.Real a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
syr2k = getSYR2K $ Class.switchReal (SYR2K S.syr2k) (SYR2K D.syr2k)


newtype SYRK a = SYRK {getSYRK :: Char -> Char -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()}

syrk :: Class.Real a => Char -> Char -> Int -> a -> CArray (Int,Int) a -> a -> IOCArray (Int,Int) a -> IO ()
syrk = getSYRK $ Class.switchReal (SYRK S.syrk) (SYRK D.syrk)


newtype TBMV a = TBMV {getTBMV :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

tbmv :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
tbmv = getTBMV $ Class.switchReal (TBMV S.tbmv) (TBMV D.tbmv)


newtype TBSV a = TBSV {getTBSV :: Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

tbsv :: Class.Real a => Char -> Char -> Char -> Int -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
tbsv = getTBSV $ Class.switchReal (TBSV S.tbsv) (TBSV D.tbsv)


newtype TPMV a = TPMV {getTPMV :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()}

tpmv :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()
tpmv = getTPMV $ Class.switchReal (TPMV S.tpmv) (TPMV D.tpmv)


newtype TPSV a = TPSV {getTPSV :: Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()}

tpsv :: Class.Real a => Char -> Char -> Char -> Int -> CArray Int a -> IOCArray Int a -> Int -> IO ()
tpsv = getTPSV $ Class.switchReal (TPSV S.tpsv) (TPSV D.tpsv)


newtype TRMM a = TRMM {getTRMM :: Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()}

trmm :: Class.Real a => Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()
trmm = getTRMM $ Class.switchReal (TRMM S.trmm) (TRMM D.trmm)


newtype TRMV a = TRMV {getTRMV :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

trmv :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
trmv = getTRMV $ Class.switchReal (TRMV S.trmv) (TRMV D.trmv)


newtype TRSM a = TRSM {getTRSM :: Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()}

trsm :: Class.Real a => Char -> Char -> Char -> Char -> Int -> a -> CArray (Int,Int) a -> IOCArray (Int,Int) a -> IO ()
trsm = getTRSM $ Class.switchReal (TRSM S.trsm) (TRSM D.trsm)


newtype TRSV a = TRSV {getTRSV :: Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()}

trsv :: Class.Real a => Char -> Char -> Char -> CArray (Int,Int) a -> IOCArray Int a -> Int -> IO ()
trsv = getTRSV $ Class.switchReal (TRSV S.trsv) (TRSV D.trsv)
