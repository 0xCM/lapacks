-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.BLAS.ComfortArray.Float where

import qualified Numeric.BLAS.FFI.Float as FFI
import qualified Numeric.Netlib.ComfortArray.Utility as Call
import Numeric.Netlib.ComfortArray.Utility (ZeroInt)

import qualified Data.Array.Comfort.Storable.Mutable as MutArray
import qualified Data.Array.Comfort.Storable as Array
import Data.Array.Comfort.Storable.Mutable (IOArray)
import Data.Array.Comfort.Storable (Array)

import Foreign.Storable.Complex ()
import Foreign.Storable (peek)
import Foreign.C.Types (CInt)

import Control.Monad.Trans.Cont (evalContT)
import Control.Monad.IO.Class (liftIO)
import Control.Applicative (pure, (<*>))


asum ::
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO Float
asum n sx incx = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   Call.assert "asum: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.asum nPtr sxPtr incxPtr

axpy ::
   Int {- ^ n -} ->
   Float {- ^ sa -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   IO ()
axpy n sa sx incx sy incy = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   let syDim0 = Call.sizes1 $ MutArray.shape sy
   Call.assert "axpy: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "axpy: 1+(n-1)*abs(incy) == syDim0" (1+(n-1)*abs(incy) == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      saPtr <- Call.float sa
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      syPtr <- Call.ioarray sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.axpy nPtr saPtr sxPtr incxPtr syPtr incyPtr

copy ::
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   Int {- ^ incy -} ->
   IO (Array ZeroInt Float)
copy n sx incx incy = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   Call.assert "copy: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   sy <- Call.newArray1 (1+(n-1)*abs(incy))
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      syPtr <- Call.ioarray sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.copy nPtr sxPtr incxPtr syPtr incyPtr
      liftIO $ Call.freezeArray sy

dot ::
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   IO Float
dot n sx incx sy incy = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   let syDim0 = Call.sizes1 $ Array.shape sy
   Call.assert "dot: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "dot: 1+(n-1)*abs(incy) == syDim0" (1+(n-1)*abs(incy) == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      syPtr <- Call.array sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.dot nPtr sxPtr incxPtr syPtr incyPtr

dsdot ::
   Int {- ^ n -} ->
   Float {- ^ sb -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   IO Float
dsdot n sb sx incx sy incy = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   let syDim0 = Call.sizes1 $ Array.shape sy
   Call.assert "dsdot: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "dsdot: 1+(n-1)*abs(incx) == syDim0" (1+(n-1)*abs(incx) == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sbPtr <- Call.float sb
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      syPtr <- Call.array sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.dsdot nPtr sbPtr sxPtr incxPtr syPtr incyPtr

gbmv ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
gbmv trans m kl ku alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.float beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.gbmv transPtr mPtr nPtr klPtr kuPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

gemm ::
   Char {- ^ transa -} ->
   Char {- ^ transb -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO ()
gemm transa transb m k alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let _kb = bDim0
   let ldb = bDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      transaPtr <- Call.char transa
      transbPtr <- Call.char transb
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.gemm transaPtr transbPtr mPtr nPtr kPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

gemv ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
gemv trans m alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.float beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.gemv transPtr mPtr nPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

ger ::
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO ()
ger m alpha x incx y incy a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let _ySize = yDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ger mPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr aPtr ldaPtr

sbmv ::
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
sbmv uplo k alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.float beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.sbmv uploPtr nPtr kPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

symv ::
   Char {- ^ uplo -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
symv uplo alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.float beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.symv uploPtr nPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

syr ::
   Char {- ^ uplo -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO ()
syr uplo alpha x incx a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.syr uploPtr nPtr alphaPtr xPtr incxPtr aPtr ldaPtr

syr2 ::
   Char {- ^ uplo -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO ()
syr2 uplo alpha x incx y incy a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let _ySize = yDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.syr2 uploPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr aPtr ldaPtr

spmv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
spmv uplo n alpha ap x incx beta y incy = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let _apSize = apDim0
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      apPtr <- Call.array ap
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.float beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.spmv uploPtr nPtr alphaPtr apPtr xPtr incxPtr betaPtr yPtr incyPtr

spr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO ()
spr uplo n alpha x incx ap = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let _xSize = xDim0
   let _apSize = apDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      apPtr <- Call.ioarray ap
      liftIO $ FFI.spr uploPtr nPtr alphaPtr xPtr incxPtr apPtr

spr2 ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO ()
spr2 uplo n alpha x incx y incy ap = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let _xSize = xDim0
   let _ySize = yDim0
   let _apSize = apDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      apPtr <- Call.ioarray ap
      liftIO $ FFI.spr2 uploPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr apPtr

iamax ::
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO CInt
iamax n sx incx = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   Call.assert "iamax: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.iamax nPtr sxPtr incxPtr

nrm2 ::
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO Float
nrm2 n x incx = do
   let xDim0 = Call.sizes1 $ Array.shape x
   Call.assert "nrm2: 1+(n-1)*abs(incx) == xDim0" (1+(n-1)*abs(incx) == xDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      liftIO $ FFI.nrm2 nPtr xPtr incxPtr

rot ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   Float {- ^ c -} ->
   Float {- ^ s -} ->
   IO ()
rot n sx incx sy incy c s = do
   let sxDim0 = Call.sizes1 $ MutArray.shape sx
   let syDim0 = Call.sizes1 $ MutArray.shape sy
   Call.assert "rot: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "rot: 1+(n-1)*abs(incy) == syDim0" (1+(n-1)*abs(incy) == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      syPtr <- Call.ioarray sy
      incyPtr <- Call.cint incy
      cPtr <- Call.float c
      sPtr <- Call.float s
      liftIO $ FFI.rot nPtr sxPtr incxPtr syPtr incyPtr cPtr sPtr

rotg ::
   Float {- ^ sa -} ->
   Float {- ^ sb -} ->
   IO (Float, Float)
rotg sa sb = do
   evalContT $ do
      saPtr <- Call.float sa
      sbPtr <- Call.float sb
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      liftIO $ FFI.rotg saPtr sbPtr cPtr sPtr
      liftIO $ pure (,)
         <*> peek cPtr
         <*> peek sPtr

rotm ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   Array ZeroInt Float {- ^ sparam -} ->
   IO ()
rotm n sx incx sy incy sparam = do
   let sxDim0 = Call.sizes1 $ MutArray.shape sx
   let syDim0 = Call.sizes1 $ MutArray.shape sy
   let sparamDim0 = Call.sizes1 $ Array.shape sparam
   Call.assert "rotm: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "rotm: 1+(n-1)*abs(incy) == syDim0" (1+(n-1)*abs(incy) == syDim0)
   Call.assert "rotm: 5 == sparamDim0" (5 == sparamDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      syPtr <- Call.ioarray sy
      incyPtr <- Call.cint incy
      sparamPtr <- Call.array sparam
      liftIO $ FFI.rotm nPtr sxPtr incxPtr syPtr incyPtr sparamPtr

rotmg ::
   Float {- ^ sd1 -} ->
   Float {- ^ sd2 -} ->
   Float {- ^ sx1 -} ->
   Float {- ^ sy1 -} ->
   IO (Float, Float, Float, Array ZeroInt Float)
rotmg sd1 sd2 sx1 sy1 = do
   sparam <- Call.newArray1 5
   evalContT $ do
      sd1Ptr <- Call.float sd1
      sd2Ptr <- Call.float sd2
      sx1Ptr <- Call.float sx1
      sy1Ptr <- Call.float sy1
      sparamPtr <- Call.ioarray sparam
      liftIO $ FFI.rotmg sd1Ptr sd2Ptr sx1Ptr sy1Ptr sparamPtr
      liftIO $ pure (,,,)
         <*> peek sd1Ptr
         <*> peek sd2Ptr
         <*> peek sx1Ptr
         <*> Call.freezeArray sparam

scal ::
   Int {- ^ n -} ->
   Float {- ^ sa -} ->
   IOArray ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO ()
scal n sa sx incx = do
   let sxDim0 = Call.sizes1 $ MutArray.shape sx
   Call.assert "scal: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      saPtr <- Call.float sa
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.scal nPtr saPtr sxPtr incxPtr

swap ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   IO ()
swap n sx incx sy incy = do
   let sxDim0 = Call.sizes1 $ MutArray.shape sx
   let syDim0 = Call.sizes1 $ MutArray.shape sy
   Call.assert "swap: 1+(n-1)*abs(incx) == sxDim0" (1+(n-1)*abs(incx) == sxDim0)
   Call.assert "swap: 1+(n-1)*abs(incy) == syDim0" (1+(n-1)*abs(incy) == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      syPtr <- Call.ioarray sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.swap nPtr sxPtr incxPtr syPtr incyPtr

symm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO ()
symm side uplo m alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   Call.assert "symm: n == cDim0" (n == cDim0)
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.symm sidePtr uploPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

syr2k ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO ()
syr2k uplo trans k alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let _kb = bDim0
   let ldb = bDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.syr2k uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

syrk ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO ()
syrk uplo trans k alpha a beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.syrk uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr betaPtr cPtr ldcPtr

tbmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tbmv uplo trans diag k a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tbmv uploPtr transPtr diagPtr nPtr kPtr aPtr ldaPtr xPtr incxPtr

tbsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tbsv uplo trans diag k a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tbsv uploPtr transPtr diagPtr nPtr kPtr aPtr ldaPtr xPtr incxPtr

tpmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tpmv uplo trans diag n ap x incx = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _apSize = apDim0
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tpmv uploPtr transPtr diagPtr nPtr apPtr xPtr incxPtr

tpsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tpsv uplo trans diag n ap x incx = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _apSize = apDim0
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tpsv uploPtr transPtr diagPtr nPtr apPtr xPtr incxPtr

trmm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ transa -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
trmm side uplo transa diag m alpha a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let _k = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transaPtr <- Call.char transa
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.trmm sidePtr uploPtr transaPtr diagPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr

trmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
trmv uplo trans diag a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.trmv uploPtr transPtr diagPtr nPtr aPtr ldaPtr xPtr incxPtr

trsm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ transa -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
trsm side uplo transa diag m alpha a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let _k = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transaPtr <- Call.char transa
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.trsm sidePtr uploPtr transaPtr diagPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr

trsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
trsv uplo trans diag a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.trsv uploPtr transPtr diagPtr nPtr aPtr ldaPtr xPtr incxPtr
