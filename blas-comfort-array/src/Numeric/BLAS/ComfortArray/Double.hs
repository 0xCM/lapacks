-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.BLAS.ComfortArray.Double where

import qualified Numeric.BLAS.FFI.Double as FFI
import qualified Numeric.Netlib.ComfortArray.Utility as Call
import Numeric.Netlib.ComfortArray.Utility (ZeroInt)

import qualified Data.Array.Comfort.Storable.Mutable as MutArray
import qualified Data.Array.Comfort.Storable as Array
import Data.Array.Comfort.Storable.Mutable (IOArray)
import Data.Array.Comfort.Storable (Array)

import Foreign.Storable.Complex ()
import Foreign.Storable (peek)
import Foreign.C.Types (CInt)

import Control.Monad.Trans.Cont (evalContT)
import Control.Monad.IO.Class (liftIO)
import Control.Applicative (pure, (<*>))


asum ::
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IO Double
asum n dx incx = do
   let dxDim0 = Call.sizes1 $ Array.shape dx
   Call.assert "asum: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.array dx
      incxPtr <- Call.cint incx
      liftIO $ FFI.asum nPtr dxPtr incxPtr

axpy ::
   Int {- ^ n -} ->
   Double {- ^ da -} ->
   Array ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Double {- ^ dy -} ->
   Int {- ^ incy -} ->
   IO ()
axpy n da dx incx dy incy = do
   let dxDim0 = Call.sizes1 $ Array.shape dx
   let dyDim0 = Call.sizes1 $ MutArray.shape dy
   Call.assert "axpy: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   Call.assert "axpy: 1+(n-1)*abs(incy) == dyDim0" (1+(n-1)*abs(incy) == dyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      daPtr <- Call.double da
      dxPtr <- Call.array dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.ioarray dy
      incyPtr <- Call.cint incy
      liftIO $ FFI.axpy nPtr daPtr dxPtr incxPtr dyPtr incyPtr

copy ::
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   Int {- ^ incy -} ->
   IO (Array ZeroInt Double)
copy n dx incx incy = do
   let dxDim0 = Call.sizes1 $ Array.shape dx
   Call.assert "copy: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   dy <- Call.newArray1 (1+(n-1)*abs(incy))
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.array dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.ioarray dy
      incyPtr <- Call.cint incy
      liftIO $ FFI.copy nPtr dxPtr incxPtr dyPtr incyPtr
      liftIO $ Call.freezeArray dy

dot ::
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Double {- ^ dy -} ->
   Int {- ^ incy -} ->
   IO Double
dot n dx incx dy incy = do
   let dxDim0 = Call.sizes1 $ Array.shape dx
   let dyDim0 = Call.sizes1 $ Array.shape dy
   Call.assert "dot: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   Call.assert "dot: 1+(n-1)*abs(incy) == dyDim0" (1+(n-1)*abs(incy) == dyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.array dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.array dy
      incyPtr <- Call.cint incy
      liftIO $ FFI.dot nPtr dxPtr incxPtr dyPtr incyPtr

gbmv ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ beta -} ->
   IOArray ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
gbmv trans m kl ku alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.double beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.gbmv transPtr mPtr nPtr klPtr kuPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

gemm ::
   Char {- ^ transa -} ->
   Char {- ^ transb -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ b -} ->
   Double {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ c -} ->
   IO ()
gemm transa transb m k alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let _kb = bDim0
   let ldb = bDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      transaPtr <- Call.char transa
      transbPtr <- Call.char transb
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.double beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.gemm transaPtr transbPtr mPtr nPtr kPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

gemv ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ beta -} ->
   IOArray ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
gemv trans m alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.double beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.gemv transPtr mPtr nPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

ger ::
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IO ()
ger m alpha x incx y incy a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let _ySize = yDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ger mPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr aPtr ldaPtr

sbmv ::
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ beta -} ->
   IOArray ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
sbmv uplo k alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.double beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.sbmv uploPtr nPtr kPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

symv ::
   Char {- ^ uplo -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ beta -} ->
   IOArray ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
symv uplo alpha a x incx beta y incy = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.double beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.symv uploPtr nPtr alphaPtr aPtr ldaPtr xPtr incxPtr betaPtr yPtr incyPtr

syr ::
   Char {- ^ uplo -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IO ()
syr uplo alpha x incx a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.syr uploPtr nPtr alphaPtr xPtr incxPtr aPtr ldaPtr

syr2 ::
   Char {- ^ uplo -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IO ()
syr2 uplo alpha x incx y incy a = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _xSize = xDim0
   let _ySize = yDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.syr2 uploPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr aPtr ldaPtr

spmv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ ap -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Double {- ^ beta -} ->
   IOArray ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IO ()
spmv uplo n alpha ap x incx beta y incy = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let _apSize = apDim0
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      apPtr <- Call.array ap
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      betaPtr <- Call.double beta
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      liftIO $ FFI.spmv uploPtr nPtr alphaPtr apPtr xPtr incxPtr betaPtr yPtr incyPtr

spr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Double {- ^ ap -} ->
   IO ()
spr uplo n alpha x incx ap = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let _xSize = xDim0
   let _apSize = apDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      apPtr <- Call.ioarray ap
      liftIO $ FFI.spr uploPtr nPtr alphaPtr xPtr incxPtr apPtr

spr2 ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Double {- ^ alpha -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Double {- ^ y -} ->
   Int {- ^ incy -} ->
   IOArray ZeroInt Double {- ^ ap -} ->
   IO ()
spr2 uplo n alpha x incx y incy ap = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let yDim0 = Call.sizes1 $ Array.shape y
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let _xSize = xDim0
   let _ySize = yDim0
   let _apSize = apDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      yPtr <- Call.array y
      incyPtr <- Call.cint incy
      apPtr <- Call.ioarray ap
      liftIO $ FFI.spr2 uploPtr nPtr alphaPtr xPtr incxPtr yPtr incyPtr apPtr

iamax ::
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IO CInt
iamax n dx incx = do
   let dxDim0 = Call.sizes1 $ Array.shape dx
   Call.assert "iamax: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.array dx
      incxPtr <- Call.cint incx
      liftIO $ FFI.iamax nPtr dxPtr incxPtr

nrm2 ::
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO Double
nrm2 n x incx = do
   let xDim0 = Call.sizes1 $ Array.shape x
   Call.assert "nrm2: 1+(n-1)*abs(incx) == xDim0" (1+(n-1)*abs(incx) == xDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      liftIO $ FFI.nrm2 nPtr xPtr incxPtr

rot ::
   Int {- ^ n -} ->
   IOArray ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Double {- ^ dy -} ->
   Int {- ^ incy -} ->
   Double {- ^ c -} ->
   Double {- ^ s -} ->
   IO ()
rot n dx incx dy incy c s = do
   let dxDim0 = Call.sizes1 $ MutArray.shape dx
   let dyDim0 = Call.sizes1 $ MutArray.shape dy
   Call.assert "rot: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   Call.assert "rot: 1+(n-1)*abs(incy) == dyDim0" (1+(n-1)*abs(incy) == dyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.ioarray dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.ioarray dy
      incyPtr <- Call.cint incy
      cPtr <- Call.double c
      sPtr <- Call.double s
      liftIO $ FFI.rot nPtr dxPtr incxPtr dyPtr incyPtr cPtr sPtr

rotg ::
   Double {- ^ da -} ->
   Double {- ^ db -} ->
   IO (Double, Double)
rotg da db = do
   evalContT $ do
      daPtr <- Call.double da
      dbPtr <- Call.double db
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      liftIO $ FFI.rotg daPtr dbPtr cPtr sPtr
      liftIO $ pure (,)
         <*> peek cPtr
         <*> peek sPtr

rotm ::
   Int {- ^ n -} ->
   IOArray ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Double {- ^ dy -} ->
   Int {- ^ incy -} ->
   Array ZeroInt Double {- ^ dparam -} ->
   IO ()
rotm n dx incx dy incy dparam = do
   let dxDim0 = Call.sizes1 $ MutArray.shape dx
   let dyDim0 = Call.sizes1 $ MutArray.shape dy
   let dparamDim0 = Call.sizes1 $ Array.shape dparam
   Call.assert "rotm: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   Call.assert "rotm: 1+(n-1)*abs(incy) == dyDim0" (1+(n-1)*abs(incy) == dyDim0)
   Call.assert "rotm: 5 == dparamDim0" (5 == dparamDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.ioarray dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.ioarray dy
      incyPtr <- Call.cint incy
      dparamPtr <- Call.array dparam
      liftIO $ FFI.rotm nPtr dxPtr incxPtr dyPtr incyPtr dparamPtr

rotmg ::
   Double {- ^ dd1 -} ->
   Double {- ^ dd2 -} ->
   Double {- ^ dx1 -} ->
   Double {- ^ dy1 -} ->
   IO (Double, Double, Double, Array ZeroInt Double)
rotmg dd1 dd2 dx1 dy1 = do
   dparam <- Call.newArray1 5
   evalContT $ do
      dd1Ptr <- Call.double dd1
      dd2Ptr <- Call.double dd2
      dx1Ptr <- Call.double dx1
      dy1Ptr <- Call.double dy1
      dparamPtr <- Call.ioarray dparam
      liftIO $ FFI.rotmg dd1Ptr dd2Ptr dx1Ptr dy1Ptr dparamPtr
      liftIO $ pure (,,,)
         <*> peek dd1Ptr
         <*> peek dd2Ptr
         <*> peek dx1Ptr
         <*> Call.freezeArray dparam

scal ::
   Int {- ^ n -} ->
   Double {- ^ da -} ->
   IOArray ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IO ()
scal n da dx incx = do
   let dxDim0 = Call.sizes1 $ MutArray.shape dx
   Call.assert "scal: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   evalContT $ do
      nPtr <- Call.cint n
      daPtr <- Call.double da
      dxPtr <- Call.ioarray dx
      incxPtr <- Call.cint incx
      liftIO $ FFI.scal nPtr daPtr dxPtr incxPtr

sdot ::
   Array ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ sy -} ->
   Int {- ^ incy -} ->
   IO Double
sdot sx incx sy incy = do
   let sxDim0 = Call.sizes1 $ Array.shape sx
   let syDim0 = Call.sizes1 $ Array.shape sy
   let n = sxDim0
   Call.assert "sdot: n == syDim0" (n == syDim0)
   evalContT $ do
      nPtr <- Call.cint n
      sxPtr <- Call.array sx
      incxPtr <- Call.cint incx
      syPtr <- Call.array sy
      incyPtr <- Call.cint incy
      liftIO $ FFI.sdot nPtr sxPtr incxPtr syPtr incyPtr

swap ::
   Int {- ^ n -} ->
   IOArray ZeroInt Double {- ^ dx -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Double {- ^ dy -} ->
   Int {- ^ incy -} ->
   IO ()
swap n dx incx dy incy = do
   let dxDim0 = Call.sizes1 $ MutArray.shape dx
   let dyDim0 = Call.sizes1 $ MutArray.shape dy
   Call.assert "swap: 1+(n-1)*abs(incx) == dxDim0" (1+(n-1)*abs(incx) == dxDim0)
   Call.assert "swap: 1+(n-1)*abs(incy) == dyDim0" (1+(n-1)*abs(incy) == dyDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dxPtr <- Call.ioarray dx
      incxPtr <- Call.cint incx
      dyPtr <- Call.ioarray dy
      incyPtr <- Call.cint incy
      liftIO $ FFI.swap nPtr dxPtr incxPtr dyPtr incyPtr

symm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ b -} ->
   Double {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ c -} ->
   IO ()
symm side uplo m alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   Call.assert "symm: n == cDim0" (n == cDim0)
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.double beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.symm sidePtr uploPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

syr2k ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ k -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ b -} ->
   Double {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ c -} ->
   IO ()
syr2k uplo trans k alpha a b beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let _kb = bDim0
   let ldb = bDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      betaPtr <- Call.double beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.syr2k uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr bPtr ldbPtr betaPtr cPtr ldcPtr

syrk ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ k -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   Double {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ c -} ->
   IO ()
syrk uplo trans k alpha a beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      betaPtr <- Call.double beta
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      liftIO $ FFI.syrk uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr betaPtr cPtr ldcPtr

tbmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tbmv uplo trans diag k a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tbmv uploPtr transPtr diagPtr nPtr kPtr aPtr ldaPtr xPtr incxPtr

tbsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tbsv uplo trans diag k a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tbsv uploPtr transPtr diagPtr nPtr kPtr aPtr ldaPtr xPtr incxPtr

tpmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ ap -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tpmv uplo trans diag n ap x incx = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _apSize = apDim0
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tpmv uploPtr transPtr diagPtr nPtr apPtr xPtr incxPtr

tpsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Double {- ^ ap -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
tpsv uplo trans diag n ap x incx = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _apSize = apDim0
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.tpsv uploPtr transPtr diagPtr nPtr apPtr xPtr incxPtr

trmm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ transa -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ b -} ->
   IO ()
trmm side uplo transa diag m alpha a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let _k = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transaPtr <- Call.char transa
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.trmm sidePtr uploPtr transaPtr diagPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr

trmv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
trmv uplo trans diag a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.trmv uploPtr transPtr diagPtr nPtr aPtr ldaPtr xPtr incxPtr

trsm ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ transa -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Double {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Double {- ^ b -} ->
   IO ()
trsm side uplo transa diag m alpha a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let _k = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transaPtr <- Call.char transa
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.double alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.trsm sidePtr uploPtr transaPtr diagPtr mPtr nPtr alphaPtr aPtr ldaPtr bPtr ldbPtr

trsv ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Double {- ^ a -} ->
   IOArray ZeroInt Double {- ^ x -} ->
   Int {- ^ incx -} ->
   IO ()
trsv uplo trans diag a x incx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let _xSize = xDim0
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      liftIO $ FFI.trsv uploPtr transPtr diagPtr nPtr aPtr ldaPtr xPtr incxPtr
