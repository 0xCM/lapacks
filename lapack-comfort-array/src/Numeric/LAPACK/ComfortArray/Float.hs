-- Do not edit! Automatically generated by create-lapack-ffi.
module Numeric.LAPACK.ComfortArray.Float where

import qualified Numeric.LAPACK.FFI.Float as FFI
import qualified Numeric.Netlib.ComfortArray.Utility as Call
import Numeric.Netlib.ComfortArray.Utility (ZeroInt, (^!))

import qualified Data.Array.Comfort.Storable.Mutable as MutArray
import qualified Data.Array.Comfort.Storable as Array
import Data.Array.Comfort.Storable.Mutable (IOArray)
import Data.Array.Comfort.Storable (Array)

import Foreign.Storable (peek)
import Foreign.Ptr (Ptr, FunPtr)
import Foreign.C.String (castCCharToChar)
import Foreign.C.Types (CInt)

import Control.Monad.Trans.Cont (evalContT)
import Control.Monad.IO.Class (liftIO)
import Control.Applicative (pure, (<*>))


-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sbbcsd.f>
bbcsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOArray ZeroInt Float {- ^ theta -} ->
   IOArray ZeroInt Float {- ^ phi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u1 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u2 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v1t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v2t -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
bbcsd jobu1 jobu2 jobv1t jobv2t trans m theta phi u1 u2 v1t v2t lwork = do
   let thetaDim0 = Call.sizes1 $ MutArray.shape theta
   let phiDim0 = Call.sizes1 $ MutArray.shape phi
   let (u1Dim0,u1Dim1) = Call.sizes2 $ MutArray.shape u1
   let (u2Dim0,u2Dim1) = Call.sizes2 $ MutArray.shape u2
   let (v1tDim0,v1tDim1) = Call.sizes2 $ MutArray.shape v1t
   let (v2tDim0,v2tDim1) = Call.sizes2 $ MutArray.shape v2t
   let q = thetaDim0
   let p = u1Dim0
   let ldu1 = u1Dim1
   let ldu2 = u2Dim1
   let ldv1t = v1tDim1
   let ldv2t = v2tDim1
   Call.assert "bbcsd: q-1 == phiDim0" (q-1 == phiDim0)
   Call.assert "bbcsd: m-p == u2Dim0" (m-p == u2Dim0)
   Call.assert "bbcsd: q == v1tDim0" (q == v1tDim0)
   Call.assert "bbcsd: m-q == v2tDim0" (m-q == v2tDim0)
   b11d <- Call.newArray1 q
   b11e <- Call.newArray1 (q-1)
   b12d <- Call.newArray1 q
   b12e <- Call.newArray1 (q-1)
   b21d <- Call.newArray1 q
   b21e <- Call.newArray1 (q-1)
   b22d <- Call.newArray1 q
   b22e <- Call.newArray1 (q-1)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      b11dPtr <- Call.ioarray b11d
      b11ePtr <- Call.ioarray b11e
      b12dPtr <- Call.ioarray b12d
      b12ePtr <- Call.ioarray b12e
      b21dPtr <- Call.ioarray b21d
      b21ePtr <- Call.ioarray b21e
      b22dPtr <- Call.ioarray b22d
      b22ePtr <- Call.ioarray b22e
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bbcsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr mPtr pPtr qPtr thetaPtr phiPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr b11dPtr b11ePtr b12dPtr b12ePtr b21dPtr b21ePtr b22dPtr b22ePtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,,,,)
         <*> Call.freezeArray b11d
         <*> Call.freezeArray b11e
         <*> Call.freezeArray b12d
         <*> Call.freezeArray b12e
         <*> Call.freezeArray b21d
         <*> Call.freezeArray b21e
         <*> Call.freezeArray b22d
         <*> Call.freezeArray b22e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sbdsdc.f>
bdsdc ::
   Char {- ^ uplo -} ->
   Char {- ^ compq -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ ldq -} ->
   Int {- ^ ldiq -} ->
   Int {- ^ lwork -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Array ZeroInt CInt, Int)
bdsdc uplo compq d e ldu ldvt ldq ldiq lwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "bdsdc: n-1 == eDim0" (n-1 == eDim0)
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 n ldvt
   q <- Call.newArray1 ldq
   iq <- Call.newArray1 ldiq
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (8*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      compqPtr <- Call.char compq
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      qPtr <- Call.ioarray q
      iqPtr <- Call.ioarray iq
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.bdsdc uploPtr compqPtr nPtr dPtr ePtr uPtr lduPtr vtPtr ldvtPtr qPtr iqPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> Call.freezeArray q
         <*> Call.freezeArray iq
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sbdsqr.f>
bdsqr ::
   Char {- ^ uplo -} ->
   Int {- ^ nru -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vt -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO (Int)
bdsqr uplo nru d e vt u c = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (vtDim0,vtDim1) = Call.sizes2 $ MutArray.shape vt
   let (uDim0,uDim1) = Call.sizes2 $ MutArray.shape u
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let n = dDim0
   let ncvt = vtDim0
   let ldvt = vtDim1
   let ldu = uDim1
   let ncc = cDim0
   let ldc = cDim1
   Call.assert "bdsqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "bdsqr: n == uDim0" (n == uDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      ncvtPtr <- Call.cint ncvt
      nruPtr <- Call.cint nru
      nccPtr <- Call.cint ncc
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.bdsqr uploPtr nPtr ncvtPtr nruPtr nccPtr dPtr ePtr vtPtr ldvtPtr uPtr lduPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sdisna.f>
disna ::
   Char {- ^ job -} ->
   Int {- ^ m -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ d -} ->
   Int {- ^ sepSize -} ->
   IO (Array ZeroInt Float, Int)
disna job m n d sepSize = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let _dSize = dDim0
   sep <- Call.newArray1 sepSize
   evalContT $ do
      jobPtr <- Call.char job
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      dPtr <- Call.array d
      sepPtr <- Call.ioarray sep
      infoPtr <- Call.alloca
      liftIO $ FFI.disna jobPtr mPtr nPtr dPtr sepPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sep
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbbrd.f>
gbbrd ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Int {- ^ ldpt -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
gbbrd vect m kl ku ab ldq ldpt c = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let n = abDim0
   let ldab = abDim1
   let ncc = cDim0
   let ldc = cDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   q <- Call.newArray2 m ldq
   pt <- Call.newArray2 n ldpt
   work <- Call.newArray1 (2*maximum[m,n])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nccPtr <- Call.cint ncc
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ptPtr <- Call.ioarray pt
      ldptPtr <- Call.cint ldpt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gbbrd vectPtr mPtr nPtr nccPtr klPtr kuPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr ptPtr ldptPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray q
         <*> Call.freezeArray pt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbcon.f>
gbcon ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gbcon norm kl ku ab ipiv anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = abDim0
   let ldab = abDim1
   Call.assert "gbcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbcon normPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbequ.f>
gbequ ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Float, Float, Float, Int)
gbequ m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequ mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbequb.f>
gbequb ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Float, Float, Float, Int)
gbequb m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.gbequb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbrfs.f>
gbrfs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ afb -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
gbrfs trans kl ku ab afb ipiv b x = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let (afbDim0,afbDim1) = Call.sizes2 $ Array.shape afb
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "gbrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbrfs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbsv.f>
gbsv ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Array ZeroInt CInt, Int)
gbsv kl ku ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsv nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbsvx.f>
gbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ afb -} ->
   IOArray ZeroInt CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOArray ZeroInt Float {- ^ r -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
gbsvx fact trans kl ku ab afb ipiv equed r c b ldx = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (afbDim0,afbDim1) = Call.sizes2 $ MutArray.shape afb
   let ipivDim0 = Call.sizes1 $ MutArray.shape ipiv
   let rDim0 = Call.sizes1 $ MutArray.shape r
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "gbsvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gbsvx: n == rDim0" (n == rDim0)
   Call.assert "gbsvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gbsvx factPtr transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbtf2.f>
gbtf2 ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Array ZeroInt CInt, Int)
gbtf2 m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtf2 mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbtrf.f>
gbtrf ::
   Int {- ^ m -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Array ZeroInt CInt, Int)
gbtrf m kl ku ab = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrf mPtr nPtr klPtr kuPtr abPtr ldabPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgbtrs.f>
gbtrs ::
   Char {- ^ trans -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
gbtrs trans kl ku ab ipiv b = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gbtrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gbtrs transPtr nPtr klPtr kuPtr nrhsPtr abPtr ldabPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgebak.f>
gebak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   Array ZeroInt Float {- ^ scale -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   IO (Int)
gebak job side ilo ihi scale v = do
   let scaleDim0 = Call.sizes1 $ Array.shape scale
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let n = scaleDim0
   let m = vDim0
   let ldv = vDim1
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      scalePtr <- Call.array scale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.gebak jobPtr sidePtr nPtr iloPtr ihiPtr scalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgebal.f>
gebal ::
   Char {- ^ job -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int, Int, Array ZeroInt Float, Int)
gebal job a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   scale <- Call.newArray1 n
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      infoPtr <- Call.alloca
      liftIO $ FFI.gebal jobPtr nPtr aPtr ldaPtr iloPtr ihiPtr scalePtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgebd2.f>
gebd2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
gebd2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gebd2 mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgebrd.f>
gebrd ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
gebrd m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 (minimum[m,n])
   e <- Call.newArray1 (minimum[m,n]-1)
   tauq <- Call.newArray1 (minimum[m,n])
   taup <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gebrd mPtr nPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgecon.f>
gecon ::
   Char {- ^ norm -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gecon norm a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gecon normPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeequ.f>
geequ ::
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Float, Float, Float, Int)
geequ m a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequ mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeequb.f>
geequb ::
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Float, Float, Float, Int)
geequb m a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   r <- Call.newArray1 m
   c <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      rowcndPtr <- Call.alloca
      colcndPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.geequb mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray r
         <*> Call.freezeArray c
         <*> peek rowcndPtr
         <*> peek colcndPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgees.f>
gees ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Float -> Ptr Float -> IO Bool) {- ^ select -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
gees jobvs sort select a ldvs lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gees jobvsPtr sortPtr selectPtr nPtr aPtr ldaPtr sdimPtr wrPtr wiPtr vsPtr ldvsPtr workPtr lworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vs
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeesx.f>
geesx ::
   Char {- ^ jobvs -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Float -> Ptr Float -> IO Bool) {- ^ select -} ->
   Char {- ^ sense -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldvs -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Float, Float, Int)
geesx jobvs sort select sense a ldvs lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vs <- Call.newArray2 n ldvs
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvsPtr <- Call.char jobvs
      sortPtr <- Call.char sort
      selectPtr <- pure select
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sdimPtr <- Call.alloca
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vsPtr <- Call.ioarray vs
      ldvsPtr <- Call.cint ldvs
      rcondePtr <- Call.alloca
      rcondvPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geesx jobvsPtr sortPtr selectPtr sensePtr nPtr aPtr ldaPtr sdimPtr wrPtr wiPtr vsPtr ldvsPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr liworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vs
         <*> peek rcondePtr
         <*> peek rcondvPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeev.f>
geev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
geev jobvl jobvr a ldvl ldvr lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geev jobvlPtr jobvrPtr nPtr aPtr ldaPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeevx.f>
geevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int, Int, Array ZeroInt Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
geevx balanc jobvl jobvr sense a ldvl ldvr lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   scale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (2*n-2)
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      scalePtr <- Call.ioarray scale
      abnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr scalePtr abnrmPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray scale
         <*> peek abnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgehd2.f>
gehd2 ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
gehd2 ilo ihi a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gehd2 nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgehrd.f>
gehrd ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
gehrd ilo ihi a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 lwork
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gehrd nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgejsv.f>
gejsv ::
   Char {- ^ joba -} ->
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Char {- ^ jobr -} ->
   Char {- ^ jobt -} ->
   Char {- ^ jobp -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldv -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
gejsv joba jobu jobv jobr jobt jobp m a ldu ldv lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   sva <- Call.newArray1 n
   u <- Call.newArray2 n ldu
   v <- Call.newArray2 n ldv
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 (m+3*n)
   evalContT $ do
      jobaPtr <- Call.char joba
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      jobrPtr <- Call.char jobr
      jobtPtr <- Call.char jobt
      jobpPtr <- Call.char jobp
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      svaPtr <- Call.ioarray sva
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gejsv jobaPtr jobuPtr jobvPtr jobrPtr jobtPtr jobpPtr mPtr nPtr aPtr ldaPtr svaPtr uPtr lduPtr vPtr ldvPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray sva
         <*> Call.freezeArray u
         <*> Call.freezeArray v
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgelq2.f>
gelq2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
gelq2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gelq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgelqf.f>
gelqf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
gelqf m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgels.f>
gels ::
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gels trans m a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gels transPtr mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgelsd.f>
gelsd ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Int, Int)
gelsd m a b rcond lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsd mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgelss.f>
gelss ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int, Int)
gelss m a b rcond lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   s <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sPtr <- Call.ioarray s
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelss mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr sPtr rcondPtr rankPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgelsy.f>
gelsy ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray ZeroInt CInt {- ^ jpvt -} ->
   Float {- ^ rcond -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int)
gelsy m a b jpvt rcond lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let jpvtDim0 = Call.sizes1 $ MutArray.shape jpvt
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gelsy: n == jpvtDim0" (n == jpvtDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      jpvtPtr <- Call.ioarray jpvt
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gelsy mPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr jpvtPtr rcondPtr rankPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeql2.f>
geql2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
geql2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geql2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqlf.f>
geqlf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
geqlf m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqlf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqp3.f>
geqp3 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt CInt {- ^ jpvt -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
geqp3 m a jpvt lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let jpvtDim0 = Call.sizes1 $ MutArray.shape jpvt
   let n = aDim0
   let lda = aDim1
   Call.assert "geqp3: n == jpvtDim0" (n == jpvtDim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqp3 mPtr nPtr aPtr ldaPtr jpvtPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqr2.f>
geqr2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
geqr2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqr2p.f>
geqr2p ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
geqr2p m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.geqr2p mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqrf.f>
geqrf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
geqrf m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgeqrfp.f>
geqrfp ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
geqrfp m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.geqrfp mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgerfs.f>
gerfs ::
   Char {- ^ trans -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ af -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
gerfs trans a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (afDim0,afDim1) = Call.sizes2 $ Array.shape af
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gerfs: n == afDim0" (n == afDim0)
   Call.assert "gerfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gerfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerfs transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgerq2.f>
gerq2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
gerq2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.gerq2 mPtr nPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgerqf.f>
gerqf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
gerqf m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gerqf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesc2.f>
gesc2 ::
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ rhs -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array ZeroInt CInt {- ^ jpiv -} ->
   IO (Float)
gesc2 a rhs ipiv jpiv = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let rhsDim0 = Call.sizes1 $ MutArray.shape rhs
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let jpivDim0 = Call.sizes1 $ Array.shape jpiv
   let n = aDim0
   let lda = aDim1
   Call.assert "gesc2: n == rhsDim0" (n == rhsDim0)
   Call.assert "gesc2: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesc2: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rhsPtr <- Call.ioarray rhs
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      scalePtr <- Call.alloca
      liftIO $ FFI.gesc2 nPtr aPtr ldaPtr rhsPtr ipivPtr jpivPtr scalePtr
      liftIO $ peek scalePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesdd.f>
gesdd ::
   Char {- ^ jobz -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
gesdd jobz m a ucol ldu ldvt lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (8*minimum[m,n])
   evalContT $ do
      jobzPtr <- Call.char jobz
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesdd jobzPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesv.f>
gesv ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Array ZeroInt CInt, Int)
gesv a b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gesv nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesvd.f>
gesvd ::
   Char {- ^ jobu -} ->
   Char {- ^ jobvt -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ucol -} ->
   Int {- ^ ldu -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
gesvd jobu jobvt m a ucol ldu ldvt lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 (minimum[m,n])
   u <- Call.newArray2 ucol ldu
   vt <- Call.newArray2 n ldvt
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvtPtr <- Call.char jobvt
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvd jobuPtr jobvtPtr mPtr nPtr aPtr ldaPtr sPtr uPtr lduPtr vtPtr ldvtPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesvj.f>
gesvj ::
   Char {- ^ joba -} ->
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ mv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   IOArray ZeroInt Float {- ^ work -} ->
   IO (Array ZeroInt Float, Int)
gesvj joba jobu jobv m a mv v work = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let workDim0 = Call.sizes1 $ MutArray.shape work
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   let lwork = workDim0
   Call.assert "gesvj: n == vDim0" (n == vDim0)
   sva <- Call.newArray1 n
   evalContT $ do
      jobaPtr <- Call.char joba
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvj jobaPtr jobuPtr jobvPtr mPtr nPtr aPtr ldaPtr svaPtr mvPtr vPtr ldvPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray sva
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgesvx.f>
gesvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ af -} ->
   IOArray ZeroInt CInt {- ^ ipiv -} ->
   Char {- ^ equed -} ->
   IOArray ZeroInt Float {- ^ r -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
gesvx fact trans a af ipiv equed r c b ldx = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (afDim0,afDim1) = Call.sizes2 $ MutArray.shape af
   let ipivDim0 = Call.sizes1 $ MutArray.shape ipiv
   let rDim0 = Call.sizes1 $ MutArray.shape r
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gesvx: n == afDim0" (n == afDim0)
   Call.assert "gesvx: n == ipivDim0" (n == ipivDim0)
   Call.assert "gesvx: n == rDim0" (n == rDim0)
   Call.assert "gesvx: n == cDim0" (n == cDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      equedPtr <- Call.char equed
      rPtr <- Call.ioarray r
      cPtr <- Call.ioarray c
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gesvx factPtr transPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr equedPtr rPtr cPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgetc2.f>
getc2 ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt CInt, Array ZeroInt CInt, Int)
getc2 a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   jpiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      jpivPtr <- Call.ioarray jpiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getc2 nPtr aPtr ldaPtr ipivPtr jpivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray jpiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgetf2.f>
getf2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt CInt, Int)
getf2 m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getf2 mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgetrf.f>
getrf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt CInt, Int)
getrf m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 (minimum[m,n])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.getrf mPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgetri.f>
getri ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Int {- ^ lwork -} ->
   IO (Int)
getri a ipiv lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "getri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.getri nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgetrs.f>
getrs ::
   Char {- ^ trans -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
getrs trans a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "getrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.getrs transPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggbak.f>
ggbak ::
   Char {- ^ job -} ->
   Char {- ^ side -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   Array ZeroInt Float {- ^ lscale -} ->
   Array ZeroInt Float {- ^ rscale -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   IO (Int)
ggbak job side ilo ihi lscale rscale v = do
   let lscaleDim0 = Call.sizes1 $ Array.shape lscale
   let rscaleDim0 = Call.sizes1 $ Array.shape rscale
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let n = lscaleDim0
   let m = vDim0
   let ldv = vDim1
   Call.assert "ggbak: n == rscaleDim0" (n == rscaleDim0)
   evalContT $ do
      jobPtr <- Call.char job
      sidePtr <- Call.char side
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      lscalePtr <- Call.array lscale
      rscalePtr <- Call.array rscale
      mPtr <- Call.cint m
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbak jobPtr sidePtr nPtr iloPtr ihiPtr lscalePtr rscalePtr mPtr vPtr ldvPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggbal.f>
ggbal ::
   Char {- ^ job -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, Array ZeroInt Float, Array ZeroInt Float, Int)
ggbal job a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggbal: n == bDim0" (n == bDim0)
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ggbal jobPtr nPtr aPtr ldaPtr bPtr ldbPtr iloPtr ihiPtr lscalePtr rscalePtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgges.f>
gges ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Float -> Ptr Float -> Ptr Float -> IO Bool) {- ^ selctg -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
gges jobvsl jobvsr sort selctg a b ldvsl ldvsr lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "gges: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   work <- Call.newArray1 (maximum[1,lwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gges jobvslPtr jobvsrPtr sortPtr selctgPtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alpharPtr alphaiPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr workPtr lworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggesx.f>
ggesx ::
   Char {- ^ jobvsl -} ->
   Char {- ^ jobvsr -} ->
   Char {- ^ sort -} ->
   FunPtr (Ptr Float -> Ptr Float -> Ptr Float -> IO Bool) {- ^ selctg -} ->
   Char {- ^ sense -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldvsl -} ->
   Int {- ^ ldvsr -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Array ZeroInt Float, Int)
ggesx jobvsl jobvsr sort selctg sense a b ldvsl ldvsr lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggesx: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vsl <- Call.newArray2 n ldvsl
   vsr <- Call.newArray2 n ldvsr
   rconde <- Call.newArray1 2
   rcondv <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   bwork <- Call.newArray1 n
   evalContT $ do
      jobvslPtr <- Call.char jobvsl
      jobvsrPtr <- Call.char jobvsr
      sortPtr <- Call.char sort
      selctgPtr <- pure selctg
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      sdimPtr <- Call.alloca
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vslPtr <- Call.ioarray vsl
      ldvslPtr <- Call.cint ldvsl
      vsrPtr <- Call.ioarray vsr
      ldvsrPtr <- Call.cint ldvsr
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggesx jobvslPtr jobvsrPtr sortPtr selctgPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr sdimPtr alpharPtr alphaiPtr betaPtr vslPtr ldvslPtr vsrPtr ldvsrPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr liworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,,)
         <*> fmap fromIntegral (peek sdimPtr)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vsl
         <*> Call.freezeArray vsr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggev.f>
ggev ::
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
ggev jobvl jobvr a b ldvl ldvr lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggev: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggev jobvlPtr jobvrPtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggevx.f>
ggevx ::
   Char {- ^ balanc -} ->
   Char {- ^ jobvl -} ->
   Char {- ^ jobvr -} ->
   Char {- ^ sense -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldvl -} ->
   Int {- ^ ldvr -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int, Int, Array ZeroInt Float, Array ZeroInt Float, Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
ggevx balanc jobvl jobvr sense a b ldvl ldvr lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggevx: n == bDim0" (n == bDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   vl <- Call.newArray2 n ldvl
   vr <- Call.newArray2 n ldvr
   lscale <- Call.newArray1 n
   rscale <- Call.newArray1 n
   rconde <- Call.newArray1 n
   rcondv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (n+6)
   bwork <- Call.newArray1 n
   evalContT $ do
      balancPtr <- Call.char balanc
      jobvlPtr <- Call.char jobvl
      jobvrPtr <- Call.char jobvr
      sensePtr <- Call.char sense
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      iloPtr <- Call.alloca
      ihiPtr <- Call.alloca
      lscalePtr <- Call.ioarray lscale
      rscalePtr <- Call.ioarray rscale
      abnrmPtr <- Call.alloca
      bbnrmPtr <- Call.alloca
      rcondePtr <- Call.ioarray rconde
      rcondvPtr <- Call.ioarray rcondv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      bworkPtr <- Call.ioarray bwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggevx balancPtr jobvlPtr jobvrPtr sensePtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr vlPtr ldvlPtr vrPtr ldvrPtr iloPtr ihiPtr lscalePtr rscalePtr abnrmPtr bbnrmPtr rcondePtr rcondvPtr workPtr lworkPtr iworkPtr bworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> Call.freezeArray vl
         <*> Call.freezeArray vr
         <*> fmap fromIntegral (peek iloPtr)
         <*> fmap fromIntegral (peek ihiPtr)
         <*> Call.freezeArray lscale
         <*> Call.freezeArray rscale
         <*> peek abnrmPtr
         <*> peek bbnrmPtr
         <*> Call.freezeArray rconde
         <*> Call.freezeArray rcondv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggglm.f>
ggglm ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
ggglm a b d lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   let n = dDim0
   x <- Call.newArray1 m
   y <- Call.newArray1 p
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggglm nPtr mPtr pPtr aPtr ldaPtr bPtr ldbPtr dPtr xPtr yPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray x
         <*> Call.freezeArray y
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgghrd.f>
gghrd ::
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   IO (Int)
gghrd compq compz ilo ihi a b q z = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "gghrd: n == bDim0" (n == bDim0)
   Call.assert "gghrd: n == qDim0" (n == qDim0)
   Call.assert "gghrd: n == zDim0" (n == zDim0)
   evalContT $ do
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.gghrd compqPtr compzPtr nPtr iloPtr ihiPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgglse.f>
gglse ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
gglse a b c d lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = cDim0
   let p = dDim0
   Call.assert "gglse: n == bDim0" (n == bDim0)
   x <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      dPtr <- Call.ioarray d
      xPtr <- Call.ioarray x
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gglse mPtr nPtr pPtr aPtr ldaPtr bPtr ldbPtr cPtr dPtr xPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggqrf.f>
ggqrf ::
   Int {- ^ n -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
ggqrf n a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let m = aDim0
   let lda = aDim1
   let p = bDim0
   let ldb = bDim1
   taua <- Call.newArray1 (minimum[n,m])
   taub <- Call.newArray1 (minimum[n,p])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggqrf nPtr mPtr pPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggrqf.f>
ggrqf ::
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
ggrqf m p a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "ggrqf: n == bDim0" (n == bDim0)
   taua <- Call.newArray1 (minimum[m,n])
   taub <- Call.newArray1 (minimum[p,n])
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauaPtr <- Call.ioarray taua
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      taubPtr <- Call.ioarray taub
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ggrqf mPtr pPtr nPtr aPtr ldaPtr tauaPtr bPtr ldbPtr taubPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray taua
         <*> Call.freezeArray taub
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgsvj0.f>
gsvj0 ::
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ sva -} ->
   Int {- ^ mv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Float {- ^ eps -} ->
   Float {- ^ sfmin -} ->
   Float {- ^ tol -} ->
   Int {- ^ nsweep -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gsvj0 jobv m a d sva mv v eps sfmin tol nsweep lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let svaDim0 = Call.sizes1 $ MutArray.shape sva
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   Call.assert "gsvj0: n == dDim0" (n == dDim0)
   Call.assert "gsvj0: n == svaDim0" (n == svaDim0)
   Call.assert "gsvj0: n == vDim0" (n == vDim0)
   work <- Call.newArray1 lwork
   evalContT $ do
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      epsPtr <- Call.float eps
      sfminPtr <- Call.float sfmin
      tolPtr <- Call.float tol
      nsweepPtr <- Call.cint nsweep
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gsvj0 jobvPtr mPtr nPtr aPtr ldaPtr dPtr svaPtr mvPtr vPtr ldvPtr epsPtr sfminPtr tolPtr nsweepPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgsvj1.f>
gsvj1 ::
   Char {- ^ jobv -} ->
   Int {- ^ m -} ->
   Int {- ^ n1 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ sva -} ->
   Int {- ^ mv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Float {- ^ eps -} ->
   Float {- ^ sfmin -} ->
   Float {- ^ tol -} ->
   Int {- ^ nsweep -} ->
   Int {- ^ lwork -} ->
   IO (Int)
gsvj1 jobv m n1 a d sva mv v eps sfmin tol nsweep lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let svaDim0 = Call.sizes1 $ MutArray.shape sva
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let n = aDim0
   let lda = aDim1
   let ldv = vDim1
   Call.assert "gsvj1: n == dDim0" (n == dDim0)
   Call.assert "gsvj1: n == svaDim0" (n == svaDim0)
   Call.assert "gsvj1: n == vDim0" (n == vDim0)
   work <- Call.newArray1 lwork
   evalContT $ do
      jobvPtr <- Call.char jobv
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      svaPtr <- Call.ioarray sva
      mvPtr <- Call.cint mv
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      epsPtr <- Call.float eps
      sfminPtr <- Call.float sfmin
      tolPtr <- Call.float tol
      nsweepPtr <- Call.cint nsweep
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gsvj1 jobvPtr mPtr nPtr n1Ptr aPtr ldaPtr dPtr svaPtr mvPtr vPtr ldvPtr epsPtr sfminPtr tolPtr nsweepPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgtcon.f>
gtcon ::
   Char {- ^ norm -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   Array ZeroInt Float {- ^ du2 -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
gtcon norm dl d du du2 ipiv anorm = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let du2Dim0 = Call.sizes1 $ Array.shape du2
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = dDim0
   Call.assert "gtcon: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtcon: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtcon: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtcon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtcon normPtr nPtr dlPtr dPtr duPtr du2Ptr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgtrfs.f>
gtrfs ::
   Char {- ^ trans -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   Array ZeroInt Float {- ^ dlf -} ->
   Array ZeroInt Float {- ^ df -} ->
   Array ZeroInt Float {- ^ duf -} ->
   Array ZeroInt Float {- ^ du2 -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
gtrfs trans dl d du dlf df duf du2 ipiv b x = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let dlfDim0 = Call.sizes1 $ Array.shape dlf
   let dfDim0 = Call.sizes1 $ Array.shape df
   let dufDim0 = Call.sizes1 $ Array.shape duf
   let du2Dim0 = Call.sizes1 $ Array.shape du2
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "gtrfs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtrfs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtrfs: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtrfs: n == dfDim0" (n == dfDim0)
   Call.assert "gtrfs: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtrfs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "gtrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.array dlf
      dfPtr <- Call.array df
      dufPtr <- Call.array duf
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtrfs transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgtsv.f>
gtsv ::
   IOArray ZeroInt Float {- ^ dl -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ du -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
gtsv dl d du b = do
   let dlDim0 = Call.sizes1 $ MutArray.shape dl
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let duDim0 = Call.sizes1 $ MutArray.shape du
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsv: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsv: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsv nPtr nrhsPtr dlPtr dPtr duPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgtsvx.f>
gtsvx ::
   Char {- ^ fact -} ->
   Char {- ^ trans -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   IOArray ZeroInt Float {- ^ dlf -} ->
   IOArray ZeroInt Float {- ^ df -} ->
   IOArray ZeroInt Float {- ^ duf -} ->
   IOArray ZeroInt Float {- ^ du2 -} ->
   IOArray ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
gtsvx fact trans dl d du dlf df duf du2 ipiv b ldx = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let dlfDim0 = Call.sizes1 $ MutArray.shape dlf
   let dfDim0 = Call.sizes1 $ MutArray.shape df
   let dufDim0 = Call.sizes1 $ MutArray.shape duf
   let du2Dim0 = Call.sizes1 $ MutArray.shape du2
   let ipivDim0 = Call.sizes1 $ MutArray.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtsvx: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtsvx: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtsvx: n-1 == dlfDim0" (n-1 == dlfDim0)
   Call.assert "gtsvx: n == dfDim0" (n == dfDim0)
   Call.assert "gtsvx: n-1 == dufDim0" (n-1 == dufDim0)
   Call.assert "gtsvx: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtsvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      dlfPtr <- Call.ioarray dlf
      dfPtr <- Call.ioarray df
      dufPtr <- Call.ioarray duf
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.gtsvx factPtr transPtr nPtr nrhsPtr dlPtr dPtr duPtr dlfPtr dfPtr dufPtr du2Ptr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgttrf.f>
gttrf ::
   IOArray ZeroInt Float {- ^ dl -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ du -} ->
   IO (Array ZeroInt Float, Array ZeroInt CInt, Int)
gttrf dl d du = do
   let dlDim0 = Call.sizes1 $ MutArray.shape dl
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let duDim0 = Call.sizes1 $ MutArray.shape du
   let n = dDim0
   Call.assert "gttrf: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrf: n-1 == duDim0" (n-1 == duDim0)
   du2 <- Call.newArray1 (n-2)
   ipiv <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dlPtr <- Call.ioarray dl
      dPtr <- Call.ioarray d
      duPtr <- Call.ioarray du
      du2Ptr <- Call.ioarray du2
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrf nPtr dlPtr dPtr duPtr du2Ptr ipivPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray du2
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgttrs.f>
gttrs ::
   Char {- ^ trans -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   Array ZeroInt Float {- ^ du2 -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
gttrs trans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let du2Dim0 = Call.sizes1 $ Array.shape du2
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gttrs: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gttrs: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gttrs: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gttrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.gttrs transPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sgtts2.f>
gtts2 ::
   Int {- ^ itrans -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   Array ZeroInt Float {- ^ du2 -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
gtts2 itrans dl d du du2 ipiv b = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let du2Dim0 = Call.sizes1 $ Array.shape du2
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "gtts2: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "gtts2: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "gtts2: n-2 == du2Dim0" (n-2 == du2Dim0)
   Call.assert "gtts2: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      itransPtr <- Call.cint itrans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      du2Ptr <- Call.array du2
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.gtts2 itransPtr nPtr nrhsPtr dlPtr dPtr duPtr du2Ptr ipivPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbev.f>
sbev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ ldz -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
sbev jobz uplo kd ab ldz = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,3*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbev jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbevd.f>
sbevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ ldz -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
sbevd jobz uplo kd ab ldz workSize lwork liwork = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sbevd jobzPtr uploPtr nPtr kdPtr abPtr ldabPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbevx.f>
sbevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ ldq -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
sbevx jobz range uplo kd ab ldq vl vu il iu abstol m ldz = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sbevx jobzPtr rangePtr uploPtr nPtr kdPtr abPtr ldabPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbgst.f>
sbgst ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ bb -} ->
   Int {- ^ ldx -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
sbgst vect uplo ka kb ab bb ldx = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bbDim0,bbDim1) = Call.sizes2 $ Array.shape bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgst: n == bbDim0" (n == bbDim0)
   x <- Call.newArray2 n ldx
   work <- Call.newArray1 (2*n)
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.array bb
      ldbbPtr <- Call.cint ldbb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgst vectPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr xPtr ldxPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray x
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbgv.f>
sbgv ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ bb -} ->
   Int {- ^ ldz -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
sbgv jobz uplo ka kb ab bb ldz = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bbDim0,bbDim1) = Call.sizes2 $ MutArray.shape bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgv: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgv jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbgvd.f>
sbgvd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ bb -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
sbgvd jobz uplo ka kb ab bb ldz lwork liwork = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bbDim0,bbDim1) = Call.sizes2 $ MutArray.shape bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgvd: n == bbDim0" (n == bbDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgvd jobzPtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbgvx.f>
sbgvx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ ka -} ->
   Int {- ^ kb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ bb -} ->
   Int {- ^ ldq -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ ldz -} ->
   Int {- ^ m -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
sbgvx jobz range uplo ka kb ab bb ldq vl vu il iu abstol ldz m = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bbDim0,bbDim1) = Call.sizes2 $ MutArray.shape bb
   let n = abDim0
   let ldab = abDim1
   let ldbb = bbDim1
   Call.assert "sbgvx: n == bbDim0" (n == bbDim0)
   q <- Call.newArray2 n ldq
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (7*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 m
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kaPtr <- Call.cint ka
      kbPtr <- Call.cint kb
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bbPtr <- Call.ioarray bb
      ldbbPtr <- Call.cint ldbb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sbgvx jobzPtr rangePtr uploPtr nPtr kaPtr kbPtr abPtr ldabPtr bbPtr ldbbPtr qPtr ldqPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssbtrd.f>
sbtrd ::
   Char {- ^ vect -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
sbtrd vect uplo kd ab q = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = abDim0
   let ldab = abDim1
   let ldq = qDim1
   Call.assert "sbtrd: n == qDim0" (n == qDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   work <- Call.newArray1 n
   evalContT $ do
      vectPtr <- Call.char vect
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sbtrd vectPtr uploPtr nPtr kdPtr abPtr ldabPtr dPtr ePtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyev.f>
syev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
syev jobz uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syev jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevd.f>
syevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Int)
syevd jobz uplo a workSize lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syevd jobzPtr uploPtr nPtr aPtr ldaPtr wPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevr.f>
syevr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
syevr jobz range uplo a vl vu il iu abstol m ldz lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syevr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevx.f>
syevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
syevx jobz range uplo a vl vu il iu abstol m ldz lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.syevx jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygs2.f>
sygs2 ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
sygs2 itype uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygs2: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sygs2 itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygst.f>
sygst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
sygst itype uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygst: n == bDim0" (n == bDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sygst itypePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygv.f>
sygv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
sygv itype jobz uplo a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygv: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sygv itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygvd.f>
sygvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Int)
sygvd itype jobz uplo a b lwork liwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygvd: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      wPtr <- Call.ioarray w
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sygvd itypePtr jobzPtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr wPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygvx.f>
sygvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
sygvx itype jobz range uplo a b vl vu il iu abstol m ldz lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   Call.assert "sygvx: n == bDim0" (n == bDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.sygvx itypePtr jobzPtr rangePtr uploPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssfrk.f>
sfrk ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Float {- ^ alpha -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   IO ()
sfrk transr uplo trans n k alpha a beta c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let _ka = aDim0
   let lda = aDim1
   let _nt = cDim0
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      betaPtr <- Call.float beta
      cPtr <- Call.ioarray c
      liftIO $ FFI.sfrk transrPtr uploPtr transPtr nPtr kPtr alphaPtr aPtr ldaPtr betaPtr cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/shgeqz.f>
hgeqz ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
hgeqz job compq compz ilo ihi h t q z lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (tDim0,tDim1) = Call.sizes2 $ MutArray.shape t
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ldt = tDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "hgeqz: n == tDim0" (n == tDim0)
   Call.assert "hgeqz: n == qDim0" (n == qDim0)
   Call.assert "hgeqz: n == zDim0" (n == zDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hgeqz jobPtr compqPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr tPtr ldtPtr alpharPtr alphaiPtr betaPtr qPtr ldqPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspev.f>
spev ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Int {- ^ ldz -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
spev jobz uplo n ap ldz = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "spev: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.spev jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspevd.f>
spevd ::
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
spevd jobz uplo n ap ldz lwork liwork = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "spevd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spevd jobzPtr uploPtr nPtr apPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspevx.f>
spevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
spevx jobz range uplo n ap vl vu il iu abstol m ldz = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "spevx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (8*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.spevx jobzPtr rangePtr uploPtr nPtr apPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspgst.f>
spgst ::
   Int {- ^ itype -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ bp -} ->
   IO (Int)
spgst itype uplo n ap bp = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let bpDim0 = Call.sizes1 $ Array.shape bp
   Call.assert "spgst: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgst: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   evalContT $ do
      itypePtr <- Call.cint itype
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.array bp
      infoPtr <- Call.alloca
      liftIO $ FFI.spgst itypePtr uploPtr nPtr apPtr bpPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspgv.f>
spgv ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ bp -} ->
   Int {- ^ ldz -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
spgv itype jobz uplo n ap bp ldz = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let bpDim0 = Call.sizes1 $ MutArray.shape bp
   Call.assert "spgv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgv: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (3*n)
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.spgv itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspgvd.f>
spgvd ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ bp -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
spgvd itype jobz uplo n ap bp ldz lwork liwork = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let bpDim0 = Call.sizes1 $ MutArray.shape bp
   Call.assert "spgvd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgvd: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spgvd itypePtr jobzPtr uploPtr nPtr apPtr bpPtr wPtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspgvx.f>
spgvx ::
   Int {- ^ itype -} ->
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ bp -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
spgvx itype jobz range uplo n ap bp vl vu il iu abstol m ldz = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let bpDim0 = Call.sizes1 $ MutArray.shape bp
   Call.assert "spgvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spgvx: n*(n+1)`div`2 == bpDim0" (n*(n+1)`div`2 == bpDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (8*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      itypePtr <- Call.cint itype
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      bpPtr <- Call.ioarray bp
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.spgvx itypePtr jobzPtr rangePtr uploPtr nPtr apPtr bpPtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssptrd.f>
sptrd ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
sptrd uplo n ap = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "sptrd: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrd uploPtr nPtr apPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/shsein.f>
hsein ::
   Char {- ^ side -} ->
   Char {- ^ eigsrc -} ->
   Char {- ^ initv -} ->
   IOArray ZeroInt Bool {- ^ select -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ h -} ->
   IOArray ZeroInt Float {- ^ wr -} ->
   Array ZeroInt Float {- ^ wi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vl -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vr -} ->
   IO (Int, Array ZeroInt CInt, Array ZeroInt CInt, Int)
hsein side eigsrc initv select h wr wi vl vr = do
   let selectDim0 = Call.sizes1 $ MutArray.shape select
   let (hDim0,hDim1) = Call.sizes2 $ Array.shape h
   let wrDim0 = Call.sizes1 $ MutArray.shape wr
   let wiDim0 = Call.sizes1 $ Array.shape wi
   let (vlDim0,vlDim1) = Call.sizes2 $ MutArray.shape vl
   let (vrDim0,vrDim1) = Call.sizes2 $ MutArray.shape vr
   let n = selectDim0
   let ldh = hDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "hsein: n == hDim0" (n == hDim0)
   Call.assert "hsein: n == wrDim0" (n == wrDim0)
   Call.assert "hsein: n == wiDim0" (n == wiDim0)
   Call.assert "hsein: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 ((n+2)*n)
   ifaill <- Call.newArray1 mm
   ifailr <- Call.newArray1 mm
   evalContT $ do
      sidePtr <- Call.char side
      eigsrcPtr <- Call.char eigsrc
      initvPtr <- Call.char initv
      selectPtr <- Call.ioarray select
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.array wi
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      ifaillPtr <- Call.ioarray ifaill
      ifailrPtr <- Call.ioarray ifailr
      infoPtr <- Call.alloca
      liftIO $ FFI.hsein sidePtr eigsrcPtr initvPtr selectPtr nPtr hPtr ldhPtr wrPtr wiPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr ifaillPtr ifailrPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray ifaill
         <*> Call.freezeArray ifailr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/shseqr.f>
hseqr ::
   Char {- ^ job -} ->
   Char {- ^ compz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
hseqr job compz ilo ihi h z lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "hseqr: n == zDim0" (n == zDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   work <- Call.newArray1 lwork
   evalContT $ do
      jobPtr <- Call.char job
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.hseqr jobPtr compzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaslc.f>
ilalc ::
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO CInt
ilalc m a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalc mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaslr.f>
ilalr ::
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO CInt
ilalr m a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.ilalr mPtr nPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sisnan.f>
isnan ::
   Float {- ^ sin_ -} ->
   IO Bool
isnan sin_ = do
   evalContT $ do
      sin_Ptr <- Call.float sin_
      liftIO $ FFI.isnan sin_Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slabad.f>
labad ::
   Float {- ^ small -} ->
   Float {- ^ large -} ->
   IO (Float, Float)
labad small large = do
   evalContT $ do
      smallPtr <- Call.float small
      largePtr <- Call.float large
      liftIO $ FFI.labad smallPtr largePtr
      liftIO $ pure (,)
         <*> peek smallPtr
         <*> peek largePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slabrd.f>
labrd ::
   Int {- ^ m -} ->
   Int {- ^ nb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldx -} ->
   Int {- ^ ldy -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float)
labrd m nb a ldx ldy = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 nb
   e <- Call.newArray1 nb
   tauq <- Call.newArray1 nb
   taup <- Call.newArray1 nb
   x <- Call.newArray2 nb ldx
   y <- Call.newArray2 nb ldy
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauqPtr <- Call.ioarray tauq
      taupPtr <- Call.ioarray taup
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.labrd mPtr nPtr nbPtr aPtr ldaPtr dPtr ePtr tauqPtr taupPtr xPtr ldxPtr yPtr ldyPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tauq
         <*> Call.freezeArray taup
         <*> Call.freezeArray x
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slacn2.f>
lacn2 ::
   IOArray ZeroInt Float {- ^ x -} ->
   Float {- ^ est -} ->
   Int {- ^ kase -} ->
   IOArray ZeroInt CInt {- ^ isave -} ->
   IO (Array ZeroInt Float, Array ZeroInt CInt, Float, Int)
lacn2 x est kase isave = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let isaveDim0 = Call.sizes1 $ MutArray.shape isave
   let n = xDim0
   Call.assert "lacn2: 3 == isaveDim0" (3 == isaveDim0)
   v <- Call.newArray1 n
   isgn <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      isgnPtr <- Call.ioarray isgn
      estPtr <- Call.float est
      kasePtr <- Call.cint kase
      isavePtr <- Call.ioarray isave
      liftIO $ FFI.lacn2 nPtr vPtr xPtr isgnPtr estPtr kasePtr isavePtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray isgn
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slacon.f>
lacon ::
   IOArray ZeroInt Float {- ^ x -} ->
   Float {- ^ est -} ->
   Int {- ^ kase -} ->
   IO (Array ZeroInt Float, Array ZeroInt CInt, Float, Int)
lacon x est kase = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = xDim0
   v <- Call.newArray1 n
   isgn <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      vPtr <- Call.ioarray v
      xPtr <- Call.ioarray x
      isgnPtr <- Call.ioarray isgn
      estPtr <- Call.float est
      kasePtr <- Call.cint kase
      liftIO $ FFI.lacon nPtr vPtr xPtr isgnPtr estPtr kasePtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray isgn
         <*> peek estPtr
         <*> fmap fromIntegral (peek kasePtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slacpy.f>
lacpy ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldb -} ->
   IO (Array (ZeroInt,ZeroInt) Float)
lacpy uplo m a ldb = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   b <- Call.newArray2 n ldb
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lacpy uploPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr
      liftIO $ Call.freezeArray b

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sladiv.f>
ladiv ::
   Float {- ^ a -} ->
   Float {- ^ b -} ->
   Float {- ^ c -} ->
   Float {- ^ d -} ->
   IO (Float, Float)
ladiv a b c d = do
   evalContT $ do
      aPtr <- Call.float a
      bPtr <- Call.float b
      cPtr <- Call.float c
      dPtr <- Call.float d
      pPtr <- Call.alloca
      qPtr <- Call.alloca
      liftIO $ FFI.ladiv aPtr bPtr cPtr dPtr pPtr qPtr
      liftIO $ pure (,)
         <*> peek pPtr
         <*> peek qPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slae2.f>
lae2 ::
   Float {- ^ a -} ->
   Float {- ^ b -} ->
   Float {- ^ c -} ->
   IO (Float, Float)
lae2 a b c = do
   evalContT $ do
      aPtr <- Call.float a
      bPtr <- Call.float b
      cPtr <- Call.float c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      liftIO $ FFI.lae2 aPtr bPtr cPtr rt1Ptr rt2Ptr
      liftIO $ pure (,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaebz.f>
laebz ::
   Int {- ^ ijob -} ->
   Int {- ^ nitmax -} ->
   Int {- ^ nbmin -} ->
   Float {- ^ abstol -} ->
   Float {- ^ reltol -} ->
   Float {- ^ pivmin -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Array ZeroInt Float {- ^ e2 -} ->
   IOArray ZeroInt CInt {- ^ nval -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   IOArray (ZeroInt,ZeroInt) CInt {- ^ nab -} ->
   IO (Int, Int)
laebz ijob nitmax nbmin abstol reltol pivmin d e e2 nval ab c nab = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let e2Dim0 = Call.sizes1 $ Array.shape e2
   let nvalDim0 = Call.sizes1 $ MutArray.shape nval
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let (nabDim0,nabDim1) = Call.sizes2 $ MutArray.shape nab
   let n = dDim0
   let minp = nvalDim0
   let mmax = abDim1
   Call.assert "laebz: n == eDim0" (n == eDim0)
   Call.assert "laebz: n == e2Dim0" (n == e2Dim0)
   Call.assert "laebz: 2 == abDim0" (2 == abDim0)
   Call.assert "laebz: mmax == cDim0" (mmax == cDim0)
   Call.assert "laebz: 2 == nabDim0" (2 == nabDim0)
   Call.assert "laebz: mmax == nabDim1" (mmax == nabDim1)
   work <- Call.newArray1 mmax
   iwork <- Call.newArray1 mmax
   evalContT $ do
      ijobPtr <- Call.cint ijob
      nitmaxPtr <- Call.cint nitmax
      nPtr <- Call.cint n
      mmaxPtr <- Call.cint mmax
      minpPtr <- Call.cint minp
      nbminPtr <- Call.cint nbmin
      abstolPtr <- Call.float abstol
      reltolPtr <- Call.float reltol
      pivminPtr <- Call.float pivmin
      dPtr <- Call.array d
      ePtr <- Call.array e
      e2Ptr <- Call.array e2
      nvalPtr <- Call.ioarray nval
      abPtr <- Call.ioarray ab
      cPtr <- Call.ioarray c
      moutPtr <- Call.alloca
      nabPtr <- Call.ioarray nab
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laebz ijobPtr nitmaxPtr nPtr mmaxPtr minpPtr nbminPtr abstolPtr reltolPtr pivminPtr dPtr ePtr e2Ptr nvalPtr abPtr cPtr moutPtr nabPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek moutPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed0.f>
laed0 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Int {- ^ ldqs -} ->
   Int {- ^ workSize -} ->
   Int {- ^ iworkSize -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
laed0 icompq qsiz d e q ldqs workSize iworkSize = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed0: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "laed0: n == qDim0" (n == qDim0)
   qstore <- Call.newArray2 n ldqs
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 iworkSize
   evalContT $ do
      icompqPtr <- Call.cint icompq
      qsizPtr <- Call.cint qsiz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.array e
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      qstorePtr <- Call.ioarray qstore
      ldqsPtr <- Call.cint ldqs
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed0 icompqPtr qsizPtr nPtr dPtr ePtr qPtr ldqPtr qstorePtr ldqsPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray qstore
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed1.f>
laed1 ::
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray ZeroInt CInt {- ^ indxq -} ->
   Float {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   IO (Int)
laed1 d q indxq rho cutpnt = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let indxqDim0 = Call.sizes1 $ MutArray.shape indxq
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed1: n == qDim0" (n == qDim0)
   Call.assert "laed1: n == indxqDim0" (n == indxqDim0)
   work <- Call.newArray1 (4*n+n^!2)
   iwork <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.float rho
      cutpntPtr <- Call.cint cutpnt
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed1 nPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr workPtr iworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed2.f>
laed2 ::
   Int {- ^ n1 -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray ZeroInt CInt {- ^ indxq -} ->
   Float {- ^ rho -} ->
   Array ZeroInt Float {- ^ z -} ->
   IO (Int, Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt, Int)
laed2 n1 d q indxq rho z = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let indxqDim0 = Call.sizes1 $ MutArray.shape indxq
   let zDim0 = Call.sizes1 $ Array.shape z
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed2: n == qDim0" (n == qDim0)
   Call.assert "laed2: n == indxqDim0" (n == indxqDim0)
   Call.assert "laed2: n == zDim0" (n == zDim0)
   dlamda <- Call.newArray1 n
   w <- Call.newArray1 n
   q2 <- Call.newArray1 (n1^!2+(n-n1)^!2)
   indx <- Call.newArray1 n
   indxc <- Call.newArray1 n
   indxp <- Call.newArray1 n
   coltyp <- Call.newArray1 n
   evalContT $ do
      kPtr <- Call.alloca
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.float rho
      zPtr <- Call.array z
      dlamdaPtr <- Call.ioarray dlamda
      wPtr <- Call.ioarray w
      q2Ptr <- Call.ioarray q2
      indxPtr <- Call.ioarray indx
      indxcPtr <- Call.ioarray indxc
      indxpPtr <- Call.ioarray indxp
      coltypPtr <- Call.ioarray coltyp
      infoPtr <- Call.alloca
      liftIO $ FFI.laed2 kPtr nPtr n1Ptr dPtr qPtr ldqPtr indxqPtr rhoPtr zPtr dlamdaPtr wPtr q2Ptr indxPtr indxcPtr indxpPtr coltypPtr infoPtr
      liftIO $ pure (,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> peek rhoPtr
         <*> Call.freezeArray dlamda
         <*> Call.freezeArray w
         <*> Call.freezeArray q2
         <*> Call.freezeArray indx
         <*> Call.freezeArray indxc
         <*> Call.freezeArray indxp
         <*> Call.freezeArray coltyp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed3.f>
laed3 ::
   Int {- ^ n1 -} ->
   Int {- ^ ldq -} ->
   Float {- ^ rho -} ->
   IOArray ZeroInt Float {- ^ dlamda -} ->
   Array ZeroInt Float {- ^ q2 -} ->
   Array ZeroInt CInt {- ^ indx -} ->
   Array ZeroInt CInt {- ^ ctot -} ->
   IOArray ZeroInt Float {- ^ w -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Int)
laed3 n1 ldq rho dlamda q2 indx ctot w = do
   let dlamdaDim0 = Call.sizes1 $ MutArray.shape dlamda
   let q2Dim0 = Call.sizes1 $ Array.shape q2
   let indxDim0 = Call.sizes1 $ Array.shape indx
   let ctotDim0 = Call.sizes1 $ Array.shape ctot
   let wDim0 = Call.sizes1 $ MutArray.shape w
   let k = dlamdaDim0
   let n = indxDim0
   Call.ignore "laed3: ldq2*n == q2Dim0" q2Dim0
   Call.assert "laed3: 4 == ctotDim0" (4 == ctotDim0)
   Call.assert "laed3: k == wDim0" (k == wDim0)
   d <- Call.newArray1 n
   q <- Call.newArray2 n ldq
   s <- Call.newArray1 (n1+1)
   evalContT $ do
      kPtr <- Call.cint k
      nPtr <- Call.cint n
      n1Ptr <- Call.cint n1
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      rhoPtr <- Call.float rho
      dlamdaPtr <- Call.ioarray dlamda
      q2Ptr <- Call.array q2
      indxPtr <- Call.array indx
      ctotPtr <- Call.array ctot
      wPtr <- Call.ioarray w
      sPtr <- Call.ioarray s
      infoPtr <- Call.alloca
      liftIO $ FFI.laed3 kPtr nPtr n1Ptr dPtr qPtr ldqPtr rhoPtr dlamdaPtr q2Ptr indxPtr ctotPtr wPtr sPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed4.f>
laed4 ::
   Int {- ^ i -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ rho -} ->
   IO (Array ZeroInt Float, Float, Int)
laed4 i d z rho = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let zDim0 = Call.sizes1 $ Array.shape z
   let n = dDim0
   Call.assert "laed4: n == zDim0" (n == zDim0)
   delta <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.float rho
      dlamPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laed4 nPtr iPtr dPtr zPtr deltaPtr rhoPtr dlamPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray delta
         <*> peek dlamPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed5.f>
laed5 ::
   Int {- ^ i -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ rho -} ->
   IO (Array ZeroInt Float, Float)
laed5 i d z rho = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.assert "laed5: 2 == dDim0" (2 == dDim0)
   Call.assert "laed5: 2 == zDim0" (2 == zDim0)
   delta <- Call.newArray1 2
   evalContT $ do
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.float rho
      dlamPtr <- Call.alloca
      liftIO $ FFI.laed5 iPtr dPtr zPtr deltaPtr rhoPtr dlamPtr
      liftIO $ pure (,)
         <*> Call.freezeArray delta
         <*> peek dlamPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed6.f>
laed6 ::
   Int {- ^ kniter -} ->
   Bool {- ^ orgati -} ->
   Float {- ^ rho -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ finit -} ->
   IO (Float, Int)
laed6 kniter orgati rho d z finit = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.assert "laed6: 3 == dDim0" (3 == dDim0)
   Call.assert "laed6: 3 == zDim0" (3 == zDim0)
   evalContT $ do
      kniterPtr <- Call.cint kniter
      orgatiPtr <- Call.bool orgati
      rhoPtr <- Call.float rho
      dPtr <- Call.array d
      zPtr <- Call.array z
      finitPtr <- Call.float finit
      tauPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laed6 kniterPtr orgatiPtr rhoPtr dPtr zPtr finitPtr tauPtr infoPtr
      liftIO $ pure (,)
         <*> peek tauPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed7.f>
laed7 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   Int {- ^ tlvls -} ->
   Int {- ^ curlvl -} ->
   Int {- ^ curpbm -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Float {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   IOArray ZeroInt Float {- ^ qstore -} ->
   IOArray ZeroInt CInt {- ^ qptr -} ->
   Array ZeroInt CInt {- ^ prmptr -} ->
   Array ZeroInt CInt {- ^ perm -} ->
   Array ZeroInt CInt {- ^ givptr -} ->
   Array (ZeroInt,ZeroInt) CInt {- ^ givcol -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ givnum -} ->
   IO (Array ZeroInt CInt, Int)
laed7 icompq qsiz tlvls curlvl curpbm d q rho cutpnt qstore qptr prmptr perm givptr givcol givnum = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let qstoreDim0 = Call.sizes1 $ MutArray.shape qstore
   let qptrDim0 = Call.sizes1 $ MutArray.shape qptr
   let prmptrDim0 = Call.sizes1 $ Array.shape prmptr
   let permDim0 = Call.sizes1 $ Array.shape perm
   let givptrDim0 = Call.sizes1 $ Array.shape givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ Array.shape givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ Array.shape givnum
   let n = dDim0
   let ldq = qDim1
   let nlgn = prmptrDim0
   Call.assert "laed7: n == qDim0" (n == qDim0)
   Call.assert "laed7: n^!2+1 == qstoreDim0" (n^!2+1 == qstoreDim0)
   Call.assert "laed7: n+2 == qptrDim0" (n+2 == qptrDim0)
   Call.assert "laed7: nlgn == permDim0" (nlgn == permDim0)
   Call.assert "laed7: nlgn == givptrDim0" (nlgn == givptrDim0)
   Call.assert "laed7: nlgn == givcolDim0" (nlgn == givcolDim0)
   Call.assert "laed7: 2 == givcolDim1" (2 == givcolDim1)
   Call.assert "laed7: nlgn == givnumDim0" (nlgn == givnumDim0)
   Call.assert "laed7: 2 == givnumDim1" (2 == givnumDim1)
   indxq <- Call.newArray1 n
   work <- Call.newArray1 (3*n+2*qsiz*n)
   iwork <- Call.newArray1 (4*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nPtr <- Call.cint n
      qsizPtr <- Call.cint qsiz
      tlvlsPtr <- Call.cint tlvls
      curlvlPtr <- Call.cint curlvl
      curpbmPtr <- Call.cint curpbm
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.ioarray indxq
      rhoPtr <- Call.float rho
      cutpntPtr <- Call.cint cutpnt
      qstorePtr <- Call.ioarray qstore
      qptrPtr <- Call.ioarray qptr
      prmptrPtr <- Call.array prmptr
      permPtr <- Call.array perm
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      givnumPtr <- Call.array givnum
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laed7 icompqPtr nPtr qsizPtr tlvlsPtr curlvlPtr curpbmPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr qstorePtr qptrPtr prmptrPtr permPtr givptrPtr givcolPtr givnumPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray indxq
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed8.f>
laed8 ::
   Int {- ^ icompq -} ->
   Int {- ^ qsiz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Array ZeroInt CInt {- ^ indxq -} ->
   Float {- ^ rho -} ->
   Int {- ^ cutpnt -} ->
   Array ZeroInt Float {- ^ z -} ->
   Int {- ^ ldq2 -} ->
   IO (Int, Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Array ZeroInt CInt, Int, Array (ZeroInt,ZeroInt) CInt, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Array ZeroInt CInt, Int)
laed8 icompq qsiz d q indxq rho cutpnt z ldq2 = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let indxqDim0 = Call.sizes1 $ Array.shape indxq
   let zDim0 = Call.sizes1 $ Array.shape z
   let n = dDim0
   let ldq = qDim1
   Call.assert "laed8: n == qDim0" (n == qDim0)
   Call.assert "laed8: n == indxqDim0" (n == indxqDim0)
   Call.assert "laed8: n == zDim0" (n == zDim0)
   dlamda <- Call.newArray1 n
   q2 <- Call.newArray2 n ldq2
   w <- Call.newArray1 n
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 n 2
   givnum <- Call.newArray2 n 2
   indxp <- Call.newArray1 n
   indx <- Call.newArray1 n
   evalContT $ do
      icompqPtr <- Call.cint icompq
      kPtr <- Call.alloca
      nPtr <- Call.cint n
      qsizPtr <- Call.cint qsiz
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      indxqPtr <- Call.array indxq
      rhoPtr <- Call.float rho
      cutpntPtr <- Call.cint cutpnt
      zPtr <- Call.array z
      dlamdaPtr <- Call.ioarray dlamda
      q2Ptr <- Call.ioarray q2
      ldq2Ptr <- Call.cint ldq2
      wPtr <- Call.ioarray w
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      givnumPtr <- Call.ioarray givnum
      indxpPtr <- Call.ioarray indxp
      indxPtr <- Call.ioarray indx
      infoPtr <- Call.alloca
      liftIO $ FFI.laed8 icompqPtr kPtr nPtr qsizPtr dPtr qPtr ldqPtr indxqPtr rhoPtr cutpntPtr zPtr dlamdaPtr q2Ptr ldq2Ptr wPtr permPtr givptrPtr givcolPtr givnumPtr indxpPtr indxPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> peek rhoPtr
         <*> Call.freezeArray dlamda
         <*> Call.freezeArray q2
         <*> Call.freezeArray w
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> Call.freezeArray indxp
         <*> Call.freezeArray indx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaed9.f>
laed9 ::
   Int {- ^ kstart -} ->
   Int {- ^ kstop -} ->
   Int {- ^ n -} ->
   Int {- ^ ldq -} ->
   Float {- ^ rho -} ->
   Array ZeroInt Float {- ^ dlamda -} ->
   Array ZeroInt Float {- ^ w -} ->
   Int {- ^ lds -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
laed9 kstart kstop n ldq rho dlamda w lds = do
   let dlamdaDim0 = Call.sizes1 $ Array.shape dlamda
   let wDim0 = Call.sizes1 $ Array.shape w
   let k = dlamdaDim0
   Call.assert "laed9: k == wDim0" (k == wDim0)
   d <- Call.newArray1 n
   q <- Call.newArray2 n ldq
   s <- Call.newArray2 k lds
   evalContT $ do
      kPtr <- Call.cint k
      kstartPtr <- Call.cint kstart
      kstopPtr <- Call.cint kstop
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      rhoPtr <- Call.float rho
      dlamdaPtr <- Call.array dlamda
      wPtr <- Call.array w
      sPtr <- Call.ioarray s
      ldsPtr <- Call.cint lds
      infoPtr <- Call.alloca
      liftIO $ FFI.laed9 kPtr kstartPtr kstopPtr nPtr dPtr qPtr ldqPtr rhoPtr dlamdaPtr wPtr sPtr ldsPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaeda.f>
laeda ::
   Int {- ^ n -} ->
   Int {- ^ tlvls -} ->
   Int {- ^ curlvl -} ->
   Int {- ^ curpbm -} ->
   Array ZeroInt CInt {- ^ prmptr -} ->
   Array ZeroInt CInt {- ^ perm -} ->
   Array ZeroInt CInt {- ^ givptr -} ->
   Array (ZeroInt,ZeroInt) CInt {- ^ givcol -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ givnum -} ->
   Array ZeroInt Float {- ^ q -} ->
   Array ZeroInt CInt {- ^ qptr -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
laeda n tlvls curlvl curpbm prmptr perm givptr givcol givnum q qptr = do
   let prmptrDim0 = Call.sizes1 $ Array.shape prmptr
   let permDim0 = Call.sizes1 $ Array.shape perm
   let givptrDim0 = Call.sizes1 $ Array.shape givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ Array.shape givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ Array.shape givnum
   let qDim0 = Call.sizes1 $ Array.shape q
   let qptrDim0 = Call.sizes1 $ Array.shape qptr
   let nlgn = prmptrDim0
   Call.assert "laeda: nlgn == permDim0" (nlgn == permDim0)
   Call.assert "laeda: nlgn == givptrDim0" (nlgn == givptrDim0)
   Call.assert "laeda: nlgn == givcolDim0" (nlgn == givcolDim0)
   Call.assert "laeda: 2 == givcolDim1" (2 == givcolDim1)
   Call.assert "laeda: nlgn == givnumDim0" (nlgn == givnumDim0)
   Call.assert "laeda: 2 == givnumDim1" (2 == givnumDim1)
   Call.assert "laeda: n^!2 == qDim0" (n^!2 == qDim0)
   Call.assert "laeda: n+2 == qptrDim0" (n+2 == qptrDim0)
   z <- Call.newArray1 n
   ztemp <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      tlvlsPtr <- Call.cint tlvls
      curlvlPtr <- Call.cint curlvl
      curpbmPtr <- Call.cint curpbm
      prmptrPtr <- Call.array prmptr
      permPtr <- Call.array perm
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      givnumPtr <- Call.array givnum
      qPtr <- Call.array q
      qptrPtr <- Call.array qptr
      zPtr <- Call.ioarray z
      ztempPtr <- Call.ioarray ztemp
      infoPtr <- Call.alloca
      liftIO $ FFI.laeda nPtr tlvlsPtr curlvlPtr curpbmPtr prmptrPtr permPtr givptrPtr givcolPtr givnumPtr qPtr qptrPtr zPtr ztempPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray ztemp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaein.f>
laein ::
   Bool {- ^ rightv -} ->
   Bool {- ^ noinit -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Float {- ^ wr -} ->
   Float {- ^ wi -} ->
   IOArray ZeroInt Float {- ^ vr -} ->
   IOArray ZeroInt Float {- ^ vi -} ->
   Int {- ^ ldb -} ->
   Float {- ^ eps3 -} ->
   Float {- ^ smlnum -} ->
   Float {- ^ bignum -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
laein rightv noinit h wr wi vr vi ldb eps3 smlnum bignum = do
   let (hDim0,hDim1) = Call.sizes2 $ Array.shape h
   let vrDim0 = Call.sizes1 $ MutArray.shape vr
   let viDim0 = Call.sizes1 $ MutArray.shape vi
   let n = hDim0
   let ldh = hDim1
   Call.assert "laein: n == vrDim0" (n == vrDim0)
   Call.assert "laein: n == viDim0" (n == viDim0)
   b <- Call.newArray2 n ldb
   work <- Call.newArray1 n
   evalContT $ do
      rightvPtr <- Call.bool rightv
      noinitPtr <- Call.bool noinit
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.float wr
      wiPtr <- Call.float wi
      vrPtr <- Call.ioarray vr
      viPtr <- Call.ioarray vi
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      eps3Ptr <- Call.float eps3
      smlnumPtr <- Call.float smlnum
      bignumPtr <- Call.float bignum
      infoPtr <- Call.alloca
      liftIO $ FFI.laein rightvPtr noinitPtr nPtr hPtr ldhPtr wrPtr wiPtr vrPtr viPtr bPtr ldbPtr workPtr eps3Ptr smlnumPtr bignumPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray b
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaev2.f>
laev2 ::
   Float {- ^ a -} ->
   Float {- ^ b -} ->
   Float {- ^ c -} ->
   IO (Float, Float, Float, Float)
laev2 a b c = do
   evalContT $ do
      aPtr <- Call.float a
      bPtr <- Call.float b
      cPtr <- Call.float c
      rt1Ptr <- Call.alloca
      rt2Ptr <- Call.alloca
      cs1Ptr <- Call.alloca
      sn1Ptr <- Call.alloca
      liftIO $ FFI.laev2 aPtr bPtr cPtr rt1Ptr rt2Ptr cs1Ptr sn1Ptr
      liftIO $ pure (,,,)
         <*> peek rt1Ptr
         <*> peek rt2Ptr
         <*> peek cs1Ptr
         <*> peek sn1Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaexc.f>
laexc ::
   Bool {- ^ wantq -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Int {- ^ j1 -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   IO (Int)
laexc wantq t q j1 n1 n2 = do
   let (tDim0,tDim1) = Call.sizes2 $ MutArray.shape t
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = tDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "laexc: n == qDim0" (n == qDim0)
   work <- Call.newArray1 n
   evalContT $ do
      wantqPtr <- Call.bool wantq
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      j1Ptr <- Call.cint j1
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.laexc wantqPtr nPtr tPtr ldtPtr qPtr ldqPtr j1Ptr n1Ptr n2Ptr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slag2.f>
lag2 ::
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ safmin -} ->
   IO (Float, Float, Float, Float, Float)
lag2 a b safmin = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let lda = aDim1
   let ldb = bDim1
   Call.assert "lag2: 2 == aDim0" (2 == aDim0)
   Call.assert "lag2: 2 == bDim0" (2 == bDim0)
   evalContT $ do
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      safminPtr <- Call.float safmin
      scale1Ptr <- Call.alloca
      scale2Ptr <- Call.alloca
      wr1Ptr <- Call.alloca
      wr2Ptr <- Call.alloca
      wiPtr <- Call.alloca
      liftIO $ FFI.lag2 aPtr ldaPtr bPtr ldbPtr safminPtr scale1Ptr scale2Ptr wr1Ptr wr2Ptr wiPtr
      liftIO $ pure (,,,,)
         <*> peek scale1Ptr
         <*> peek scale2Ptr
         <*> peek wr1Ptr
         <*> peek wr2Ptr
         <*> peek wiPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slag2d.f>
lag2d ::
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ sa -} ->
   Int {- ^ lda -} ->
   IO (Array (ZeroInt,ZeroInt) Double, Int)
lag2d m sa lda = do
   let (saDim0,saDim1) = Call.sizes2 $ Array.shape sa
   let n = saDim0
   let ldsa = saDim1
   a <- Call.newArray2 n lda
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      saPtr <- Call.array sa
      ldsaPtr <- Call.cint ldsa
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lag2d mPtr nPtr saPtr ldsaPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slags2.f>
lags2 ::
   Bool {- ^ upper -} ->
   Float {- ^ a1 -} ->
   Float {- ^ a2 -} ->
   Float {- ^ a3 -} ->
   Float {- ^ b1 -} ->
   Float {- ^ b2 -} ->
   Float {- ^ b3 -} ->
   IO (Float, Float, Float, Float, Float, Float)
lags2 upper a1 a2 a3 b1 b2 b3 = do
   evalContT $ do
      upperPtr <- Call.bool upper
      a1Ptr <- Call.float a1
      a2Ptr <- Call.float a2
      a3Ptr <- Call.float a3
      b1Ptr <- Call.float b1
      b2Ptr <- Call.float b2
      b3Ptr <- Call.float b3
      csuPtr <- Call.alloca
      snuPtr <- Call.alloca
      csvPtr <- Call.alloca
      snvPtr <- Call.alloca
      csqPtr <- Call.alloca
      snqPtr <- Call.alloca
      liftIO $ FFI.lags2 upperPtr a1Ptr a2Ptr a3Ptr b1Ptr b2Ptr b3Ptr csuPtr snuPtr csvPtr snvPtr csqPtr snqPtr
      liftIO $ pure (,,,,,)
         <*> peek csuPtr
         <*> peek snuPtr
         <*> peek csvPtr
         <*> peek snvPtr
         <*> peek csqPtr
         <*> peek snqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagtf.f>
lagtf ::
   IOArray ZeroInt Float {- ^ a -} ->
   Float {- ^ lambda -} ->
   IOArray ZeroInt Float {- ^ b -} ->
   IOArray ZeroInt Float {- ^ c -} ->
   Float {- ^ tol -} ->
   IO (Array ZeroInt Float, Array ZeroInt CInt, Int)
lagtf a lambda b c tol = do
   let aDim0 = Call.sizes1 $ MutArray.shape a
   let bDim0 = Call.sizes1 $ MutArray.shape b
   let cDim0 = Call.sizes1 $ MutArray.shape c
   let n = aDim0
   Call.assert "lagtf: n-1 == bDim0" (n-1 == bDim0)
   Call.assert "lagtf: n-1 == cDim0" (n-1 == cDim0)
   d <- Call.newArray1 (n-2)
   in_ <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      lambdaPtr <- Call.float lambda
      bPtr <- Call.ioarray b
      cPtr <- Call.ioarray c
      tolPtr <- Call.float tol
      dPtr <- Call.ioarray d
      in_Ptr <- Call.ioarray in_
      infoPtr <- Call.alloca
      liftIO $ FFI.lagtf nPtr aPtr lambdaPtr bPtr cPtr tolPtr dPtr in_Ptr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray in_
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagtm.f>
lagtm ::
   Char {- ^ trans -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ x -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
lagtm trans alpha dl d du x beta b = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let (xDim0,xDim1) = Call.sizes2 $ Array.shape x
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = xDim0
   let ldx = xDim1
   let ldb = bDim1
   Call.assert "lagtm: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "lagtm: n-1 == duDim0" (n-1 == duDim0)
   Call.assert "lagtm: nrhs == bDim0" (nrhs == bDim0)
   evalContT $ do
      transPtr <- Call.char trans
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      alphaPtr <- Call.float alpha
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      betaPtr <- Call.float beta
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.lagtm transPtr nPtr nrhsPtr alphaPtr dlPtr dPtr duPtr xPtr ldxPtr betaPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagts.f>
lagts ::
   Int {- ^ job -} ->
   Array ZeroInt Float {- ^ a -} ->
   Array ZeroInt Float {- ^ b -} ->
   Array ZeroInt Float {- ^ c -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt CInt {- ^ in_ -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Float {- ^ tol -} ->
   IO (Float, Int)
lagts job a b c d in_ y tol = do
   let aDim0 = Call.sizes1 $ Array.shape a
   let bDim0 = Call.sizes1 $ Array.shape b
   let cDim0 = Call.sizes1 $ Array.shape c
   let dDim0 = Call.sizes1 $ Array.shape d
   let in_Dim0 = Call.sizes1 $ Array.shape in_
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let n = aDim0
   Call.assert "lagts: n-1 == bDim0" (n-1 == bDim0)
   Call.assert "lagts: n-1 == cDim0" (n-1 == cDim0)
   Call.assert "lagts: n-2 == dDim0" (n-2 == dDim0)
   Call.assert "lagts: n == in_Dim0" (n == in_Dim0)
   Call.assert "lagts: n == yDim0" (n == yDim0)
   evalContT $ do
      jobPtr <- Call.cint job
      nPtr <- Call.cint n
      aPtr <- Call.array a
      bPtr <- Call.array b
      cPtr <- Call.array c
      dPtr <- Call.array d
      in_Ptr <- Call.array in_
      yPtr <- Call.ioarray y
      tolPtr <- Call.float tol
      infoPtr <- Call.alloca
      liftIO $ FFI.lagts jobPtr nPtr aPtr bPtr cPtr dPtr in_Ptr yPtr tolPtr infoPtr
      liftIO $ pure (,)
         <*> peek tolPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagv2.f>
lagv2 ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Float, Float, Float, Float)
lagv2 a b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let lda = aDim1
   let ldb = bDim1
   Call.assert "lagv2: 2 == aDim0" (2 == aDim0)
   Call.assert "lagv2: 2 == bDim0" (2 == bDim0)
   alphar <- Call.newArray1 2
   alphai <- Call.newArray1 2
   beta <- Call.newArray1 2
   evalContT $ do
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      cslPtr <- Call.alloca
      snlPtr <- Call.alloca
      csrPtr <- Call.alloca
      snrPtr <- Call.alloca
      liftIO $ FFI.lagv2 aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr cslPtr snlPtr csrPtr snrPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> peek cslPtr
         <*> peek snlPtr
         <*> peek csrPtr
         <*> peek snrPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slahqr.f>
lahqr ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
lahqr wantt wantz ilo ihi h iloz ihiz z = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "lahqr: n == zDim0" (n == zDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      infoPtr <- Call.alloca
      liftIO $ FFI.lahqr wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slahr2.f>
lahr2 ::
   Int {- ^ n -} ->
   Int {- ^ k -} ->
   Int {- ^ nb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldt -} ->
   Int {- ^ ldy -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float)
lahr2 n k nb a ldt ldy = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let lda = aDim1
   Call.assert "lahr2: n-k+1 == aDim0" (n-k+1 == aDim0)
   tau <- Call.newArray1 nb
   t <- Call.newArray2 nb ldt
   y <- Call.newArray2 nb ldy
   evalContT $ do
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      yPtr <- Call.ioarray y
      ldyPtr <- Call.cint ldy
      liftIO $ FFI.lahr2 nPtr kPtr nbPtr aPtr ldaPtr tauPtr tPtr ldtPtr yPtr ldyPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray tau
         <*> Call.freezeArray t
         <*> Call.freezeArray y

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaic1.f>
laic1 ::
   Int {- ^ job -} ->
   Array ZeroInt Float {- ^ x -} ->
   Float {- ^ sest -} ->
   Array ZeroInt Float {- ^ w -} ->
   Float {- ^ gamma -} ->
   IO (Float, Float, Float)
laic1 job x sest w gamma = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let wDim0 = Call.sizes1 $ Array.shape w
   let j = xDim0
   Call.assert "laic1: j == wDim0" (j == wDim0)
   evalContT $ do
      jobPtr <- Call.cint job
      jPtr <- Call.cint j
      xPtr <- Call.array x
      sestPtr <- Call.float sest
      wPtr <- Call.array w
      gammaPtr <- Call.float gamma
      sestprPtr <- Call.alloca
      sPtr <- Call.alloca
      cPtr <- Call.alloca
      liftIO $ FFI.laic1 jobPtr jPtr xPtr sestPtr wPtr gammaPtr sestprPtr sPtr cPtr
      liftIO $ pure (,,)
         <*> peek sestprPtr
         <*> peek sPtr
         <*> peek cPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaisnan.f>
laisnan ::
   Float {- ^ sin1 -} ->
   Float {- ^ sin2 -} ->
   IO Bool
laisnan sin1 sin2 = do
   evalContT $ do
      sin1Ptr <- Call.float sin1
      sin2Ptr <- Call.float sin2
      liftIO $ FFI.laisnan sin1Ptr sin2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaln2.f>
laln2 ::
   Bool {- ^ ltrans -} ->
   Float {- ^ smin -} ->
   Float {- ^ ca -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ d1 -} ->
   Float {- ^ d2 -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ wr -} ->
   Float {- ^ wi -} ->
   Int {- ^ ldx -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Float, Float, Int)
laln2 ltrans smin ca a d1 d2 b wr wi ldx = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let na = aDim0
   let lda = aDim1
   let nw = bDim0
   let ldb = bDim1
   x <- Call.newArray2 nw ldx
   evalContT $ do
      ltransPtr <- Call.bool ltrans
      naPtr <- Call.cint na
      nwPtr <- Call.cint nw
      sminPtr <- Call.float smin
      caPtr <- Call.float ca
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      d1Ptr <- Call.float d1
      d2Ptr <- Call.float d2
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      wrPtr <- Call.float wr
      wiPtr <- Call.float wi
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      scalePtr <- Call.alloca
      xnormPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.laln2 ltransPtr naPtr nwPtr sminPtr caPtr aPtr ldaPtr d1Ptr d2Ptr bPtr ldbPtr wrPtr wiPtr xPtr ldxPtr scalePtr xnormPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray x
         <*> peek scalePtr
         <*> peek xnormPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slals0.f>
lals0 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldbx -} ->
   Array ZeroInt CInt {- ^ perm -} ->
   Int {- ^ givptr -} ->
   Array (ZeroInt,ZeroInt) CInt {- ^ givcol -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ givnum -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ poles -} ->
   Array ZeroInt Float {- ^ difl -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ difr -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ c -} ->
   Float {- ^ s -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
lals0 icompq nl nr sqre b ldbx perm givptr givcol givnum poles difl difr z c s = do
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let permDim0 = Call.sizes1 $ Array.shape perm
   let (givcolDim0,givcolDim1) = Call.sizes2 $ Array.shape givcol
   let (givnumDim0,givnumDim1) = Call.sizes2 $ Array.shape givnum
   let (polesDim0,polesDim1) = Call.sizes2 $ Array.shape poles
   let diflDim0 = Call.sizes1 $ Array.shape difl
   let (difrDim0,difrDim1) = Call.sizes2 $ Array.shape difr
   let zDim0 = Call.sizes1 $ Array.shape z
   let nrhs = bDim0
   let ldb = bDim1
   let _n = permDim0
   let ldgcol = givcolDim1
   let ldgnum = givnumDim1
   let k = diflDim0
   Call.assert "lals0: 2 == givcolDim0" (2 == givcolDim0)
   Call.assert "lals0: 2 == givnumDim0" (2 == givnumDim0)
   Call.assert "lals0: 2 == polesDim0" (2 == polesDim0)
   Call.assert "lals0: ldgnum == polesDim1" (ldgnum == polesDim1)
   Call.assert "lals0: 2 == difrDim0" (2 == difrDim0)
   Call.assert "lals0: ldgnum == difrDim1" (ldgnum == difrDim1)
   Call.assert "lals0: k == zDim0" (k == zDim0)
   bx <- Call.newArray2 nrhs ldbx
   work <- Call.newArray1 k
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      permPtr <- Call.array perm
      givptrPtr <- Call.cint givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.array givnum
      ldgnumPtr <- Call.cint ldgnum
      polesPtr <- Call.array poles
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      kPtr <- Call.cint k
      cPtr <- Call.float c
      sPtr <- Call.float s
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lals0 icompqPtr nlPtr nrPtr sqrePtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr polesPtr diflPtr difrPtr zPtr kPtr cPtr sPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slalsa.f>
lalsa ::
   Int {- ^ icompq -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldbx -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ u -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ vt -} ->
   Array ZeroInt CInt {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ difl -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ difr -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ poles -} ->
   Array ZeroInt CInt {- ^ givptr -} ->
   Array (ZeroInt,ZeroInt) CInt {- ^ givcol -} ->
   Array (ZeroInt,ZeroInt) CInt {- ^ perm -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ givnum -} ->
   Array ZeroInt Float {- ^ c -} ->
   Array ZeroInt Float {- ^ s -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
lalsa icompq b ldbx u vt k difl difr z poles givptr givcol perm givnum c s = do
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (uDim0,uDim1) = Call.sizes2 $ Array.shape u
   let (vtDim0,vtDim1) = Call.sizes2 $ Array.shape vt
   let kDim0 = Call.sizes1 $ Array.shape k
   let (diflDim0,diflDim1) = Call.sizes2 $ Array.shape difl
   let (difrDim0,difrDim1) = Call.sizes2 $ Array.shape difr
   let (zDim0,zDim1) = Call.sizes2 $ Array.shape z
   let (polesDim0,polesDim1) = Call.sizes2 $ Array.shape poles
   let givptrDim0 = Call.sizes1 $ Array.shape givptr
   let (givcolDim0,givcolDim1) = Call.sizes2 $ Array.shape givcol
   let (permDim0,permDim1) = Call.sizes2 $ Array.shape perm
   let (givnumDim0,givnumDim1) = Call.sizes2 $ Array.shape givnum
   let cDim0 = Call.sizes1 $ Array.shape c
   let sDim0 = Call.sizes1 $ Array.shape s
   let nrhs = bDim0
   let ldb = bDim1
   let smlsiz = uDim0
   let ldu = uDim1
   let n = kDim0
   let nlvl = diflDim0
   let ldgcol = givcolDim1
   Call.assert "lalsa: smlsiz+1 == vtDim0" (smlsiz+1 == vtDim0)
   Call.assert "lalsa: ldu == vtDim1" (ldu == vtDim1)
   Call.assert "lalsa: ldu == diflDim1" (ldu == diflDim1)
   Call.assert "lalsa: 2*nlvl == difrDim0" (2*nlvl == difrDim0)
   Call.assert "lalsa: ldu == difrDim1" (ldu == difrDim1)
   Call.assert "lalsa: nlvl == zDim0" (nlvl == zDim0)
   Call.assert "lalsa: ldu == zDim1" (ldu == zDim1)
   Call.assert "lalsa: 2*nlvl == polesDim0" (2*nlvl == polesDim0)
   Call.assert "lalsa: ldu == polesDim1" (ldu == polesDim1)
   Call.assert "lalsa: n == givptrDim0" (n == givptrDim0)
   Call.assert "lalsa: 2*nlvl == givcolDim0" (2*nlvl == givcolDim0)
   Call.assert "lalsa: nlvl == permDim0" (nlvl == permDim0)
   Call.assert "lalsa: ldgcol == permDim1" (ldgcol == permDim1)
   Call.assert "lalsa: 2*nlvl == givnumDim0" (2*nlvl == givnumDim0)
   Call.assert "lalsa: ldu == givnumDim1" (ldu == givnumDim1)
   Call.assert "lalsa: n == cDim0" (n == cDim0)
   Call.assert "lalsa: n == sDim0" (n == sDim0)
   bx <- Call.newArray2 nrhs ldbx
   work <- Call.newArray1 n
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      bxPtr <- Call.ioarray bx
      ldbxPtr <- Call.cint ldbx
      uPtr <- Call.array u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.array vt
      kPtr <- Call.array k
      diflPtr <- Call.array difl
      difrPtr <- Call.array difr
      zPtr <- Call.array z
      polesPtr <- Call.array poles
      givptrPtr <- Call.array givptr
      givcolPtr <- Call.array givcol
      ldgcolPtr <- Call.cint ldgcol
      permPtr <- Call.array perm
      givnumPtr <- Call.array givnum
      cPtr <- Call.array c
      sPtr <- Call.array s
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsa icompqPtr smlsizPtr nPtr nrhsPtr bPtr ldbPtr bxPtr ldbxPtr uPtr lduPtr vtPtr kPtr diflPtr difrPtr zPtr polesPtr givptrPtr givcolPtr ldgcolPtr permPtr givnumPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray bx
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slalsd.f>
lalsd ::
   Char {- ^ uplo -} ->
   Int {- ^ smlsiz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ rcond -} ->
   Int {- ^ workSize -} ->
   Int {- ^ iworkSize -} ->
   IO (Int, Int)
lalsd uplo smlsiz d e b rcond workSize iworkSize = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "lalsd: n-1 == eDim0" (n-1 == eDim0)
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 iworkSize
   evalContT $ do
      uploPtr <- Call.char uplo
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      rcondPtr <- Call.float rcond
      rankPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lalsd uploPtr smlsizPtr nPtr nrhsPtr dPtr ePtr bPtr ldbPtr rcondPtr rankPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slamrg.f>
lamrg ::
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   Array ZeroInt Float {- ^ a -} ->
   Int {- ^ strd1 -} ->
   Int {- ^ strd2 -} ->
   IO (Array ZeroInt CInt)
lamrg n1 n2 a strd1 strd2 = do
   let aDim0 = Call.sizes1 $ Array.shape a
   Call.assert "lamrg: n1+n2 == aDim0" (n1+n2 == aDim0)
   index <- Call.newArray1 (n1+n2)
   evalContT $ do
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      aPtr <- Call.array a
      strd1Ptr <- Call.cint strd1
      strd2Ptr <- Call.cint strd2
      indexPtr <- Call.ioarray index
      liftIO $ FFI.lamrg n1Ptr n2Ptr aPtr strd1Ptr strd2Ptr indexPtr
      liftIO $ Call.freezeArray index

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaneg.f>
laneg ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ lld -} ->
   Float {- ^ sigma -} ->
   Float {- ^ pivmin -} ->
   Int {- ^ r -} ->
   IO CInt
laneg d lld sigma pivmin r = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let lldDim0 = Call.sizes1 $ Array.shape lld
   let n = dDim0
   Call.assert "laneg: n-1 == lldDim0" (n-1 == lldDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lldPtr <- Call.array lld
      sigmaPtr <- Call.float sigma
      pivminPtr <- Call.float pivmin
      rPtr <- Call.cint r
      liftIO $ FFI.laneg nPtr dPtr lldPtr sigmaPtr pivminPtr rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slangb.f>
langb ::
   Char {- ^ norm -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
langb norm kl ku ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.langb normPtr nPtr klPtr kuPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slange.f>
lange ::
   Char {- ^ norm -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lange norm m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lange normPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slangt.f>
langt ::
   Char {- ^ norm -} ->
   Array ZeroInt Float {- ^ dl -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ du -} ->
   IO Float
langt norm dl d du = do
   let dlDim0 = Call.sizes1 $ Array.shape dl
   let dDim0 = Call.sizes1 $ Array.shape d
   let duDim0 = Call.sizes1 $ Array.shape du
   let n = dDim0
   Call.assert "langt: n-1 == dlDim0" (n-1 == dlDim0)
   Call.assert "langt: n-1 == duDim0" (n-1 == duDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dlPtr <- Call.array dl
      dPtr <- Call.array d
      duPtr <- Call.array du
      liftIO $ FFI.langt normPtr nPtr dlPtr dPtr duPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slanhs.f>
lanhs ::
   Char {- ^ norm -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lanhs norm a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lanhs normPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slansb.f>
lansb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
lansb norm uplo k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansb normPtr uploPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slansf.f>
lansf ::
   Char {- ^ norm -} ->
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lansf norm transr uplo n a lwork = do
   let aDim0 = Call.sizes1 $ Array.shape a
   Call.assert "lansf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansf normPtr transrPtr uploPtr nPtr aPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slansp.f>
lansp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Float
lansp norm uplo n ap lwork = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "lansp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansp normPtr uploPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slanst.f>
lanst ::
   Char {- ^ norm -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IO Float
lanst norm d e = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let n = dDim0
   Call.assert "lanst: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      normPtr <- Call.char norm
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      liftIO $ FFI.lanst normPtr nPtr dPtr ePtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slansy.f>
lansy ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lansy norm uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lansy normPtr uploPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slantb.f>
lantb ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Int {- ^ lwork -} ->
   IO Float
lantb norm uplo diag k ab lwork = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantb normPtr uploPtr diagPtr nPtr kPtr abPtr ldabPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slantp.f>
lantp ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Int {- ^ lwork -} ->
   IO Float
lantp norm uplo diag n ap lwork = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "lantp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantp normPtr uploPtr diagPtr nPtr apPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slantr.f>
lantr ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO Float
lantr norm uplo diag m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      workPtr <- Call.ioarray work
      liftIO $ FFI.lantr normPtr uploPtr diagPtr mPtr nPtr aPtr ldaPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slanv2.f>
lanv2 ::
   Float {- ^ a -} ->
   Float {- ^ b -} ->
   Float {- ^ c -} ->
   Float {- ^ d -} ->
   IO (Float, Float, Float, Float, Float, Float, Float, Float, Float, Float)
lanv2 a b c d = do
   evalContT $ do
      aPtr <- Call.float a
      bPtr <- Call.float b
      cPtr <- Call.float c
      dPtr <- Call.float d
      rt1rPtr <- Call.alloca
      rt1iPtr <- Call.alloca
      rt2rPtr <- Call.alloca
      rt2iPtr <- Call.alloca
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      liftIO $ FFI.lanv2 aPtr bPtr cPtr dPtr rt1rPtr rt1iPtr rt2rPtr rt2iPtr csPtr snPtr
      liftIO $ pure (,,,,,,,,,)
         <*> peek aPtr
         <*> peek bPtr
         <*> peek cPtr
         <*> peek dPtr
         <*> peek rt1rPtr
         <*> peek rt1iPtr
         <*> peek rt2rPtr
         <*> peek rt2iPtr
         <*> peek csPtr
         <*> peek snPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapll.f>
lapll ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   IO (Float)
lapll n x incx y incy = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let _xSize = xDim0
   let _ySize = yDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      ssminPtr <- Call.alloca
      liftIO $ FFI.lapll nPtr xPtr incxPtr yPtr incyPtr ssminPtr
      liftIO $ peek ssminPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapmr.f>
lapmr ::
   Bool {- ^ forwrd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IOArray ZeroInt CInt {- ^ k -} ->
   IO ()
lapmr forwrd x k = do
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let kDim0 = Call.sizes1 $ MutArray.shape k
   let n = xDim0
   let ldx = xDim1
   let m = kDim0
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmr forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapmt.f>
lapmt ::
   Bool {- ^ forwrd -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IOArray ZeroInt CInt {- ^ k -} ->
   IO ()
lapmt forwrd m x k = do
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let kDim0 = Call.sizes1 $ MutArray.shape k
   let n = xDim0
   let ldx = xDim1
   Call.assert "lapmt: n == kDim0" (n == kDim0)
   evalContT $ do
      forwrdPtr <- Call.bool forwrd
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      kPtr <- Call.ioarray k
      liftIO $ FFI.lapmt forwrdPtr mPtr nPtr xPtr ldxPtr kPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapy2.f>
lapy2 ::
   Float {- ^ x -} ->
   Float {- ^ y -} ->
   IO Float
lapy2 x y = do
   evalContT $ do
      xPtr <- Call.float x
      yPtr <- Call.float y
      liftIO $ FFI.lapy2 xPtr yPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapy3.f>
lapy3 ::
   Float {- ^ x -} ->
   Float {- ^ y -} ->
   Float {- ^ z -} ->
   IO Float
lapy3 x y z = do
   evalContT $ do
      xPtr <- Call.float x
      yPtr <- Call.float y
      zPtr <- Call.float z
      liftIO $ FFI.lapy3 xPtr yPtr zPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqgb.f>
laqgb ::
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array ZeroInt Float {- ^ r -} ->
   Array ZeroInt Float {- ^ c -} ->
   Float {- ^ rowcnd -} ->
   Float {- ^ colcnd -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqgb kl ku ab r c rowcnd colcnd amax = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let rDim0 = Call.sizes1 $ Array.shape r
   let cDim0 = Call.sizes1 $ Array.shape c
   let n = abDim0
   let ldab = abDim1
   let m = rDim0
   Call.assert "laqgb: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.float rowcnd
      colcndPtr <- Call.float colcnd
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqgb mPtr nPtr klPtr kuPtr abPtr ldabPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqge.f>
laqge ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ r -} ->
   Array ZeroInt Float {- ^ c -} ->
   Float {- ^ rowcnd -} ->
   Float {- ^ colcnd -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqge a r c rowcnd colcnd amax = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let rDim0 = Call.sizes1 $ Array.shape r
   let cDim0 = Call.sizes1 $ Array.shape c
   let n = aDim0
   let lda = aDim1
   let m = rDim0
   Call.assert "laqge: n == cDim0" (n == cDim0)
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      rPtr <- Call.array r
      cPtr <- Call.array c
      rowcndPtr <- Call.float rowcnd
      colcndPtr <- Call.float colcnd
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqge mPtr nPtr aPtr ldaPtr rPtr cPtr rowcndPtr colcndPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqp2.f>
laqp2 ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt CInt {- ^ jpvt -} ->
   IOArray ZeroInt Float {- ^ vn1 -} ->
   IOArray ZeroInt Float {- ^ vn2 -} ->
   IO (Array ZeroInt Float)
laqp2 m offset a jpvt vn1 vn2 = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let jpvtDim0 = Call.sizes1 $ MutArray.shape jpvt
   let vn1Dim0 = Call.sizes1 $ MutArray.shape vn1
   let vn2Dim0 = Call.sizes1 $ MutArray.shape vn2
   let n = aDim0
   let lda = aDim1
   Call.assert "laqp2: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqp2: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqp2: n == vn2Dim0" (n == vn2Dim0)
   tau <- Call.newArray1 (minimum[m,n])
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      workPtr <- Call.ioarray work
      liftIO $ FFI.laqp2 mPtr nPtr offsetPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqps.f>
laqps ::
   Int {- ^ m -} ->
   Int {- ^ offset -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt CInt {- ^ jpvt -} ->
   Int {- ^ kb -} ->
   IOArray ZeroInt Float {- ^ vn1 -} ->
   IOArray ZeroInt Float {- ^ vn2 -} ->
   IOArray ZeroInt Float {- ^ auxv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ f -} ->
   IO (Int, Array ZeroInt Float)
laqps m offset a jpvt kb vn1 vn2 auxv f = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let jpvtDim0 = Call.sizes1 $ MutArray.shape jpvt
   let vn1Dim0 = Call.sizes1 $ MutArray.shape vn1
   let vn2Dim0 = Call.sizes1 $ MutArray.shape vn2
   let auxvDim0 = Call.sizes1 $ MutArray.shape auxv
   let (fDim0,fDim1) = Call.sizes2 $ MutArray.shape f
   let n = aDim0
   let lda = aDim1
   let nb = auxvDim0
   let ldf = fDim1
   Call.assert "laqps: n == jpvtDim0" (n == jpvtDim0)
   Call.assert "laqps: n == vn1Dim0" (n == vn1Dim0)
   Call.assert "laqps: n == vn2Dim0" (n == vn2Dim0)
   Call.assert "laqps: nb == fDim0" (nb == fDim0)
   tau <- Call.newArray1 kb
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      offsetPtr <- Call.cint offset
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      jpvtPtr <- Call.ioarray jpvt
      tauPtr <- Call.ioarray tau
      vn1Ptr <- Call.ioarray vn1
      vn2Ptr <- Call.ioarray vn2
      auxvPtr <- Call.ioarray auxv
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      liftIO $ FFI.laqps mPtr nPtr offsetPtr nbPtr kbPtr aPtr ldaPtr jpvtPtr tauPtr vn1Ptr vn2Ptr auxvPtr fPtr ldfPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr0.f>
laqr0 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
laqr0 wantt wantz ilo h iloz ihiz z workSize lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   wr <- Call.newArray1 ihi
   wi <- Call.newArray1 ihi
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr0 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr1.f>
laqr1 ::
   Array (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Float {- ^ sr1 -} ->
   Float {- ^ si1 -} ->
   Float {- ^ sr2 -} ->
   Float {- ^ si2 -} ->
   IO (Array ZeroInt Float)
laqr1 h sr1 si1 sr2 si2 = do
   let (hDim0,hDim1) = Call.sizes2 $ Array.shape h
   let n = hDim0
   let ldh = hDim1
   v <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      hPtr <- Call.array h
      ldhPtr <- Call.cint ldh
      sr1Ptr <- Call.float sr1
      si1Ptr <- Call.float si1
      sr2Ptr <- Call.float sr2
      si2Ptr <- Call.float si2
      vPtr <- Call.ioarray v
      liftIO $ FFI.laqr1 nPtr hPtr ldhPtr sr1Ptr si1Ptr sr2Ptr si2Ptr vPtr
      liftIO $ Call.freezeArray v

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr2.f>
laqr2 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float)
laqr2 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr2: n == zDim0" (n == zDim0)
   sr <- Call.newArray1 kbot
   si <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr2 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr srPtr siPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sr
         <*> Call.freezeArray si
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr3.f>
laqr3 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   Int {- ^ nw -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldt -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float)
laqr3 wantt wantz ktop kbot nw h iloz ihiz z ldv nh ldt nv ldwv lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ldz = zDim1
   Call.assert "laqr3: n == zDim0" (n == zDim0)
   sr <- Call.newArray1 kbot
   si <- Call.newArray1 kbot
   v <- Call.newArray2 nw ldv
   t <- Call.newArray2 nw ldt
   wv <- Call.newArray2 nw ldwv
   work <- Call.newArray1 lwork
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nwPtr <- Call.cint nw
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nsPtr <- Call.alloca
      ndPtr <- Call.alloca
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      nhPtr <- Call.cint nh
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      liftIO $ FFI.laqr3 wanttPtr wantzPtr nPtr ktopPtr kbotPtr nwPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr nsPtr ndPtr srPtr siPtr vPtr ldvPtr nhPtr tPtr ldtPtr nvPtr wvPtr ldwvPtr workPtr lworkPtr
      liftIO $ pure (,,,,,,)
         <*> fmap fromIntegral (peek nsPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray sr
         <*> Call.freezeArray si
         <*> Call.freezeArray v
         <*> Call.freezeArray t
         <*> Call.freezeArray wv

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr4.f>
laqr4 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ ilo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   Int {- ^ ihiz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
laqr4 wantt wantz ilo h iloz ihiz z workSize lwork = do
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = hDim0
   let ldh = hDim1
   let ihi = zDim0
   let ldz = zDim1
   wr <- Call.newArray1 ihi
   wi <- Call.newArray1 ihi
   work <- Call.newArray1 workSize
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.laqr4 wanttPtr wantzPtr nPtr iloPtr ihiPtr hPtr ldhPtr wrPtr wiPtr ilozPtr ihizPtr zPtr ldzPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqr5.f>
laqr5 ::
   Bool {- ^ wantt -} ->
   Bool {- ^ wantz -} ->
   Int {- ^ kacc22 -} ->
   Int {- ^ ktop -} ->
   Int {- ^ kbot -} ->
   IOArray ZeroInt Float {- ^ sr -} ->
   IOArray ZeroInt Float {- ^ si -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ h -} ->
   Int {- ^ iloz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ ldv -} ->
   Int {- ^ ldu -} ->
   Int {- ^ nv -} ->
   Int {- ^ ldwv -} ->
   Int {- ^ nh -} ->
   Int {- ^ ldwh -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float)
laqr5 wantt wantz kacc22 ktop kbot sr si h iloz z ldv ldu nv ldwv nh ldwh = do
   let srDim0 = Call.sizes1 $ MutArray.shape sr
   let siDim0 = Call.sizes1 $ MutArray.shape si
   let (hDim0,hDim1) = Call.sizes2 $ MutArray.shape h
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let nshfts = srDim0
   let n = hDim0
   let ldh = hDim1
   let ihiz = zDim0
   let ldz = zDim1
   Call.assert "laqr5: nshfts == siDim0" (nshfts == siDim0)
   v <- Call.newArray2 (nshfts`div`2) ldv
   u <- Call.newArray2 (3*nshfts-3) ldu
   wv <- Call.newArray2 (3*nshfts-3) ldwv
   wh <- Call.newArray2 nh ldwh
   evalContT $ do
      wanttPtr <- Call.bool wantt
      wantzPtr <- Call.bool wantz
      kacc22Ptr <- Call.cint kacc22
      nPtr <- Call.cint n
      ktopPtr <- Call.cint ktop
      kbotPtr <- Call.cint kbot
      nshftsPtr <- Call.cint nshfts
      srPtr <- Call.ioarray sr
      siPtr <- Call.ioarray si
      hPtr <- Call.ioarray h
      ldhPtr <- Call.cint ldh
      ilozPtr <- Call.cint iloz
      ihizPtr <- Call.cint ihiz
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      nvPtr <- Call.cint nv
      wvPtr <- Call.ioarray wv
      ldwvPtr <- Call.cint ldwv
      nhPtr <- Call.cint nh
      whPtr <- Call.ioarray wh
      ldwhPtr <- Call.cint ldwh
      liftIO $ FFI.laqr5 wanttPtr wantzPtr kacc22Ptr nPtr ktopPtr kbotPtr nshftsPtr srPtr siPtr hPtr ldhPtr ilozPtr ihizPtr zPtr ldzPtr vPtr ldvPtr uPtr lduPtr nvPtr wvPtr ldwvPtr nhPtr whPtr ldwhPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray v
         <*> Call.freezeArray u
         <*> Call.freezeArray wv
         <*> Call.freezeArray wh

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqsb.f>
laqsb ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array ZeroInt Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsb uplo kd ab s scond amax = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let sDim0 = Call.sizes1 $ Array.shape s
   let n = abDim0
   let ldab = abDim1
   Call.assert "laqsb: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsb uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqsp.f>
laqsp ::
   Char {- ^ uplo -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsp uplo ap s scond amax = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let sDim0 = Call.sizes1 $ Array.shape s
   let n = sDim0
   Call.assert "laqsp: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsp uploPtr nPtr apPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqsy.f>
laqsy ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ s -} ->
   Float {- ^ scond -} ->
   Float {- ^ amax -} ->
   IO (Char)
laqsy uplo a s scond amax = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let sDim0 = Call.sizes1 $ Array.shape s
   let n = aDim0
   let lda = aDim1
   Call.assert "laqsy: n == sDim0" (n == sDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      sPtr <- Call.array s
      scondPtr <- Call.float scond
      amaxPtr <- Call.float amax
      equedPtr <- Call.alloca
      liftIO $ FFI.laqsy uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr equedPtr
      liftIO $ fmap castCCharToChar (peek equedPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaqtr.f>
laqtr ::
   Bool {- ^ ltran -} ->
   Bool {- ^ lreal -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ t -} ->
   Array ZeroInt Float {- ^ b -} ->
   Float {- ^ w -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   IO (Float, Int)
laqtr ltran lreal t b w x = do
   let (tDim0,tDim1) = Call.sizes2 $ Array.shape t
   let bDim0 = Call.sizes1 $ Array.shape b
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let n = tDim0
   let ldt = tDim1
   Call.assert "laqtr: n == bDim0" (n == bDim0)
   Call.assert "laqtr: 2*n == xDim0" (2*n == xDim0)
   work <- Call.newArray1 n
   evalContT $ do
      ltranPtr <- Call.bool ltran
      lrealPtr <- Call.bool lreal
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      bPtr <- Call.array b
      wPtr <- Call.float w
      scalePtr <- Call.alloca
      xPtr <- Call.ioarray x
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.laqtr ltranPtr lrealPtr nPtr tPtr ldtPtr bPtr wPtr scalePtr xPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slar1v.f>
lar1v ::
   Int {- ^ b1 -} ->
   Int {- ^ bn -} ->
   Float {- ^ lambda -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ l -} ->
   Array ZeroInt Float {- ^ ld -} ->
   Array ZeroInt Float {- ^ lld -} ->
   Float {- ^ pivmin -} ->
   Float {- ^ gaptol -} ->
   IOArray ZeroInt Float {- ^ z -} ->
   Bool {- ^ wantnc -} ->
   Int {- ^ r -} ->
   IO (Int, Float, Float, Int, Array ZeroInt CInt, Float, Float, Float)
lar1v b1 bn lambda d l ld lld pivmin gaptol z wantnc r = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let lDim0 = Call.sizes1 $ Array.shape l
   let ldDim0 = Call.sizes1 $ Array.shape ld
   let lldDim0 = Call.sizes1 $ Array.shape lld
   let zDim0 = Call.sizes1 $ MutArray.shape z
   let n = dDim0
   Call.assert "lar1v: n-1 == lDim0" (n-1 == lDim0)
   Call.assert "lar1v: n-1 == ldDim0" (n-1 == ldDim0)
   Call.assert "lar1v: n-1 == lldDim0" (n-1 == lldDim0)
   Call.assert "lar1v: n == zDim0" (n == zDim0)
   isuppz <- Call.newArray1 2
   work <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      b1Ptr <- Call.cint b1
      bnPtr <- Call.cint bn
      lambdaPtr <- Call.float lambda
      dPtr <- Call.array d
      lPtr <- Call.array l
      ldPtr <- Call.array ld
      lldPtr <- Call.array lld
      pivminPtr <- Call.float pivmin
      gaptolPtr <- Call.float gaptol
      zPtr <- Call.ioarray z
      wantncPtr <- Call.bool wantnc
      negcntPtr <- Call.alloca
      ztzPtr <- Call.alloca
      mingmaPtr <- Call.alloca
      rPtr <- Call.cint r
      isuppzPtr <- Call.ioarray isuppz
      nrminvPtr <- Call.alloca
      residPtr <- Call.alloca
      rqcorrPtr <- Call.alloca
      workPtr <- Call.ioarray work
      liftIO $ FFI.lar1v nPtr b1Ptr bnPtr lambdaPtr dPtr lPtr ldPtr lldPtr pivminPtr gaptolPtr zPtr wantncPtr negcntPtr ztzPtr mingmaPtr rPtr isuppzPtr nrminvPtr residPtr rqcorrPtr workPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek negcntPtr)
         <*> peek ztzPtr
         <*> peek mingmaPtr
         <*> fmap fromIntegral (peek rPtr)
         <*> Call.freezeArray isuppz
         <*> peek nrminvPtr
         <*> peek residPtr
         <*> peek rqcorrPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slar2v.f>
lar2v ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   IOArray ZeroInt Float {- ^ z -} ->
   Int {- ^ incx -} ->
   Array ZeroInt Float {- ^ c -} ->
   Array ZeroInt Float {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lar2v n x y z incx c s incc = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let zDim0 = Call.sizes1 $ MutArray.shape z
   let cDim0 = Call.sizes1 $ Array.shape c
   let sDim0 = Call.sizes1 $ Array.shape s
   let _xSize = xDim0
   let _ySize = yDim0
   let _zSize = zDim0
   Call.assert "lar2v: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lar2v: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      yPtr <- Call.ioarray y
      zPtr <- Call.ioarray z
      incxPtr <- Call.cint incx
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lar2v nPtr xPtr yPtr zPtr incxPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarf.f>
larf ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   Array ZeroInt Float {- ^ v -} ->
   Int {- ^ incv -} ->
   Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larf side m v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ Array.shape v
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.float tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larf sidePtr mPtr nPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfb.f>
larfb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larfb side trans direct storev m v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ Array.shape v
   let (tDim0,tDim1) = Call.sizes2 $ Array.shape t
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _vSize = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larfb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfg.f>
larfg ::
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Float, Float)
larfg n alpha x incx = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfg nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfgp.f>
larfgp ::
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IO (Float, Float)
larfgp n alpha x incx = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let _xSize = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      tauPtr <- Call.alloca
      liftIO $ FFI.larfgp nPtr alphaPtr xPtr incxPtr tauPtr
      liftIO $ pure (,)
         <*> peek alphaPtr
         <*> peek tauPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarft.f>
larft ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (Array (ZeroInt,ZeroInt) Float)
larft direct storev n v tau ldt = do
   let (vDim0,vDim1) = Call.sizes2 $ Array.shape v
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larft directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfx.f>
larfx ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   Array ZeroInt Float {- ^ v -} ->
   Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larfx side m v tau c workSize = do
   let vDim0 = Call.sizes1 $ Array.shape v
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _vSize = vDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      vPtr <- Call.array v
      tauPtr <- Call.float tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larfx sidePtr mPtr nPtr vPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slargv.f>
largv ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   Int {- ^ incc -} ->
   IO (Array ZeroInt Float)
largv n x incx y incy incc = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let _xSize = xDim0
   let _ySize = yDim0
   c <- Call.newArray1 (1+(n-1)*incc)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.ioarray c
      inccPtr <- Call.cint incc
      liftIO $ FFI.largv nPtr xPtr incxPtr yPtr incyPtr cPtr inccPtr
      liftIO $ Call.freezeArray c

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarnv.f>
larnv ::
   Int {- ^ idist -} ->
   IOArray ZeroInt CInt {- ^ iseed -} ->
   Int {- ^ n -} ->
   IO (Array ZeroInt Float)
larnv idist iseed n = do
   let iseedDim0 = Call.sizes1 $ MutArray.shape iseed
   Call.assert "larnv: 4 == iseedDim0" (4 == iseedDim0)
   x <- Call.newArray1 n
   evalContT $ do
      idistPtr <- Call.cint idist
      iseedPtr <- Call.ioarray iseed
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      liftIO $ FFI.larnv idistPtr iseedPtr nPtr xPtr
      liftIO $ Call.freezeArray x

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarra.f>
larra ::
   Array ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray ZeroInt Float {- ^ e2 -} ->
   Float {- ^ spltol -} ->
   Float {- ^ tnrm -} ->
   IO (Int, Array ZeroInt CInt, Int)
larra d e e2 spltol tnrm = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let e2Dim0 = Call.sizes1 $ MutArray.shape e2
   let n = dDim0
   Call.assert "larra: n == eDim0" (n == eDim0)
   Call.assert "larra: n == e2Dim0" (n == e2Dim0)
   isplit <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.ioarray e
      e2Ptr <- Call.ioarray e2
      spltolPtr <- Call.float spltol
      tnrmPtr <- Call.float tnrm
      nsplitPtr <- Call.alloca
      isplitPtr <- Call.ioarray isplit
      infoPtr <- Call.alloca
      liftIO $ FFI.larra nPtr dPtr ePtr e2Ptr spltolPtr tnrmPtr nsplitPtr isplitPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrb.f>
larrb ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ lld -} ->
   Int {- ^ ifirst -} ->
   Int {- ^ ilast -} ->
   Float {- ^ rtol1 -} ->
   Float {- ^ rtol2 -} ->
   Int {- ^ offset -} ->
   IOArray ZeroInt Float {- ^ w -} ->
   IOArray ZeroInt Float {- ^ wgap -} ->
   IOArray ZeroInt Float {- ^ werr -} ->
   Float {- ^ pivmin -} ->
   Float {- ^ spdiam -} ->
   Int {- ^ twist -} ->
   IO (Int)
larrb d lld ifirst ilast rtol1 rtol2 offset w wgap werr pivmin spdiam twist = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let lldDim0 = Call.sizes1 $ Array.shape lld
   let wDim0 = Call.sizes1 $ MutArray.shape w
   let wgapDim0 = Call.sizes1 $ MutArray.shape wgap
   let werrDim0 = Call.sizes1 $ MutArray.shape werr
   let n = dDim0
   Call.assert "larrb: n-1 == lldDim0" (n-1 == lldDim0)
   Call.assert "larrb: n == wDim0" (n == wDim0)
   Call.assert "larrb: n-1 == wgapDim0" (n-1 == wgapDim0)
   Call.assert "larrb: n == werrDim0" (n == werrDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lldPtr <- Call.array lld
      ifirstPtr <- Call.cint ifirst
      ilastPtr <- Call.cint ilast
      rtol1Ptr <- Call.float rtol1
      rtol2Ptr <- Call.float rtol2
      offsetPtr <- Call.cint offset
      wPtr <- Call.ioarray w
      wgapPtr <- Call.ioarray wgap
      werrPtr <- Call.ioarray werr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      pivminPtr <- Call.float pivmin
      spdiamPtr <- Call.float spdiam
      twistPtr <- Call.cint twist
      infoPtr <- Call.alloca
      liftIO $ FFI.larrb nPtr dPtr lldPtr ifirstPtr ilastPtr rtol1Ptr rtol2Ptr offsetPtr wPtr wgapPtr werrPtr workPtr iworkPtr pivminPtr spdiamPtr twistPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrc.f>
larrc ::
   Char {- ^ jobt -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Float {- ^ pivmin -} ->
   IO (Int, Int, Int, Int)
larrc jobt vl vu d e pivmin = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let n = dDim0
   Call.assert "larrc: n == eDim0" (n == eDim0)
   evalContT $ do
      jobtPtr <- Call.char jobt
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      dPtr <- Call.array d
      ePtr <- Call.array e
      pivminPtr <- Call.float pivmin
      eigcntPtr <- Call.alloca
      lcntPtr <- Call.alloca
      rcntPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.larrc jobtPtr nPtr vlPtr vuPtr dPtr ePtr pivminPtr eigcntPtr lcntPtr rcntPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek eigcntPtr)
         <*> fmap fromIntegral (peek lcntPtr)
         <*> fmap fromIntegral (peek rcntPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrd.f>
larrd ::
   Char {- ^ range -} ->
   Char {- ^ order -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Array ZeroInt Float {- ^ gers -} ->
   Float {- ^ reltol -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Array ZeroInt Float {- ^ e2 -} ->
   Float {- ^ pivmin -} ->
   Int {- ^ nsplit -} ->
   Array ZeroInt CInt {- ^ isplit -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Float, Float, Array ZeroInt CInt, Array ZeroInt CInt, Int)
larrd range order vl vu il iu gers reltol d e e2 pivmin nsplit isplit = do
   let gersDim0 = Call.sizes1 $ Array.shape gers
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let e2Dim0 = Call.sizes1 $ Array.shape e2
   let isplitDim0 = Call.sizes1 $ Array.shape isplit
   let n = dDim0
   Call.assert "larrd: 2*n == gersDim0" (2*n == gersDim0)
   Call.assert "larrd: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "larrd: n-1 == e2Dim0" (n-1 == e2Dim0)
   Call.assert "larrd: n == isplitDim0" (n == isplitDim0)
   w <- Call.newArray1 n
   werr <- Call.newArray1 n
   iblock <- Call.newArray1 n
   indexw <- Call.newArray1 n
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      rangePtr <- Call.char range
      orderPtr <- Call.char order
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      gersPtr <- Call.array gers
      reltolPtr <- Call.float reltol
      dPtr <- Call.array d
      ePtr <- Call.array e
      e2Ptr <- Call.array e2
      pivminPtr <- Call.float pivmin
      nsplitPtr <- Call.cint nsplit
      isplitPtr <- Call.array isplit
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wlPtr <- Call.alloca
      wuPtr <- Call.alloca
      iblockPtr <- Call.ioarray iblock
      indexwPtr <- Call.ioarray indexw
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larrd rangePtr orderPtr nPtr vlPtr vuPtr ilPtr iuPtr gersPtr reltolPtr dPtr ePtr e2Ptr pivminPtr nsplitPtr isplitPtr mPtr wPtr werrPtr wlPtr wuPtr iblockPtr indexwPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray werr
         <*> peek wlPtr
         <*> peek wuPtr
         <*> Call.freezeArray iblock
         <*> Call.freezeArray indexw
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarre.f>
larre ::
   Char {- ^ range -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray ZeroInt Float {- ^ e2 -} ->
   Float {- ^ rtol1 -} ->
   Float {- ^ rtol2 -} ->
   Float {- ^ spltol -} ->
   IO (Float, Float, Int, Array ZeroInt CInt, Int, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt Float, Float, Int)
larre range vl vu il iu d e e2 rtol1 rtol2 spltol = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let e2Dim0 = Call.sizes1 $ MutArray.shape e2
   let n = dDim0
   Call.assert "larre: n == eDim0" (n == eDim0)
   Call.assert "larre: n == e2Dim0" (n == e2Dim0)
   isplit <- Call.newArray1 n
   w <- Call.newArray1 n
   werr <- Call.newArray1 n
   wgap <- Call.newArray1 n
   iblock <- Call.newArray1 n
   indexw <- Call.newArray1 n
   gers <- Call.newArray1 (2*n)
   work <- Call.newArray1 (6*n)
   iwork <- Call.newArray1 (5*n)
   evalContT $ do
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      e2Ptr <- Call.ioarray e2
      rtol1Ptr <- Call.float rtol1
      rtol2Ptr <- Call.float rtol2
      spltolPtr <- Call.float spltol
      nsplitPtr <- Call.alloca
      isplitPtr <- Call.ioarray isplit
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wgapPtr <- Call.ioarray wgap
      iblockPtr <- Call.ioarray iblock
      indexwPtr <- Call.ioarray indexw
      gersPtr <- Call.ioarray gers
      pivminPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larre rangePtr nPtr vlPtr vuPtr ilPtr iuPtr dPtr ePtr e2Ptr rtol1Ptr rtol2Ptr spltolPtr nsplitPtr isplitPtr mPtr wPtr werrPtr wgapPtr iblockPtr indexwPtr gersPtr pivminPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,)
         <*> peek vlPtr
         <*> peek vuPtr
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray werr
         <*> Call.freezeArray wgap
         <*> Call.freezeArray iblock
         <*> Call.freezeArray indexw
         <*> Call.freezeArray gers
         <*> peek pivminPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrf.f>
larrf ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ l -} ->
   Array ZeroInt Float {- ^ ld -} ->
   Int {- ^ clstrt -} ->
   Int {- ^ clend -} ->
   Array ZeroInt Float {- ^ w -} ->
   IOArray ZeroInt Float {- ^ wgap -} ->
   Array ZeroInt Float {- ^ werr -} ->
   Float {- ^ spdiam -} ->
   Float {- ^ clgapl -} ->
   Float {- ^ clgapr -} ->
   Float {- ^ pivmin -} ->
   IO (Float, Array ZeroInt Float, Array ZeroInt Float, Int)
larrf d l ld clstrt clend w wgap werr spdiam clgapl clgapr pivmin = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let lDim0 = Call.sizes1 $ Array.shape l
   let ldDim0 = Call.sizes1 $ Array.shape ld
   let wDim0 = Call.sizes1 $ Array.shape w
   let wgapDim0 = Call.sizes1 $ MutArray.shape wgap
   let werrDim0 = Call.sizes1 $ Array.shape werr
   let n = dDim0
   let _wSize = wDim0
   let _wgapSize = wgapDim0
   let _werrSize = werrDim0
   Call.assert "larrf: n-1 == lDim0" (n-1 == lDim0)
   Call.assert "larrf: n-1 == ldDim0" (n-1 == ldDim0)
   dplus <- Call.newArray1 n
   lplus <- Call.newArray1 (n-1)
   work <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      lPtr <- Call.array l
      ldPtr <- Call.array ld
      clstrtPtr <- Call.cint clstrt
      clendPtr <- Call.cint clend
      wPtr <- Call.array w
      wgapPtr <- Call.ioarray wgap
      werrPtr <- Call.array werr
      spdiamPtr <- Call.float spdiam
      clgaplPtr <- Call.float clgapl
      clgaprPtr <- Call.float clgapr
      pivminPtr <- Call.float pivmin
      sigmaPtr <- Call.alloca
      dplusPtr <- Call.ioarray dplus
      lplusPtr <- Call.ioarray lplus
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.larrf nPtr dPtr lPtr ldPtr clstrtPtr clendPtr wPtr wgapPtr werrPtr spdiamPtr clgaplPtr clgaprPtr pivminPtr sigmaPtr dplusPtr lplusPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> peek sigmaPtr
         <*> Call.freezeArray dplus
         <*> Call.freezeArray lplus
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrj.f>
larrj ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e2 -} ->
   Int {- ^ ifirst -} ->
   Int {- ^ ilast -} ->
   Float {- ^ rtol -} ->
   Int {- ^ offset -} ->
   IOArray ZeroInt Float {- ^ w -} ->
   IOArray ZeroInt Float {- ^ werr -} ->
   Float {- ^ pivmin -} ->
   Float {- ^ spdiam -} ->
   IO (Int)
larrj d e2 ifirst ilast rtol offset w werr pivmin spdiam = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let e2Dim0 = Call.sizes1 $ Array.shape e2
   let wDim0 = Call.sizes1 $ MutArray.shape w
   let werrDim0 = Call.sizes1 $ MutArray.shape werr
   let n = dDim0
   Call.assert "larrj: n-1 == e2Dim0" (n-1 == e2Dim0)
   Call.assert "larrj: n == wDim0" (n == wDim0)
   Call.assert "larrj: n == werrDim0" (n == werrDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      e2Ptr <- Call.array e2
      ifirstPtr <- Call.cint ifirst
      ilastPtr <- Call.cint ilast
      rtolPtr <- Call.float rtol
      offsetPtr <- Call.cint offset
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      pivminPtr <- Call.float pivmin
      spdiamPtr <- Call.float spdiam
      infoPtr <- Call.alloca
      liftIO $ FFI.larrj nPtr dPtr e2Ptr ifirstPtr ilastPtr rtolPtr offsetPtr wPtr werrPtr workPtr iworkPtr pivminPtr spdiamPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrk.f>
larrk ::
   Int {- ^ iw -} ->
   Float {- ^ gl -} ->
   Float {- ^ gu -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e2 -} ->
   Float {- ^ pivmin -} ->
   Float {- ^ reltol -} ->
   IO (Float, Float, Int)
larrk iw gl gu d e2 pivmin reltol = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let e2Dim0 = Call.sizes1 $ Array.shape e2
   let n = dDim0
   Call.assert "larrk: n-1 == e2Dim0" (n-1 == e2Dim0)
   evalContT $ do
      nPtr <- Call.cint n
      iwPtr <- Call.cint iw
      glPtr <- Call.float gl
      guPtr <- Call.float gu
      dPtr <- Call.array d
      e2Ptr <- Call.array e2
      pivminPtr <- Call.float pivmin
      reltolPtr <- Call.float reltol
      wPtr <- Call.alloca
      werrPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.larrk nPtr iwPtr glPtr guPtr dPtr e2Ptr pivminPtr reltolPtr wPtr werrPtr infoPtr
      liftIO $ pure (,,)
         <*> peek wPtr
         <*> peek werrPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrr.f>
larrr ::
   Array ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IO (Int)
larrr d e = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "larrr: n == eDim0" (n == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.larrr nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrv.f>
larrv ::
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ l -} ->
   Float {- ^ pivmin -} ->
   Array ZeroInt CInt {- ^ isplit -} ->
   Int {- ^ m -} ->
   Int {- ^ dol -} ->
   Int {- ^ dou -} ->
   Float {- ^ minrgp -} ->
   Float {- ^ rtol1 -} ->
   Float {- ^ rtol2 -} ->
   IOArray ZeroInt Float {- ^ w -} ->
   IOArray ZeroInt Float {- ^ werr -} ->
   IOArray ZeroInt Float {- ^ wgap -} ->
   Array ZeroInt CInt {- ^ iblock -} ->
   Array ZeroInt CInt {- ^ indexw -} ->
   Array ZeroInt Float {- ^ gers -} ->
   Int {- ^ ldz -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
larrv vl vu d l pivmin isplit m dol dou minrgp rtol1 rtol2 w werr wgap iblock indexw gers ldz = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let lDim0 = Call.sizes1 $ MutArray.shape l
   let isplitDim0 = Call.sizes1 $ Array.shape isplit
   let wDim0 = Call.sizes1 $ MutArray.shape w
   let werrDim0 = Call.sizes1 $ MutArray.shape werr
   let wgapDim0 = Call.sizes1 $ MutArray.shape wgap
   let iblockDim0 = Call.sizes1 $ Array.shape iblock
   let indexwDim0 = Call.sizes1 $ Array.shape indexw
   let gersDim0 = Call.sizes1 $ Array.shape gers
   let n = dDim0
   Call.assert "larrv: n == lDim0" (n == lDim0)
   Call.assert "larrv: n == isplitDim0" (n == isplitDim0)
   Call.assert "larrv: n == wDim0" (n == wDim0)
   Call.assert "larrv: n == werrDim0" (n == werrDim0)
   Call.assert "larrv: n == wgapDim0" (n == wgapDim0)
   Call.assert "larrv: n == iblockDim0" (n == iblockDim0)
   Call.assert "larrv: n == indexwDim0" (n == indexwDim0)
   Call.assert "larrv: 2*n == gersDim0" (2*n == gersDim0)
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (12*n)
   iwork <- Call.newArray1 (7*n)
   evalContT $ do
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      dPtr <- Call.ioarray d
      lPtr <- Call.ioarray l
      pivminPtr <- Call.float pivmin
      isplitPtr <- Call.array isplit
      mPtr <- Call.cint m
      dolPtr <- Call.cint dol
      douPtr <- Call.cint dou
      minrgpPtr <- Call.float minrgp
      rtol1Ptr <- Call.float rtol1
      rtol2Ptr <- Call.float rtol2
      wPtr <- Call.ioarray w
      werrPtr <- Call.ioarray werr
      wgapPtr <- Call.ioarray wgap
      iblockPtr <- Call.array iblock
      indexwPtr <- Call.array indexw
      gersPtr <- Call.array gers
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.larrv nPtr vlPtr vuPtr dPtr lPtr pivminPtr isplitPtr mPtr dolPtr douPtr minrgpPtr rtol1Ptr rtol2Ptr wPtr werrPtr wgapPtr iblockPtr indexwPtr gersPtr zPtr ldzPtr isuppzPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartg.f>
lartg ::
   Float {- ^ f -} ->
   Float {- ^ g -} ->
   IO (Float, Float, Float)
lartg f g = do
   evalContT $ do
      fPtr <- Call.float f
      gPtr <- Call.float g
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      rPtr <- Call.alloca
      liftIO $ FFI.lartg fPtr gPtr csPtr snPtr rPtr
      liftIO $ pure (,,)
         <*> peek csPtr
         <*> peek snPtr
         <*> peek rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartgp.f>
lartgp ::
   Float {- ^ f -} ->
   Float {- ^ g -} ->
   IO (Float, Float, Float)
lartgp f g = do
   evalContT $ do
      fPtr <- Call.float f
      gPtr <- Call.float g
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      rPtr <- Call.alloca
      liftIO $ FFI.lartgp fPtr gPtr csPtr snPtr rPtr
      liftIO $ pure (,,)
         <*> peek csPtr
         <*> peek snPtr
         <*> peek rPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartgs.f>
lartgs ::
   Float {- ^ x -} ->
   Float {- ^ y -} ->
   Float {- ^ sigma -} ->
   IO (Float, Float)
lartgs x y sigma = do
   evalContT $ do
      xPtr <- Call.float x
      yPtr <- Call.float y
      sigmaPtr <- Call.float sigma
      csPtr <- Call.alloca
      snPtr <- Call.alloca
      liftIO $ FFI.lartgs xPtr yPtr sigmaPtr csPtr snPtr
      liftIO $ pure (,)
         <*> peek csPtr
         <*> peek snPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartv.f>
lartv ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   IOArray ZeroInt Float {- ^ y -} ->
   Int {- ^ incy -} ->
   Array ZeroInt Float {- ^ c -} ->
   Array ZeroInt Float {- ^ s -} ->
   Int {- ^ incc -} ->
   IO ()
lartv n x incx y incy c s incc = do
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let yDim0 = Call.sizes1 $ MutArray.shape y
   let cDim0 = Call.sizes1 $ Array.shape c
   let sDim0 = Call.sizes1 $ Array.shape s
   let _xSize = xDim0
   let _ySize = yDim0
   Call.assert "lartv: 1+(n-1)*incc == cDim0" (1+(n-1)*incc == cDim0)
   Call.assert "lartv: 1+(n-1)*incc == sDim0" (1+(n-1)*incc == sDim0)
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      incxPtr <- Call.cint incx
      yPtr <- Call.ioarray y
      incyPtr <- Call.cint incy
      cPtr <- Call.array c
      sPtr <- Call.array s
      inccPtr <- Call.cint incc
      liftIO $ FFI.lartv nPtr xPtr incxPtr yPtr incyPtr cPtr sPtr inccPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaruv.f>
laruv ::
   IOArray ZeroInt CInt {- ^ iseed -} ->
   Int {- ^ n -} ->
   IO (Array ZeroInt Float)
laruv iseed n = do
   let iseedDim0 = Call.sizes1 $ MutArray.shape iseed
   Call.assert "laruv: 4 == iseedDim0" (4 == iseedDim0)
   x <- Call.newArray1 n
   evalContT $ do
      iseedPtr <- Call.ioarray iseed
      nPtr <- Call.cint n
      xPtr <- Call.ioarray x
      liftIO $ FFI.laruv iseedPtr nPtr xPtr
      liftIO $ Call.freezeArray x

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarz.f>
larz ::
   Char {- ^ side -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   Array ZeroInt Float {- ^ v -} ->
   Int {- ^ incv -} ->
   Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO ()
larz side m l v incv tau c workSize = do
   let vDim0 = Call.sizes1 $ Array.shape v
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let n = cDim0
   let ldc = cDim1
   Call.assert "larz: 1+(l-1)*abs(incv) == vDim0" (1+(l-1)*abs(incv) == vDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      vPtr <- Call.array v
      incvPtr <- Call.cint incv
      tauPtr <- Call.float tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      liftIO $ FFI.larz sidePtr mPtr nPtr lPtr vPtr incvPtr tauPtr cPtr ldcPtr workPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarzb.f>
larzb ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ ldwork -} ->
   IO ()
larzb side trans direct storev m l v t c ldwork = do
   let (vDim0,vDim1) = Call.sizes2 $ Array.shape v
   let (tDim0,tDim1) = Call.sizes2 $ Array.shape t
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _nv = vDim0
   let ldv = vDim1
   let k = tDim0
   let ldt = tDim1
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray2 k ldwork
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      vPtr <- Call.array v
      ldvPtr <- Call.cint ldv
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      liftIO $ FFI.larzb sidePtr transPtr directPtr storevPtr mPtr nPtr kPtr lPtr vPtr ldvPtr tPtr ldtPtr cPtr ldcPtr workPtr ldworkPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarzt.f>
larzt ::
   Char {- ^ direct -} ->
   Char {- ^ storev -} ->
   Int {- ^ n -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ ldt -} ->
   IO (Array (ZeroInt,ZeroInt) Float)
larzt direct storev n v tau ldt = do
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let _vSize = vDim0
   let ldv = vDim1
   let k = tauDim0
   t <- Call.newArray2 k ldt
   evalContT $ do
      directPtr <- Call.char direct
      storevPtr <- Call.char storev
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      tauPtr <- Call.array tau
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      liftIO $ FFI.larzt directPtr storevPtr nPtr kPtr vPtr ldvPtr tauPtr tPtr ldtPtr
      liftIO $ Call.freezeArray t

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slas2.f>
las2 ::
   Float {- ^ f -} ->
   Float {- ^ g -} ->
   Float {- ^ h -} ->
   IO (Float, Float)
las2 f g h = do
   evalContT $ do
      fPtr <- Call.float f
      gPtr <- Call.float g
      hPtr <- Call.float h
      ssminPtr <- Call.alloca
      ssmaxPtr <- Call.alloca
      liftIO $ FFI.las2 fPtr gPtr hPtr ssminPtr ssmaxPtr
      liftIO $ pure (,)
         <*> peek ssminPtr
         <*> peek ssmaxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slascl.f>
lascl ::
   Char {- ^ type_ -} ->
   Int {- ^ kl -} ->
   Int {- ^ ku -} ->
   Float {- ^ cfrom -} ->
   Float {- ^ cto -} ->
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
lascl type_ kl ku cfrom cto m a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      type_Ptr <- Call.char type_
      klPtr <- Call.cint kl
      kuPtr <- Call.cint ku
      cfromPtr <- Call.float cfrom
      ctoPtr <- Call.float cto
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lascl type_Ptr klPtr kuPtr cfromPtr ctoPtr mPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd0.f>
lasd0 ::
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Int {- ^ ldu -} ->
   Int {- ^ m -} ->
   Int {- ^ ldvt -} ->
   Int {- ^ smlsiz -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
lasd0 sqre d e ldu m ldvt smlsiz = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "lasd0: m-1 == eDim0" (m-1 == eDim0)
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 m ldvt
   iwork <- Call.newArray1 (8*n)
   work <- Call.newArray1 (3*m^!2+2*m)
   evalContT $ do
      nPtr <- Call.cint n
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      smlsizPtr <- Call.cint smlsiz
      iworkPtr <- Call.ioarray iwork
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd0 nPtr sqrePtr dPtr ePtr uPtr lduPtr vtPtr ldvtPtr smlsizPtr iworkPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd1.f>
lasd1 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Float {- ^ alpha -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vt -} ->
   IOArray ZeroInt CInt {- ^ idxq -} ->
   IO (Float, Float, Int)
lasd1 nl nr sqre d alpha beta u vt idxq = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (uDim0,uDim1) = Call.sizes2 $ MutArray.shape u
   let (vtDim0,vtDim1) = Call.sizes2 $ MutArray.shape vt
   let idxqDim0 = Call.sizes1 $ MutArray.shape idxq
   let n = uDim0
   let ldu = uDim1
   let m = vtDim0
   let ldvt = vtDim1
   Call.assert "lasd1: nl+nr+1 == dDim0" (nl+nr+1 == dDim0)
   Call.assert "lasd1: n == idxqDim0" (n == idxqDim0)
   iwork <- Call.newArray1 (4*n)
   work <- Call.newArray1 (3*m^!2+2*m)
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      alphaPtr <- Call.float alpha
      betaPtr <- Call.float beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      idxqPtr <- Call.ioarray idxq
      iworkPtr <- Call.ioarray iwork
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd1 nlPtr nrPtr sqrePtr dPtr alphaPtr betaPtr uPtr lduPtr vtPtr ldvtPtr idxqPtr iworkPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> peek alphaPtr
         <*> peek betaPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd2.f>
lasd2 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Float {- ^ alpha -} ->
   Float {- ^ beta -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vt -} ->
   Int {- ^ ldu2 -} ->
   Int {- ^ ldvt2 -} ->
   IOArray ZeroInt CInt {- ^ idxq -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt, Int)
lasd2 nl nr sqre d alpha beta u vt ldu2 ldvt2 idxq = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let (uDim0,uDim1) = Call.sizes2 $ MutArray.shape u
   let (vtDim0,vtDim1) = Call.sizes2 $ MutArray.shape vt
   let idxqDim0 = Call.sizes1 $ MutArray.shape idxq
   let n = dDim0
   let ldu = uDim1
   let _m = vtDim0
   let ldvt = vtDim1
   Call.assert "lasd2: n == uDim0" (n == uDim0)
   Call.assert "lasd2: n == idxqDim0" (n == idxqDim0)
   z <- Call.newArray1 n
   dsigma <- Call.newArray1 n
   u2 <- Call.newArray2 n ldu2
   vt2 <- Call.newArray2 n ldvt2
   idxp <- Call.newArray1 n
   idx <- Call.newArray1 n
   idxc <- Call.newArray1 n
   coltyp <- Call.newArray1 n
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.alloca
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      alphaPtr <- Call.float alpha
      betaPtr <- Call.float beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      dsigmaPtr <- Call.ioarray dsigma
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      vt2Ptr <- Call.ioarray vt2
      ldvt2Ptr <- Call.cint ldvt2
      idxpPtr <- Call.ioarray idxp
      idxPtr <- Call.ioarray idx
      idxcPtr <- Call.ioarray idxc
      idxqPtr <- Call.ioarray idxq
      coltypPtr <- Call.ioarray coltyp
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd2 nlPtr nrPtr sqrePtr kPtr dPtr zPtr alphaPtr betaPtr uPtr lduPtr vtPtr ldvtPtr dsigmaPtr u2Ptr ldu2Ptr vt2Ptr ldvt2Ptr idxpPtr idxPtr idxcPtr idxqPtr coltypPtr infoPtr
      liftIO $ pure (,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> Call.freezeArray z
         <*> Call.freezeArray dsigma
         <*> Call.freezeArray u2
         <*> Call.freezeArray vt2
         <*> Call.freezeArray idxp
         <*> Call.freezeArray idx
         <*> Call.freezeArray idxc
         <*> Call.freezeArray coltyp
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd3.f>
lasd3 ::
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   Int {- ^ ldq -} ->
   IOArray ZeroInt Float {- ^ dsigma -} ->
   Int {- ^ ldu -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ u2 -} ->
   Int {- ^ m -} ->
   Int {- ^ ldvt -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vt2 -} ->
   Array ZeroInt CInt {- ^ idxc -} ->
   Array ZeroInt CInt {- ^ ctot -} ->
   IOArray ZeroInt Float {- ^ z -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
lasd3 nl nr sqre ldq dsigma ldu u2 m ldvt vt2 idxc ctot z = do
   let dsigmaDim0 = Call.sizes1 $ MutArray.shape dsigma
   let (u2Dim0,u2Dim1) = Call.sizes2 $ Array.shape u2
   let (vt2Dim0,vt2Dim1) = Call.sizes2 $ MutArray.shape vt2
   let idxcDim0 = Call.sizes1 $ Array.shape idxc
   let ctotDim0 = Call.sizes1 $ Array.shape ctot
   let zDim0 = Call.sizes1 $ MutArray.shape z
   let k = dsigmaDim0
   let n = u2Dim0
   let ldu2 = u2Dim1
   let ldvt2 = vt2Dim1
   Call.assert "lasd3: n == vt2Dim0" (n == vt2Dim0)
   Call.assert "lasd3: n == idxcDim0" (n == idxcDim0)
   Call.assert "lasd3: 4 == ctotDim0" (4 == ctotDim0)
   Call.assert "lasd3: k == zDim0" (k == zDim0)
   d <- Call.newArray1 k
   q <- Call.newArray2 k ldq
   u <- Call.newArray2 n ldu
   vt <- Call.newArray2 m ldvt
   evalContT $ do
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.cint k
      dPtr <- Call.ioarray d
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      dsigmaPtr <- Call.ioarray dsigma
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      u2Ptr <- Call.array u2
      ldu2Ptr <- Call.cint ldu2
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      vt2Ptr <- Call.ioarray vt2
      ldvt2Ptr <- Call.cint ldvt2
      idxcPtr <- Call.array idxc
      ctotPtr <- Call.array ctot
      zPtr <- Call.ioarray z
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd3 nlPtr nrPtr sqrePtr kPtr dPtr qPtr ldqPtr dsigmaPtr uPtr lduPtr u2Ptr ldu2Ptr vtPtr ldvtPtr vt2Ptr ldvt2Ptr idxcPtr ctotPtr zPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray q
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd4.f>
lasd4 ::
   Int {- ^ i -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ rho -} ->
   IO (Array ZeroInt Float, Float, Int)
lasd4 i d z rho = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let zDim0 = Call.sizes1 $ Array.shape z
   let n = dDim0
   Call.assert "lasd4: n == zDim0" (n == zDim0)
   delta <- Call.newArray1 n
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.float rho
      sigmaPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd4 nPtr iPtr dPtr zPtr deltaPtr rhoPtr sigmaPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray delta
         <*> peek sigmaPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd5.f>
lasd5 ::
   Int {- ^ i -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ z -} ->
   Float {- ^ rho -} ->
   IO (Array ZeroInt Float, Float)
lasd5 i d z rho = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.assert "lasd5: 2 == dDim0" (2 == dDim0)
   Call.assert "lasd5: 2 == zDim0" (2 == zDim0)
   delta <- Call.newArray1 2
   work <- Call.newArray1 2
   evalContT $ do
      iPtr <- Call.cint i
      dPtr <- Call.array d
      zPtr <- Call.array z
      deltaPtr <- Call.ioarray delta
      rhoPtr <- Call.float rho
      dsigmaPtr <- Call.alloca
      workPtr <- Call.ioarray work
      liftIO $ FFI.lasd5 iPtr dPtr zPtr deltaPtr rhoPtr dsigmaPtr workPtr
      liftIO $ pure (,)
         <*> Call.freezeArray delta
         <*> peek dsigmaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd6.f>
lasd6 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ vf -} ->
   IOArray ZeroInt Float {- ^ vl -} ->
   Float {- ^ alpha -} ->
   Float {- ^ beta -} ->
   IOArray ZeroInt CInt {- ^ idxq -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ ldgnum -} ->
   Int {- ^ difrSize -} ->
   IO (Float, Float, Array ZeroInt CInt, Int, Array (ZeroInt,ZeroInt) CInt, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int, Float, Float, Int)
lasd6 icompq nl nr sqre d vf vl alpha beta idxq ldgcol ldgnum difrSize = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let vfDim0 = Call.sizes1 $ MutArray.shape vf
   let vlDim0 = Call.sizes1 $ MutArray.shape vl
   let idxqDim0 = Call.sizes1 $ MutArray.shape idxq
   let m = vfDim0
   let n = idxqDim0
   Call.assert "lasd6: nl+nr+1 == dDim0" (nl+nr+1 == dDim0)
   Call.assert "lasd6: m == vlDim0" (m == vlDim0)
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 2 ldgcol
   givnum <- Call.newArray2 2 ldgnum
   poles <- Call.newArray2 2 ldgnum
   difl <- Call.newArray1 n
   difr <- Call.newArray1 difrSize
   z <- Call.newArray1 m
   work <- Call.newArray1 (4*m)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      vfPtr <- Call.ioarray vf
      vlPtr <- Call.ioarray vl
      alphaPtr <- Call.float alpha
      betaPtr <- Call.float beta
      idxqPtr <- Call.ioarray idxq
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.ioarray givnum
      ldgnumPtr <- Call.cint ldgnum
      polesPtr <- Call.ioarray poles
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      zPtr <- Call.ioarray z
      kPtr <- Call.alloca
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd6 icompqPtr nlPtr nrPtr sqrePtr dPtr vfPtr vlPtr alphaPtr betaPtr idxqPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr polesPtr diflPtr difrPtr zPtr kPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> peek alphaPtr
         <*> peek betaPtr
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> Call.freezeArray poles
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek kPtr)
         <*> peek cPtr
         <*> peek sPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd7.f>
lasd7 ::
   Int {- ^ icompq -} ->
   Int {- ^ nl -} ->
   Int {- ^ nr -} ->
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ vf -} ->
   IOArray ZeroInt Float {- ^ vl -} ->
   Float {- ^ alpha -} ->
   Float {- ^ beta -} ->
   Array ZeroInt CInt {- ^ idxq -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ ldgnum -} ->
   IO (Int, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt, Int, Array (ZeroInt,ZeroInt) CInt, Array (ZeroInt,ZeroInt) Float, Float, Float, Int)
lasd7 icompq nl nr sqre d vf vl alpha beta idxq ldgcol ldgnum = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let vfDim0 = Call.sizes1 $ MutArray.shape vf
   let vlDim0 = Call.sizes1 $ MutArray.shape vl
   let idxqDim0 = Call.sizes1 $ Array.shape idxq
   let n = dDim0
   let m = vfDim0
   Call.assert "lasd7: m == vlDim0" (m == vlDim0)
   Call.assert "lasd7: n == idxqDim0" (n == idxqDim0)
   z <- Call.newArray1 m
   zw <- Call.newArray1 m
   vfw <- Call.newArray1 m
   vlw <- Call.newArray1 m
   dsigma <- Call.newArray1 n
   idx <- Call.newArray1 n
   idxp <- Call.newArray1 n
   perm <- Call.newArray1 n
   givcol <- Call.newArray2 2 ldgcol
   givnum <- Call.newArray2 2 ldgnum
   evalContT $ do
      icompqPtr <- Call.cint icompq
      nlPtr <- Call.cint nl
      nrPtr <- Call.cint nr
      sqrePtr <- Call.cint sqre
      kPtr <- Call.alloca
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      zwPtr <- Call.ioarray zw
      vfPtr <- Call.ioarray vf
      vfwPtr <- Call.ioarray vfw
      vlPtr <- Call.ioarray vl
      vlwPtr <- Call.ioarray vlw
      alphaPtr <- Call.float alpha
      betaPtr <- Call.float beta
      dsigmaPtr <- Call.ioarray dsigma
      idxPtr <- Call.ioarray idx
      idxpPtr <- Call.ioarray idxp
      idxqPtr <- Call.array idxq
      permPtr <- Call.ioarray perm
      givptrPtr <- Call.alloca
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      givnumPtr <- Call.ioarray givnum
      ldgnumPtr <- Call.cint ldgnum
      cPtr <- Call.alloca
      sPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd7 icompqPtr nlPtr nrPtr sqrePtr kPtr dPtr zPtr zwPtr vfPtr vfwPtr vlPtr vlwPtr alphaPtr betaPtr dsigmaPtr idxPtr idxpPtr idxqPtr permPtr givptrPtr givcolPtr ldgcolPtr givnumPtr ldgnumPtr cPtr sPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,,)
         <*> fmap fromIntegral (peek kPtr)
         <*> Call.freezeArray z
         <*> Call.freezeArray zw
         <*> Call.freezeArray vfw
         <*> Call.freezeArray vlw
         <*> Call.freezeArray dsigma
         <*> Call.freezeArray idx
         <*> Call.freezeArray idxp
         <*> Call.freezeArray perm
         <*> fmap fromIntegral (peek givptrPtr)
         <*> Call.freezeArray givcol
         <*> Call.freezeArray givnum
         <*> peek cPtr
         <*> peek sPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd8.f>
lasd8 ::
   Int {- ^ icompq -} ->
   IOArray ZeroInt Float {- ^ z -} ->
   IOArray ZeroInt Float {- ^ vf -} ->
   IOArray ZeroInt Float {- ^ vl -} ->
   Int {- ^ difrSize -} ->
   Int {- ^ lddifr -} ->
   IOArray ZeroInt Float {- ^ dsigma -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Int)
lasd8 icompq z vf vl difrSize lddifr dsigma = do
   let zDim0 = Call.sizes1 $ MutArray.shape z
   let vfDim0 = Call.sizes1 $ MutArray.shape vf
   let vlDim0 = Call.sizes1 $ MutArray.shape vl
   let dsigmaDim0 = Call.sizes1 $ MutArray.shape dsigma
   let k = zDim0
   Call.assert "lasd8: k == vfDim0" (k == vfDim0)
   Call.assert "lasd8: k == vlDim0" (k == vlDim0)
   Call.assert "lasd8: k == dsigmaDim0" (k == dsigmaDim0)
   d <- Call.newArray1 k
   difl <- Call.newArray1 k
   difr <- Call.newArray2 difrSize lddifr
   work <- Call.newArray1 (3*k)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      kPtr <- Call.cint k
      dPtr <- Call.ioarray d
      zPtr <- Call.ioarray z
      vfPtr <- Call.ioarray vf
      vlPtr <- Call.ioarray vl
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      lddifrPtr <- Call.cint lddifr
      dsigmaPtr <- Call.ioarray dsigma
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasd8 icompqPtr kPtr dPtr zPtr vfPtr vlPtr diflPtr difrPtr lddifrPtr dsigmaPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasda.f>
lasda ::
   Int {- ^ icompq -} ->
   Int {- ^ smlsiz -} ->
   Int {- ^ sqre -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Int {- ^ uSize -} ->
   Int {- ^ ldu -} ->
   Int {- ^ vtSize -} ->
   Int {- ^ kSize -} ->
   Int {- ^ nlvl -} ->
   Int {- ^ difrSize -} ->
   Int {- ^ zSize -} ->
   Int {- ^ polesSize -} ->
   Int {- ^ givptrSize -} ->
   Int {- ^ givcolSize -} ->
   Int {- ^ ldgcol -} ->
   Int {- ^ permSize -} ->
   Int {- ^ givnumSize -} ->
   Int {- ^ cSize -} ->
   Int {- ^ sSize -} ->
   Int {- ^ workSize -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Array (ZeroInt,ZeroInt) CInt, Array (ZeroInt,ZeroInt) CInt, Array (ZeroInt,ZeroInt) Float, Array ZeroInt Float, Array ZeroInt Float, Int)
lasda icompq smlsiz sqre d e uSize ldu vtSize kSize nlvl difrSize zSize polesSize givptrSize givcolSize ldgcol permSize givnumSize cSize sSize workSize = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let n = dDim0
   Call.ignore "lasda: m-1 == eDim0" eDim0
   u <- Call.newArray2 uSize ldu
   vt <- Call.newArray2 vtSize ldu
   k <- Call.newArray1 kSize
   difl <- Call.newArray2 nlvl ldu
   difr <- Call.newArray2 difrSize ldu
   z <- Call.newArray2 zSize ldu
   poles <- Call.newArray2 polesSize ldu
   givptr <- Call.newArray1 givptrSize
   givcol <- Call.newArray2 givcolSize ldgcol
   perm <- Call.newArray2 permSize ldgcol
   givnum <- Call.newArray2 givnumSize ldu
   c <- Call.newArray1 cSize
   s <- Call.newArray1 sSize
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (7*n)
   evalContT $ do
      icompqPtr <- Call.cint icompq
      smlsizPtr <- Call.cint smlsiz
      nPtr <- Call.cint n
      sqrePtr <- Call.cint sqre
      dPtr <- Call.ioarray d
      ePtr <- Call.array e
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vtPtr <- Call.ioarray vt
      kPtr <- Call.ioarray k
      diflPtr <- Call.ioarray difl
      difrPtr <- Call.ioarray difr
      zPtr <- Call.ioarray z
      polesPtr <- Call.ioarray poles
      givptrPtr <- Call.ioarray givptr
      givcolPtr <- Call.ioarray givcol
      ldgcolPtr <- Call.cint ldgcol
      permPtr <- Call.ioarray perm
      givnumPtr <- Call.ioarray givnum
      cPtr <- Call.ioarray c
      sPtr <- Call.ioarray s
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.lasda icompqPtr smlsizPtr nPtr sqrePtr dPtr ePtr uPtr lduPtr vtPtr kPtr diflPtr difrPtr zPtr polesPtr givptrPtr givcolPtr ldgcolPtr permPtr givnumPtr cPtr sPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,,,,,,,,,)
         <*> Call.freezeArray u
         <*> Call.freezeArray vt
         <*> Call.freezeArray k
         <*> Call.freezeArray difl
         <*> Call.freezeArray difr
         <*> Call.freezeArray z
         <*> Call.freezeArray poles
         <*> Call.freezeArray givptr
         <*> Call.freezeArray givcol
         <*> Call.freezeArray perm
         <*> Call.freezeArray givnum
         <*> Call.freezeArray c
         <*> Call.freezeArray s
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasdq.f>
lasdq ::
   Char {- ^ uplo -} ->
   Int {- ^ sqre -} ->
   Int {- ^ nru -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vt -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO (Int)
lasdq uplo sqre nru d e vt u c = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (vtDim0,vtDim1) = Call.sizes2 $ MutArray.shape vt
   let (uDim0,uDim1) = Call.sizes2 $ MutArray.shape u
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let n = dDim0
   let ncvt = vtDim0
   let ldvt = vtDim1
   let ldu = uDim1
   let ncc = cDim0
   let ldc = cDim1
   Call.assert "lasdq: n-1+sqre == eDim0" (n-1+sqre == eDim0)
   Call.assert "lasdq: n == uDim0" (n == uDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      sqrePtr <- Call.cint sqre
      nPtr <- Call.cint n
      ncvtPtr <- Call.cint ncvt
      nruPtr <- Call.cint nru
      nccPtr <- Call.cint ncc
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vtPtr <- Call.ioarray vt
      ldvtPtr <- Call.cint ldvt
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasdq uploPtr sqrePtr nPtr ncvtPtr nruPtr nccPtr dPtr ePtr vtPtr ldvtPtr uPtr lduPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasdt.f>
lasdt ::
   Int {- ^ n -} ->
   Int {- ^ msub -} ->
   IO (Int, Int, Array ZeroInt CInt, Array ZeroInt CInt, Array ZeroInt CInt)
lasdt n msub = do
   inode <- Call.newArray1 n
   ndiml <- Call.newArray1 n
   ndimr <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      lvlPtr <- Call.alloca
      ndPtr <- Call.alloca
      inodePtr <- Call.ioarray inode
      ndimlPtr <- Call.ioarray ndiml
      ndimrPtr <- Call.ioarray ndimr
      msubPtr <- Call.cint msub
      liftIO $ FFI.lasdt nPtr lvlPtr ndPtr inodePtr ndimlPtr ndimrPtr msubPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek lvlPtr)
         <*> fmap fromIntegral (peek ndPtr)
         <*> Call.freezeArray inode
         <*> Call.freezeArray ndiml
         <*> Call.freezeArray ndimr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaset.f>
laset ::
   Char {- ^ uplo -} ->
   Int {- ^ m -} ->
   Int {- ^ n -} ->
   Float {- ^ alpha -} ->
   Float {- ^ beta -} ->
   Int {- ^ lda -} ->
   IO (Array (ZeroInt,ZeroInt) Float)
laset uplo m n alpha beta lda = do
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      betaPtr <- Call.float beta
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.laset uploPtr mPtr nPtr alphaPtr betaPtr aPtr ldaPtr
      liftIO $ Call.freezeArray a

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasq1.f>
lasq1 ::
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IO (Int)
lasq1 d e = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "lasq1: n == eDim0" (n == eDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.lasq1 nPtr dPtr ePtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasq2.f>
lasq2 ::
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ z -} ->
   IO (Int)
lasq2 n z = do
   let zDim0 = Call.sizes1 $ MutArray.shape z
   Call.assert "lasq2: 4*n == zDim0" (4*n == zDim0)
   evalContT $ do
      nPtr <- Call.cint n
      zPtr <- Call.ioarray z
      infoPtr <- Call.alloca
      liftIO $ FFI.lasq2 nPtr zPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasq4.f>
lasq4 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   Array ZeroInt Float {- ^ z -} ->
   Int {- ^ pp -} ->
   Int {- ^ n0in -} ->
   Float {- ^ dmin -} ->
   Float {- ^ dmin1 -} ->
   Float {- ^ dmin2 -} ->
   Float {- ^ dn -} ->
   Float {- ^ dn1 -} ->
   Float {- ^ dn2 -} ->
   Float {- ^ g -} ->
   IO (Float, Int, Float)
lasq4 i0 n0 z pp n0in dmin dmin1 dmin2 dn dn1 dn2 g = do
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.assert "lasq4: 4*n0 == zDim0" (4*n0 == zDim0)
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      n0inPtr <- Call.cint n0in
      dminPtr <- Call.float dmin
      dmin1Ptr <- Call.float dmin1
      dmin2Ptr <- Call.float dmin2
      dnPtr <- Call.float dn
      dn1Ptr <- Call.float dn1
      dn2Ptr <- Call.float dn2
      tauPtr <- Call.alloca
      ttypePtr <- Call.alloca
      gPtr <- Call.float g
      liftIO $ FFI.lasq4 i0Ptr n0Ptr zPtr ppPtr n0inPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dn1Ptr dn2Ptr tauPtr ttypePtr gPtr
      liftIO $ pure (,,)
         <*> peek tauPtr
         <*> fmap fromIntegral (peek ttypePtr)
         <*> peek gPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasq5.f>
lasq5 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   Array ZeroInt Float {- ^ z -} ->
   Int {- ^ pp -} ->
   Float {- ^ tau -} ->
   Float {- ^ sigma -} ->
   Bool {- ^ ieee -} ->
   Float {- ^ eps -} ->
   IO (Float, Float, Float, Float, Float, Float)
lasq5 i0 n0 z pp tau sigma ieee eps = do
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.ignore "lasq5: 4*n == zDim0" zDim0
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      tauPtr <- Call.float tau
      sigmaPtr <- Call.float sigma
      dminPtr <- Call.alloca
      dmin1Ptr <- Call.alloca
      dmin2Ptr <- Call.alloca
      dnPtr <- Call.alloca
      dnm1Ptr <- Call.alloca
      dnm2Ptr <- Call.alloca
      ieeePtr <- Call.bool ieee
      epsPtr <- Call.float eps
      liftIO $ FFI.lasq5 i0Ptr n0Ptr zPtr ppPtr tauPtr sigmaPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dnm1Ptr dnm2Ptr ieeePtr epsPtr
      liftIO $ pure (,,,,,)
         <*> peek dminPtr
         <*> peek dmin1Ptr
         <*> peek dmin2Ptr
         <*> peek dnPtr
         <*> peek dnm1Ptr
         <*> peek dnm2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasq6.f>
lasq6 ::
   Int {- ^ i0 -} ->
   Int {- ^ n0 -} ->
   Array ZeroInt Float {- ^ z -} ->
   Int {- ^ pp -} ->
   IO (Float, Float, Float, Float, Float, Float)
lasq6 i0 n0 z pp = do
   let zDim0 = Call.sizes1 $ Array.shape z
   Call.ignore "lasq6: 4*n == zDim0" zDim0
   evalContT $ do
      i0Ptr <- Call.cint i0
      n0Ptr <- Call.cint n0
      zPtr <- Call.array z
      ppPtr <- Call.cint pp
      dminPtr <- Call.alloca
      dmin1Ptr <- Call.alloca
      dmin2Ptr <- Call.alloca
      dnPtr <- Call.alloca
      dnm1Ptr <- Call.alloca
      dnm2Ptr <- Call.alloca
      liftIO $ FFI.lasq6 i0Ptr n0Ptr zPtr ppPtr dminPtr dmin1Ptr dmin2Ptr dnPtr dnm1Ptr dnm2Ptr
      liftIO $ pure (,,,,,)
         <*> peek dminPtr
         <*> peek dmin1Ptr
         <*> peek dmin2Ptr
         <*> peek dnPtr
         <*> peek dnm1Ptr
         <*> peek dnm2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasr.f>
lasr ::
   Char {- ^ side -} ->
   Char {- ^ pivot -} ->
   Char {- ^ direct -} ->
   Int {- ^ m -} ->
   Array ZeroInt Float {- ^ c -} ->
   Array ZeroInt Float {- ^ s -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO ()
lasr side pivot direct m c s a = do
   let cDim0 = Call.sizes1 $ Array.shape c
   let sDim0 = Call.sizes1 $ Array.shape s
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let _cSize = cDim0
   let _sSize = sDim0
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      sidePtr <- Call.char side
      pivotPtr <- Call.char pivot
      directPtr <- Call.char direct
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      cPtr <- Call.array c
      sPtr <- Call.array s
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      liftIO $ FFI.lasr sidePtr pivotPtr directPtr mPtr nPtr cPtr sPtr aPtr ldaPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasrt.f>
lasrt ::
   Char {- ^ id_ -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IO (Int)
lasrt id_ d = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let n = dDim0
   evalContT $ do
      id_Ptr <- Call.char id_
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      infoPtr <- Call.alloca
      liftIO $ FFI.lasrt id_Ptr nPtr dPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slassq.f>
lassq ::
   Array ZeroInt Float {- ^ x -} ->
   Int {- ^ incx -} ->
   Float {- ^ scale -} ->
   Float {- ^ sumsq -} ->
   IO (Float, Float)
lassq x incx scale sumsq = do
   let xDim0 = Call.sizes1 $ Array.shape x
   let n = xDim0
   evalContT $ do
      nPtr <- Call.cint n
      xPtr <- Call.array x
      incxPtr <- Call.cint incx
      scalePtr <- Call.float scale
      sumsqPtr <- Call.float sumsq
      liftIO $ FFI.lassq nPtr xPtr incxPtr scalePtr sumsqPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> peek sumsqPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasv2.f>
lasv2 ::
   Float {- ^ f -} ->
   Float {- ^ g -} ->
   Float {- ^ h -} ->
   IO (Float, Float, Float, Float, Float, Float)
lasv2 f g h = do
   evalContT $ do
      fPtr <- Call.float f
      gPtr <- Call.float g
      hPtr <- Call.float h
      ssminPtr <- Call.alloca
      ssmaxPtr <- Call.alloca
      snrPtr <- Call.alloca
      csrPtr <- Call.alloca
      snlPtr <- Call.alloca
      cslPtr <- Call.alloca
      liftIO $ FFI.lasv2 fPtr gPtr hPtr ssminPtr ssmaxPtr snrPtr csrPtr snlPtr cslPtr
      liftIO $ pure (,,,,,)
         <*> peek ssminPtr
         <*> peek ssmaxPtr
         <*> peek snrPtr
         <*> peek csrPtr
         <*> peek snlPtr
         <*> peek cslPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaswp.f>
laswp ::
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ k1 -} ->
   Int {- ^ k2 -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Int {- ^ incx -} ->
   IO ()
laswp a k1 k2 ipiv incx = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "laswp: k1+(k2-k1)*abs(incx) == ipivDim0" (k1+(k2-k1)*abs(incx) == ipivDim0)
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      k1Ptr <- Call.cint k1
      k2Ptr <- Call.cint k2
      ipivPtr <- Call.array ipiv
      incxPtr <- Call.cint incx
      liftIO $ FFI.laswp nPtr aPtr ldaPtr k1Ptr k2Ptr ipivPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasy2.f>
lasy2 ::
   Bool {- ^ ltranl -} ->
   Bool {- ^ ltranr -} ->
   Int {- ^ isgn -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ tl -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ tr -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Float, Array (ZeroInt,ZeroInt) Float, Float, Int)
lasy2 ltranl ltranr isgn n1 n2 tl tr b ldx = do
   let (tlDim0,tlDim1) = Call.sizes2 $ Array.shape tl
   let (trDim0,trDim1) = Call.sizes2 $ Array.shape tr
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let ldtl = tlDim1
   let ldtr = trDim1
   let ldb = bDim1
   Call.assert "lasy2: 2 == tlDim0" (2 == tlDim0)
   Call.assert "lasy2: 2 == trDim0" (2 == trDim0)
   Call.assert "lasy2: 2 == bDim0" (2 == bDim0)
   x <- Call.newArray2 2 ldx
   evalContT $ do
      ltranlPtr <- Call.bool ltranl
      ltranrPtr <- Call.bool ltranr
      isgnPtr <- Call.cint isgn
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      tlPtr <- Call.array tl
      ldtlPtr <- Call.cint ldtl
      trPtr <- Call.array tr
      ldtrPtr <- Call.cint ldtr
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      scalePtr <- Call.alloca
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      xnormPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.lasy2 ltranlPtr ltranrPtr isgnPtr n1Ptr n2Ptr tlPtr ldtlPtr trPtr ldtrPtr bPtr ldbPtr scalePtr xPtr ldxPtr xnormPtr infoPtr
      liftIO $ pure (,,,)
         <*> peek scalePtr
         <*> Call.freezeArray x
         <*> peek xnormPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasyf.f>
lasyf ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (Int, Array ZeroInt CInt, Array (ZeroInt,ZeroInt) Float, Int)
lasyf uplo nb a ldw = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      kbPtr <- Call.alloca
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      infoPtr <- Call.alloca
      liftIO $ FFI.lasyf uploPtr nPtr nbPtr kbPtr aPtr ldaPtr ipivPtr wPtr ldwPtr infoPtr
      liftIO $ pure (,,,)
         <*> fmap fromIntegral (peek kbPtr)
         <*> Call.freezeArray ipiv
         <*> Call.freezeArray w
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatbs.f>
latbs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   IOArray ZeroInt Float {- ^ cnorm -} ->
   IO (Float, Int)
latbs uplo trans diag normin kd ab x cnorm = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let cnormDim0 = Call.sizes1 $ MutArray.shape cnorm
   let n = abDim0
   let ldab = abDim1
   Call.assert "latbs: n == xDim0" (n == xDim0)
   Call.assert "latbs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latbs uploPtr transPtr diagPtr norminPtr nPtr kdPtr abPtr ldabPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatdf.f>
latdf ::
   Int {- ^ ijob -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ z -} ->
   IOArray ZeroInt Float {- ^ rhs -} ->
   Float {- ^ rdsum -} ->
   Float {- ^ rdscal -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array ZeroInt CInt {- ^ jpiv -} ->
   IO (Float, Float)
latdf ijob z rhs rdsum rdscal ipiv jpiv = do
   let (zDim0,zDim1) = Call.sizes2 $ Array.shape z
   let rhsDim0 = Call.sizes1 $ MutArray.shape rhs
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let jpivDim0 = Call.sizes1 $ Array.shape jpiv
   let n = zDim0
   let ldz = zDim1
   let _rhsSize = rhsDim0
   Call.assert "latdf: n == ipivDim0" (n == ipivDim0)
   Call.assert "latdf: n == jpivDim0" (n == jpivDim0)
   evalContT $ do
      ijobPtr <- Call.cint ijob
      nPtr <- Call.cint n
      zPtr <- Call.array z
      ldzPtr <- Call.cint ldz
      rhsPtr <- Call.ioarray rhs
      rdsumPtr <- Call.float rdsum
      rdscalPtr <- Call.float rdscal
      ipivPtr <- Call.array ipiv
      jpivPtr <- Call.array jpiv
      liftIO $ FFI.latdf ijobPtr nPtr zPtr ldzPtr rhsPtr rdsumPtr rdscalPtr ipivPtr jpivPtr
      liftIO $ pure (,)
         <*> peek rdsumPtr
         <*> peek rdscalPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatps.f>
latps ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   IOArray ZeroInt Float {- ^ cnorm -} ->
   IO (Float, Int)
latps uplo trans diag normin ap x cnorm = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let cnormDim0 = Call.sizes1 $ MutArray.shape cnorm
   let n = xDim0
   Call.assert "latps: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "latps: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latps uploPtr transPtr diagPtr norminPtr nPtr apPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatrd.f>
latrd ::
   Char {- ^ uplo -} ->
   Int {- ^ nb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ ldw -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float)
latrd uplo nb a ldw = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   w <- Call.newArray2 nb ldw
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nbPtr <- Call.cint nb
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      wPtr <- Call.ioarray w
      ldwPtr <- Call.cint ldw
      liftIO $ FFI.latrd uploPtr nPtr nbPtr aPtr ldaPtr ePtr tauPtr wPtr ldwPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> Call.freezeArray w

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatrs.f>
latrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Char {- ^ normin -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray ZeroInt Float {- ^ x -} ->
   IOArray ZeroInt Float {- ^ cnorm -} ->
   IO (Float, Int)
latrs uplo trans diag normin a x cnorm = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let xDim0 = Call.sizes1 $ MutArray.shape x
   let cnormDim0 = Call.sizes1 $ MutArray.shape cnorm
   let n = aDim0
   let lda = aDim1
   Call.assert "latrs: n == xDim0" (n == xDim0)
   Call.assert "latrs: n == cnormDim0" (n == cnormDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      norminPtr <- Call.char normin
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      xPtr <- Call.ioarray x
      scalePtr <- Call.alloca
      cnormPtr <- Call.ioarray cnorm
      infoPtr <- Call.alloca
      liftIO $ FFI.latrs uploPtr transPtr diagPtr norminPtr nPtr aPtr ldaPtr xPtr scalePtr cnormPtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatrz.f>
latrz ::
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float)
latrz m l a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      liftIO $ FFI.latrz mPtr nPtr lPtr aPtr ldaPtr tauPtr workPtr
      liftIO $ Call.freezeArray tau

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slauu2.f>
lauu2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
lauu2 uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauu2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slauum.f>
lauum ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
lauum uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.lauum uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorbdb.f>
orbdb ::
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x11 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x12 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x21 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x22 -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
orbdb trans signs m p x11 x12 x21 x22 lwork = do
   let (x11Dim0,x11Dim1) = Call.sizes2 $ MutArray.shape x11
   let (x12Dim0,x12Dim1) = Call.sizes2 $ MutArray.shape x12
   let (x21Dim0,x21Dim1) = Call.sizes2 $ MutArray.shape x21
   let (x22Dim0,x22Dim1) = Call.sizes2 $ MutArray.shape x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "orbdb: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "orbdb: q == x21Dim0" (q == x21Dim0)
   Call.assert "orbdb: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 q
   phi <- Call.newArray1 (q-1)
   taup1 <- Call.newArray1 p
   taup2 <- Call.newArray1 (m-p)
   tauq1 <- Call.newArray1 q
   tauq2 <- Call.newArray1 (m-q)
   work <- Call.newArray1 lwork
   evalContT $ do
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      phiPtr <- Call.ioarray phi
      taup1Ptr <- Call.ioarray taup1
      taup2Ptr <- Call.ioarray taup2
      tauq1Ptr <- Call.ioarray tauq1
      tauq2Ptr <- Call.ioarray tauq2
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orbdb transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr phiPtr taup1Ptr taup2Ptr tauq1Ptr tauq2Ptr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray phi
         <*> Call.freezeArray taup1
         <*> Call.freezeArray taup2
         <*> Call.freezeArray tauq1
         <*> Call.freezeArray tauq2
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorcsd.f>
orcsd ::
   Char {- ^ jobu1 -} ->
   Char {- ^ jobu2 -} ->
   Char {- ^ jobv1t -} ->
   Char {- ^ jobv2t -} ->
   Char {- ^ trans -} ->
   Char {- ^ signs -} ->
   Int {- ^ m -} ->
   Int {- ^ p -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x11 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x12 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x21 -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x22 -} ->
   Int {- ^ r -} ->
   Int {- ^ ldu1 -} ->
   Int {- ^ ldu2 -} ->
   Int {- ^ ldv1t -} ->
   Int {- ^ ldv2t -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Array (ZeroInt,ZeroInt) Float, Int)
orcsd jobu1 jobu2 jobv1t jobv2t trans signs m p x11 x12 x21 x22 r ldu1 ldu2 ldv1t ldv2t lwork = do
   let (x11Dim0,x11Dim1) = Call.sizes2 $ MutArray.shape x11
   let (x12Dim0,x12Dim1) = Call.sizes2 $ MutArray.shape x12
   let (x21Dim0,x21Dim1) = Call.sizes2 $ MutArray.shape x21
   let (x22Dim0,x22Dim1) = Call.sizes2 $ MutArray.shape x22
   let q = x11Dim0
   let ldx11 = x11Dim1
   let ldx12 = x12Dim1
   let ldx21 = x21Dim1
   let ldx22 = x22Dim1
   Call.assert "orcsd: m-q == x12Dim0" (m-q == x12Dim0)
   Call.assert "orcsd: q == x21Dim0" (q == x21Dim0)
   Call.assert "orcsd: m-q == x22Dim0" (m-q == x22Dim0)
   theta <- Call.newArray1 r
   u1 <- Call.newArray2 p ldu1
   u2 <- Call.newArray2 (m-p) ldu2
   v1t <- Call.newArray2 q ldv1t
   v2t <- Call.newArray2 (m-q) ldv2t
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (m-minimum[p,m-p,q,m-q])
   evalContT $ do
      jobu1Ptr <- Call.char jobu1
      jobu2Ptr <- Call.char jobu2
      jobv1tPtr <- Call.char jobv1t
      jobv2tPtr <- Call.char jobv2t
      transPtr <- Call.char trans
      signsPtr <- Call.char signs
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      qPtr <- Call.cint q
      x11Ptr <- Call.ioarray x11
      ldx11Ptr <- Call.cint ldx11
      x12Ptr <- Call.ioarray x12
      ldx12Ptr <- Call.cint ldx12
      x21Ptr <- Call.ioarray x21
      ldx21Ptr <- Call.cint ldx21
      x22Ptr <- Call.ioarray x22
      ldx22Ptr <- Call.cint ldx22
      thetaPtr <- Call.ioarray theta
      u1Ptr <- Call.ioarray u1
      ldu1Ptr <- Call.cint ldu1
      u2Ptr <- Call.ioarray u2
      ldu2Ptr <- Call.cint ldu2
      v1tPtr <- Call.ioarray v1t
      ldv1tPtr <- Call.cint ldv1t
      v2tPtr <- Call.ioarray v2t
      ldv2tPtr <- Call.cint ldv2t
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orcsd jobu1Ptr jobu2Ptr jobv1tPtr jobv2tPtr transPtr signsPtr mPtr pPtr qPtr x11Ptr ldx11Ptr x12Ptr ldx12Ptr x21Ptr ldx21Ptr x22Ptr ldx22Ptr thetaPtr u1Ptr ldu1Ptr u2Ptr ldu2Ptr v1tPtr ldv1tPtr v2tPtr ldv2tPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray theta
         <*> Call.freezeArray u1
         <*> Call.freezeArray u2
         <*> Call.freezeArray v1t
         <*> Call.freezeArray v2t
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbcon.f>
pbcon ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
pbcon uplo kd ab anorm = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbcon uploPtr nPtr kdPtr abPtr ldabPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbequ.f>
pbequ ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Array ZeroInt Float, Float, Float, Int)
pbequ uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.pbequ uploPtr nPtr kdPtr abPtr ldabPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbrfs.f>
pbrfs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ afb -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
pbrfs uplo kd ab afb b x = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let (afbDim0,afbDim1) = Call.sizes2 $ Array.shape afb
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pbrfs: n == afbDim0" (n == afbDim0)
   Call.assert "pbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.array afb
      ldafbPtr <- Call.cint ldafb
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbrfs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbstf.f>
pbstf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Int)
pbstf uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbstf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbsv.f>
pbsv ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
pbsv uplo kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsv uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbsvx.f>
pbsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ afb -} ->
   Char {- ^ equed -} ->
   IOArray ZeroInt Float {- ^ s -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
pbsvx fact uplo kd ab afb equed s b ldx = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let (afbDim0,afbDim1) = Call.sizes2 $ MutArray.shape afb
   let sDim0 = Call.sizes1 $ MutArray.shape s
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let ldafb = afbDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pbsvx: n == afbDim0" (n == afbDim0)
   Call.assert "pbsvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      afbPtr <- Call.ioarray afb
      ldafbPtr <- Call.cint ldafb
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pbsvx factPtr uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr afbPtr ldafbPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbtf2.f>
pbtf2 ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Int)
pbtf2 uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtf2 uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbtrf.f>
pbtrf ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Int)
pbtrf uplo kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ MutArray.shape ab
   let n = abDim0
   let ldab = abDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.ioarray ab
      ldabPtr <- Call.cint ldab
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrf uploPtr nPtr kdPtr abPtr ldabPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spbtrs.f>
pbtrs ::
   Char {- ^ uplo -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
pbtrs uplo kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pbtrs uploPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spftrf.f>
pftrf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ a -} ->
   IO (Int)
pftrf transr uplo n a = do
   let aDim0 = Call.sizes1 $ MutArray.shape a
   Call.assert "pftrf: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrf transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spftri.f>
pftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ a -} ->
   IO (Int)
pftri transr uplo n a = do
   let aDim0 = Call.sizes1 $ MutArray.shape a
   Call.assert "pftri: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.pftri transrPtr uploPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spftrs.f>
pftrs ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
pftrs transr uplo n a b = do
   let aDim0 = Call.sizes1 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pftrs: n*(n+1)`div`2 == aDim0" (n*(n+1)`div`2 == aDim0)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pftrs transrPtr uploPtr nPtr nrhsPtr aPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spocon.f>
pocon ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
pocon uplo a anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pocon uploPtr nPtr aPtr ldaPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spoequ.f>
poequ ::
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Float, Float, Int)
poequ a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequ nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spoequb.f>
poequb ::
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Float, Float, Int)
poequb a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.poequb nPtr aPtr ldaPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sporfs.f>
porfs ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ af -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
porfs uplo a af b x = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (afDim0,afDim1) = Call.sizes2 $ Array.shape af
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "porfs: n == afDim0" (n == afDim0)
   Call.assert "porfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.porfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sposv.f>
posv ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
posv uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.posv uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sposvx.f>
posvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ af -} ->
   Char {- ^ equed -} ->
   IOArray ZeroInt Float {- ^ s -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
posvx fact uplo a af equed s b ldx = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (afDim0,afDim1) = Call.sizes2 $ MutArray.shape af
   let sDim0 = Call.sizes1 $ MutArray.shape s
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "posvx: n == afDim0" (n == afDim0)
   Call.assert "posvx: n == sDim0" (n == sDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.posvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spotf2.f>
potf2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
potf2 uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potf2 uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spotrf.f>
potrf ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
potrf uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potrf uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spotri.f>
potri ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
potri uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.potri uploPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spotrs.f>
potrs ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
potrs uplo a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.potrs uploPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sppcon.f>
ppcon ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
ppcon uplo n ap anorm = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "ppcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppcon uploPtr nPtr apPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sppequ.f>
ppequ ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IO (Array ZeroInt Float, Float, Float, Int)
ppequ uplo n ap = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "ppequ: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   s <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.ppequ uploPtr nPtr apPtr sPtr scondPtr amaxPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spprfs.f>
pprfs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ afp -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
pprfs uplo n ap afp b x = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let afpDim0 = Call.sizes1 $ Array.shape afp
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "pprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "pprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "pprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.pprfs uploPtr nPtr nrhsPtr apPtr afpPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sppsv.f>
ppsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
ppsv uplo n ap b = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsv uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sppsvx.f>
ppsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ afp -} ->
   Char {- ^ equed -} ->
   IOArray ZeroInt Float {- ^ s -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Char, Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
ppsvx fact uplo ap afp equed s b ldx = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let afpDim0 = Call.sizes1 $ MutArray.shape afp
   let sDim0 = Call.sizes1 $ MutArray.shape s
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = sDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ppsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "ppsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      afpPtr <- Call.ioarray afp
      equedPtr <- Call.char equed
      sPtr <- Call.ioarray s
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ppsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr equedPtr sPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap castCCharToChar (peek equedPtr)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spptrf.f>
pptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO (Int)
pptrf uplo n ap = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "pptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrf uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spptri.f>
pptri ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO (Int)
pptri uplo n ap = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "pptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.pptri uploPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spptrs.f>
pptrs ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
pptrs uplo n ap b = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pptrs uploPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spstf2.f>
pstf2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ tol -} ->
   IO (Array ZeroInt CInt, Int, Int)
pstf2 uplo a tol = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.float tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstf2 uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spstrf.f>
pstrf ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Float {- ^ tol -} ->
   IO (Array ZeroInt CInt, Int, Int)
pstrf uplo a tol = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   piv <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      pivPtr <- Call.ioarray piv
      rankPtr <- Call.alloca
      tolPtr <- Call.float tol
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pstrf uploPtr nPtr aPtr ldaPtr pivPtr rankPtr tolPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray piv
         <*> fmap fromIntegral (peek rankPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sptcon.f>
ptcon ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
ptcon d e anorm = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let n = dDim0
   Call.assert "ptcon: n-1 == eDim0" (n-1 == eDim0)
   work <- Call.newArray1 n
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptcon nPtr dPtr ePtr anormPtr rcondPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spteqr.f>
pteqr ::
   Char {- ^ compz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   IO (Int)
pteqr compz d e z = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = dDim0
   let ldz = zDim1
   Call.assert "pteqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "pteqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (4*n)
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.pteqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sptrfs.f>
ptrfs ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Array ZeroInt Float {- ^ df -} ->
   Array ZeroInt Float {- ^ ef -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
ptrfs d e df ef b x = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let dfDim0 = Call.sizes1 $ Array.shape df
   let efDim0 = Call.sizes1 $ Array.shape ef
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "ptrfs: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptrfs: n == dfDim0" (n == dfDim0)
   Call.assert "ptrfs: n-1 == efDim0" (n-1 == efDim0)
   Call.assert "ptrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.array df
      efPtr <- Call.array ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptrfs nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sptsv.f>
ptsv ::
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
ptsv d e b = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsv: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsv nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sptsvx.f>
ptsvx ::
   Char {- ^ fact -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IOArray ZeroInt Float {- ^ df -} ->
   IOArray ZeroInt Float {- ^ ef -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
ptsvx fact d e df ef b ldx = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let dfDim0 = Call.sizes1 $ MutArray.shape df
   let efDim0 = Call.sizes1 $ MutArray.shape ef
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptsvx: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "ptsvx: n == dfDim0" (n == dfDim0)
   Call.assert "ptsvx: n-1 == efDim0" (n-1 == efDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (2*n)
   evalContT $ do
      factPtr <- Call.char fact
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      dfPtr <- Call.ioarray df
      efPtr <- Call.ioarray ef
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ptsvx factPtr nPtr nrhsPtr dPtr ePtr dfPtr efPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spttrf.f>
pttrf ::
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IO (Int)
pttrf d e = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "pttrf: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrf nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/spttrs.f>
pttrs ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
pttrs d e b = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "pttrs: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.pttrs nPtr nrhsPtr dPtr ePtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sptts2.f>
ptts2 ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
ptts2 d e b = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = dDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "ptts2: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      dPtr <- Call.array d
      ePtr <- Call.array e
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.ptts2 nPtr nrhsPtr dPtr ePtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/srscl.f>
rscl ::
   Int {- ^ n -} ->
   Float {- ^ sa -} ->
   IOArray ZeroInt Float {- ^ sx -} ->
   Int {- ^ incx -} ->
   IO ()
rscl n sa sx incx = do
   let sxDim0 = Call.sizes1 $ MutArray.shape sx
   let _sxSize = sxDim0
   evalContT $ do
      nPtr <- Call.cint n
      saPtr <- Call.float sa
      sxPtr <- Call.ioarray sx
      incxPtr <- Call.cint incx
      liftIO $ FFI.rscl nPtr saPtr sxPtr incxPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspcon.f>
spcon ::
   Char {- ^ uplo -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
spcon uplo ap ipiv anorm = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = ipivDim0
   Call.assert "spcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spcon uploPtr nPtr apPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssprfs.f>
sprfs ::
   Char {- ^ uplo -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ afp -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
sprfs uplo ap afp ipiv b x = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let afpDim0 = Call.sizes1 $ Array.shape afp
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "sprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "sprfs: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   Call.assert "sprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.array afp
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sprfs uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspsv.f>
spsv ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Array ZeroInt CInt, Int)
spsv uplo n ap b = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsv: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.spsv uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sspsvx.f>
spsvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray ZeroInt Float {- ^ afp -} ->
   IOArray ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
spsvx fact uplo ap afp ipiv b ldx = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let afpDim0 = Call.sizes1 $ MutArray.shape afp
   let ipivDim0 = Call.sizes1 $ MutArray.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "spsvx: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "spsvx: n*(n+1)`div`2 == afpDim0" (n*(n+1)`div`2 == afpDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      afpPtr <- Call.ioarray afp
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.spsvx factPtr uploPtr nPtr nrhsPtr apPtr afpPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssptrf.f>
sptrf ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO (Array ZeroInt CInt, Int)
sptrf uplo n ap = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "sptrf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrf uploPtr nPtr apPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssptri.f>
sptri ::
   Char {- ^ uplo -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IO (Int)
sptri uplo ap ipiv = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = ipivDim0
   Call.assert "sptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sptri uploPtr nPtr apPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssptrs.f>
sptrs ::
   Char {- ^ uplo -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
sptrs uplo ap ipiv b = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = ipivDim0
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sptrs uploPtr nPtr nrhsPtr apPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstebz.f>
stebz ::
   Char {- ^ range -} ->
   Char {- ^ order -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   IO (Int, Int, Array ZeroInt Float, Array ZeroInt CInt, Array ZeroInt CInt, Int)
stebz range order vl vu il iu abstol d e = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let n = dDim0
   Call.assert "stebz: n-1 == eDim0" (n-1 == eDim0)
   w <- Call.newArray1 n
   iblock <- Call.newArray1 n
   isplit <- Call.newArray1 n
   work <- Call.newArray1 (4*n)
   iwork <- Call.newArray1 (3*n)
   evalContT $ do
      rangePtr <- Call.char range
      orderPtr <- Call.char order
      nPtr <- Call.cint n
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      dPtr <- Call.array d
      ePtr <- Call.array e
      mPtr <- Call.alloca
      nsplitPtr <- Call.alloca
      wPtr <- Call.ioarray w
      iblockPtr <- Call.ioarray iblock
      isplitPtr <- Call.ioarray isplit
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stebz rangePtr orderPtr nPtr vlPtr vuPtr ilPtr iuPtr abstolPtr dPtr ePtr mPtr nsplitPtr wPtr iblockPtr isplitPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek nsplitPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray iblock
         <*> Call.freezeArray isplit
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstedc.f>
stedc ::
   Char {- ^ compz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int)
stedc compz d e z lwork liwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = dDim0
   let ldz = zDim1
   Call.assert "stedc: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stedc: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stedc compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstegr.f>
stegr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
stegr jobz range d e vl vu il iu abstol m ldz lwork liwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stegr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stegr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstein.f>
stein ::
   Array ZeroInt Float {- ^ d -} ->
   Array ZeroInt Float {- ^ e -} ->
   Int {- ^ m -} ->
   Array ZeroInt Float {- ^ w -} ->
   Array ZeroInt CInt {- ^ iblock -} ->
   Array ZeroInt CInt {- ^ isplit -} ->
   Int {- ^ ldz -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
stein d e m w iblock isplit ldz = do
   let dDim0 = Call.sizes1 $ Array.shape d
   let eDim0 = Call.sizes1 $ Array.shape e
   let wDim0 = Call.sizes1 $ Array.shape w
   let iblockDim0 = Call.sizes1 $ Array.shape iblock
   let isplitDim0 = Call.sizes1 $ Array.shape isplit
   let n = dDim0
   Call.assert "stein: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "stein: n == wDim0" (n == wDim0)
   Call.assert "stein: n == iblockDim0" (n == iblockDim0)
   Call.assert "stein: n == isplitDim0" (n == isplitDim0)
   z <- Call.newArray2 m ldz
   work <- Call.newArray1 (5*n)
   iwork <- Call.newArray1 n
   ifail <- Call.newArray1 m
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.array d
      ePtr <- Call.array e
      mPtr <- Call.cint m
      wPtr <- Call.array w
      iblockPtr <- Call.array iblock
      isplitPtr <- Call.array isplit
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.stein nPtr dPtr ePtr mPtr wPtr iblockPtr isplitPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstemr.f>
stemr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ nzc -} ->
   Bool {- ^ tryrac -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Bool, Int)
stemr jobz range d e vl vu il iu m ldz nzc tryrac lwork liwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stemr: n == eDim0" (n == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 lwork
   iwork <- Call.newArray1 liwork
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      nzcPtr <- Call.cint nzc
      isuppzPtr <- Call.ioarray isuppz
      tryracPtr <- Call.bool tryrac
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stemr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr mPtr wPtr zPtr ldzPtr nzcPtr isuppzPtr tryracPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> peek tryracPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssteqr.f>
steqr ::
   Char {- ^ compz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   IO (Int)
steqr compz d e z = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = dDim0
   let ldz = zDim1
   Call.assert "steqr: n-1 == eDim0" (n-1 == eDim0)
   Call.assert "steqr: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,2*n-2])
   evalContT $ do
      compzPtr <- Call.char compz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.steqr compzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssterf.f>
sterf ::
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   IO (Int)
sterf d e = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "sterf: n-1 == eDim0" (n-1 == eDim0)
   evalContT $ do
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.sterf nPtr dPtr ePtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstev.f>
stev ::
   Char {- ^ jobz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Int {- ^ ldz -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
stev jobz d e ldz = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stev: n-1 == eDim0" (n-1 == eDim0)
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 (maximum[1,2*n-2])
   evalContT $ do
      jobzPtr <- Call.char jobz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.stev jobzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstevd.f>
stevd ::
   Char {- ^ jobz -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Int {- ^ ldz -} ->
   Int {- ^ workSize -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
stevd jobz d e ldz workSize lwork liwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stevd: n-1 == eDim0" (n-1 == eDim0)
   z <- Call.newArray2 n ldz
   work <- Call.newArray1 workSize
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stevd jobzPtr nPtr dPtr ePtr zPtr ldzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray z
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstevr.f>
stevr ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
stevr jobz range d e vl vu il iu abstol m ldz lwork liwork = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stevr: maximum[1,n-1] == eDim0" (maximum[1,n-1] == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   isuppz <- Call.newArray1 (2*maximum[1,m])
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      isuppzPtr <- Call.ioarray isuppz
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.stevr jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr isuppzPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray isuppz
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstevx.f>
stevx ::
   Char {- ^ jobz -} ->
   Char {- ^ range -} ->
   IOArray ZeroInt Float {- ^ d -} ->
   IOArray ZeroInt Float {- ^ e -} ->
   Float {- ^ vl -} ->
   Float {- ^ vu -} ->
   Int {- ^ il -} ->
   Int {- ^ iu -} ->
   Float {- ^ abstol -} ->
   Int {- ^ m -} ->
   Int {- ^ ldz -} ->
   IO (Int, Array ZeroInt Float, Array (ZeroInt,ZeroInt) Float, Array ZeroInt CInt, Int)
stevx jobz range d e vl vu il iu abstol m ldz = do
   let dDim0 = Call.sizes1 $ MutArray.shape d
   let eDim0 = Call.sizes1 $ MutArray.shape e
   let n = dDim0
   Call.assert "stevx: maximum[1,n-1] == eDim0" (maximum[1,n-1] == eDim0)
   w <- Call.newArray1 n
   z <- Call.newArray2 (maximum[1,m]) ldz
   work <- Call.newArray1 (5*n)
   iwork <- Call.newArray1 (5*n)
   ifail <- Call.newArray1 n
   evalContT $ do
      jobzPtr <- Call.char jobz
      rangePtr <- Call.char range
      nPtr <- Call.cint n
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      vlPtr <- Call.float vl
      vuPtr <- Call.float vu
      ilPtr <- Call.cint il
      iuPtr <- Call.cint iu
      abstolPtr <- Call.float abstol
      mPtr <- Call.alloca
      wPtr <- Call.ioarray w
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      ifailPtr <- Call.ioarray ifail
      infoPtr <- Call.alloca
      liftIO $ FFI.stevx jobzPtr rangePtr nPtr dPtr ePtr vlPtr vuPtr ilPtr iuPtr abstolPtr mPtr wPtr zPtr ldzPtr workPtr iworkPtr ifailPtr infoPtr
      liftIO $ pure (,,,,)
         <*> fmap fromIntegral (peek mPtr)
         <*> Call.freezeArray w
         <*> Call.freezeArray z
         <*> Call.freezeArray ifail
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssycon.f>
sycon ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Float {- ^ anorm -} ->
   IO (Float, Int)
sycon uplo a ipiv anorm = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sycon: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (2*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      anormPtr <- Call.float anorm
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sycon uploPtr nPtr aPtr ldaPtr ipivPtr anormPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyconv.f>
syconv ::
   Char {- ^ uplo -} ->
   Char {- ^ way -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IO (Array ZeroInt Float, Int)
syconv uplo way a ipiv = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "syconv: n == ipivDim0" (n == ipivDim0)
   e <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      wayPtr <- Call.char way
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      ePtr <- Call.ioarray e
      infoPtr <- Call.alloca
      liftIO $ FFI.syconv uploPtr wayPtr nPtr aPtr ldaPtr ipivPtr ePtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray e
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyequb.f>
syequb ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Float, Float, Int)
syequb uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   s <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      sPtr <- Call.ioarray s
      scondPtr <- Call.alloca
      amaxPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.syequb uploPtr nPtr aPtr ldaPtr sPtr scondPtr amaxPtr workPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> peek scondPtr
         <*> peek amaxPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyrfs.f>
syrfs ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ af -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
syrfs uplo a af ipiv b x = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (afDim0,afDim1) = Call.sizes2 $ Array.shape af
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ MutArray.shape x
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "syrfs: n == afDim0" (n == afDim0)
   Call.assert "syrfs: n == ipivDim0" (n == ipivDim0)
   Call.assert "syrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.array af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.array ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.syrfs uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssysv.f>
sysv ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt CInt, Int)
sysv uplo a b lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysv uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssysvx.f>
sysvx ::
   Char {- ^ fact -} ->
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ af -} ->
   IOArray ZeroInt CInt {- ^ ipiv -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Int {- ^ ldx -} ->
   Int {- ^ lwork -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Float, Array ZeroInt Float, Array ZeroInt Float, Int)
sysvx fact uplo a af ipiv b ldx lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (afDim0,afDim1) = Call.sizes2 $ MutArray.shape af
   let ipivDim0 = Call.sizes1 $ MutArray.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let n = aDim0
   let lda = aDim1
   let ldaf = afDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sysvx: n == afDim0" (n == afDim0)
   Call.assert "sysvx: n == ipivDim0" (n == ipivDim0)
   x <- Call.newArray2 nrhs ldx
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 n
   evalContT $ do
      factPtr <- Call.char fact
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      afPtr <- Call.ioarray af
      ldafPtr <- Call.cint ldaf
      ipivPtr <- Call.ioarray ipiv
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.ioarray x
      ldxPtr <- Call.cint ldx
      rcondPtr <- Call.alloca
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sysvx factPtr uploPtr nPtr nrhsPtr aPtr ldaPtr afPtr ldafPtr ipivPtr bPtr ldbPtr xPtr ldxPtr rcondPtr ferrPtr berrPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,,)
         <*> Call.freezeArray x
         <*> peek rcondPtr
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyswapr.f>
syswapr ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ i1 -} ->
   Int {- ^ i2 -} ->
   IO ()
syswapr uplo a i1 i2 = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      i1Ptr <- Call.cint i1
      i2Ptr <- Call.cint i2
      liftIO $ FFI.syswapr uploPtr nPtr aPtr ldaPtr i1Ptr i2Ptr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytd2.f>
sytd2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
sytd2 uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      infoPtr <- Call.alloca
      liftIO $ FFI.sytd2 uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytf2.f>
sytf2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt CInt, Int)
sytf2 uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      infoPtr <- Call.alloca
      liftIO $ FFI.sytf2 uploPtr nPtr aPtr ldaPtr ipivPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrd.f>
sytrd ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int)
sytrd uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   d <- Call.newArray1 n
   e <- Call.newArray1 (n-1)
   tau <- Call.newArray1 (n-1)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      dPtr <- Call.ioarray d
      ePtr <- Call.ioarray e
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrd uploPtr nPtr aPtr ldaPtr dPtr ePtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray d
         <*> Call.freezeArray e
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrf.f>
sytrf ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt CInt, Int)
sytrf uplo a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   ipiv <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.ioarray ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrf uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ipiv
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytri.f>
sytri ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IO (Int)
sytri uplo a ipiv = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri uploPtr nPtr aPtr ldaPtr ipivPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytri2.f>
sytri2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   Int {- ^ lwork -} ->
   IO (Int)
sytri2 uplo a ipiv nb lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2 uploPtr nPtr aPtr ldaPtr ipivPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytri2x.f>
sytri2x ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   Int {- ^ nb -} ->
   IO (Int)
sytri2x uplo a ipiv nb = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let n = aDim0
   let lda = aDim1
   Call.assert "sytri2x: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray2 (nb+3) (n+nb+1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      workPtr <- Call.ioarray work
      nbPtr <- Call.cint nb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytri2x uploPtr nPtr aPtr ldaPtr ipivPtr workPtr nbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrs.f>
sytrs ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
sytrs uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs: n == ipivDim0" (n == ipivDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrs2.f>
sytrs2 ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt CInt {- ^ ipiv -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
sytrs2 uplo a ipiv b = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let ipivDim0 = Call.sizes1 $ Array.shape ipiv
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "sytrs2: n == ipivDim0" (n == ipivDim0)
   work <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      ipivPtr <- Call.array ipiv
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.sytrs2 uploPtr nPtr nrhsPtr aPtr ldaPtr ipivPtr bPtr ldbPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stbcon.f>
tbcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IO (Float, Int)
tbcon norm uplo diag kd ab = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let n = abDim0
   let ldab = abDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbcon normPtr uploPtr diagPtr nPtr kdPtr abPtr ldabPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stbrfs.f>
tbrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
tbrfs uplo trans diag kd ab b x = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ Array.shape x
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tbrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tbrfs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stbtrs.f>
tbtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ kd -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ ab -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
tbtrs uplo trans diag kd ab b = do
   let (abDim0,abDim1) = Call.sizes2 $ Array.shape ab
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = abDim0
   let ldab = abDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      kdPtr <- Call.cint kd
      nrhsPtr <- Call.cint nrhs
      abPtr <- Call.array ab
      ldabPtr <- Call.cint ldab
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tbtrs uploPtr transPtr diagPtr nPtr kdPtr nrhsPtr abPtr ldabPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stfsm.f>
tfsm ::
   Char {- ^ transr -} ->
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ m -} ->
   Float {- ^ alpha -} ->
   Array ZeroInt Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO ()
tfsm transr side uplo trans diag m alpha a b = do
   let aDim0 = Call.sizes1 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let _nt = aDim0
   let n = bDim0
   let ldb = bDim1
   evalContT $ do
      transrPtr <- Call.char transr
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      alphaPtr <- Call.float alpha
      aPtr <- Call.array a
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      liftIO $ FFI.tfsm transrPtr sidePtr uploPtr transPtr diagPtr mPtr nPtr alphaPtr aPtr bPtr ldbPtr

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stftri.f>
tftri ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ a -} ->
   IO (Int)
tftri transr uplo diag n a = do
   let aDim0 = Call.sizes1 $ MutArray.shape a
   let _nt = aDim0
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      infoPtr <- Call.alloca
      liftIO $ FFI.tftri transrPtr uploPtr diagPtr nPtr aPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stfttp.f>
tfttp ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ arf -} ->
   IO (Array ZeroInt Float, Int)
tfttp transr uplo n arf = do
   let arfDim0 = Call.sizes1 $ Array.shape arf
   Call.assert "tfttp: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttp transrPtr uploPtr nPtr arfPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stfttr.f>
tfttr ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ arf -} ->
   Int {- ^ lda -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
tfttr transr uplo n arf lda = do
   let arfDim0 = Call.sizes1 $ Array.shape arf
   Call.assert "tfttr: n*(n+1)`div`2 == arfDim0" (n*(n+1)`div`2 == arfDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      arfPtr <- Call.array arf
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tfttr transrPtr uploPtr nPtr arfPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgevc.f>
tgevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   Array ZeroInt Bool {- ^ select -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ s -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ p -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vl -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vr -} ->
   IO (Int, Int)
tgevc side howmny select s p vl vr = do
   let selectDim0 = Call.sizes1 $ Array.shape select
   let (sDim0,sDim1) = Call.sizes2 $ Array.shape s
   let (pDim0,pDim1) = Call.sizes2 $ Array.shape p
   let (vlDim0,vlDim1) = Call.sizes2 $ MutArray.shape vl
   let (vrDim0,vrDim1) = Call.sizes2 $ MutArray.shape vr
   let n = selectDim0
   let lds = sDim1
   let ldp = pDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgevc: n == sDim0" (n == sDim0)
   Call.assert "tgevc: n == pDim0" (n == pDim0)
   Call.assert "tgevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (6*n)
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      sPtr <- Call.array s
      ldsPtr <- Call.cint lds
      pPtr <- Call.array p
      ldpPtr <- Call.cint ldp
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.tgevc sidePtr howmnyPtr selectPtr nPtr sPtr ldsPtr pPtr ldpPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgex2.f>
tgex2 ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ j1 -} ->
   Int {- ^ n1 -} ->
   Int {- ^ n2 -} ->
   Int {- ^ lwork -} ->
   IO (Int)
tgex2 wantq wantz a b q z j1 n1 n2 lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgex2: n == bDim0" (n == bDim0)
   Call.assert "tgex2: n == qDim0" (n == qDim0)
   Call.assert "tgex2: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      j1Ptr <- Call.cint j1
      n1Ptr <- Call.cint n1
      n2Ptr <- Call.cint n2
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgex2 wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr j1Ptr n1Ptr n2Ptr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgexc.f>
tgexc ::
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   Int {- ^ lwork -} ->
   IO (Int, Int, Int)
tgexc wantq wantz a b q z ifst ilst lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgexc: n == bDim0" (n == bDim0)
   Call.assert "tgexc: n == qDim0" (n == qDim0)
   Call.assert "tgexc: n == zDim0" (n == zDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgexc wantqPtr wantzPtr nPtr aPtr ldaPtr bPtr ldbPtr qPtr ldqPtr zPtr ldzPtr ifstPtr ilstPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek ifstPtr)
         <*> fmap fromIntegral (peek ilstPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgsen.f>
tgsen ::
   Int {- ^ ijob -} ->
   Bool {- ^ wantq -} ->
   Bool {- ^ wantz -} ->
   Array ZeroInt Bool {- ^ select -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ z -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Array ZeroInt Float, Int, Float, Float, Array ZeroInt Float, Int)
tgsen ijob wantq wantz select a b q z lwork liwork = do
   let selectDim0 = Call.sizes1 $ Array.shape select
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let (zDim0,zDim1) = Call.sizes2 $ MutArray.shape z
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let ldq = qDim1
   let ldz = zDim1
   Call.assert "tgsen: n == aDim0" (n == aDim0)
   Call.assert "tgsen: n == bDim0" (n == bDim0)
   Call.assert "tgsen: n == qDim0" (n == qDim0)
   Call.assert "tgsen: n == zDim0" (n == zDim0)
   alphar <- Call.newArray1 n
   alphai <- Call.newArray1 n
   beta <- Call.newArray1 n
   dif <- Call.newArray1 2
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      ijobPtr <- Call.cint ijob
      wantqPtr <- Call.bool wantq
      wantzPtr <- Call.bool wantz
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      alpharPtr <- Call.ioarray alphar
      alphaiPtr <- Call.ioarray alphai
      betaPtr <- Call.ioarray beta
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      zPtr <- Call.ioarray z
      ldzPtr <- Call.cint ldz
      mPtr <- Call.alloca
      plPtr <- Call.alloca
      prPtr <- Call.alloca
      difPtr <- Call.ioarray dif
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsen ijobPtr wantqPtr wantzPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr alpharPtr alphaiPtr betaPtr qPtr ldqPtr zPtr ldzPtr mPtr plPtr prPtr difPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,,,)
         <*> Call.freezeArray alphar
         <*> Call.freezeArray alphai
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek mPtr)
         <*> peek plPtr
         <*> peek prPtr
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgsja.f>
tgsja ::
   Char {- ^ jobu -} ->
   Char {- ^ jobv -} ->
   Char {- ^ jobq -} ->
   Int {- ^ k -} ->
   Int {- ^ l -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Float {- ^ tola -} ->
   Float {- ^ tolb -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ u -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ v -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int, Int)
tgsja jobu jobv jobq k l a b tola tolb u v q = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let (uDim0,uDim1) = Call.sizes2 $ MutArray.shape u
   let (vDim0,vDim1) = Call.sizes2 $ MutArray.shape v
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = aDim0
   let lda = aDim1
   let ldb = bDim1
   let m = uDim0
   let ldu = uDim1
   let p = vDim0
   let ldv = vDim1
   let ldq = qDim1
   Call.assert "tgsja: n == bDim0" (n == bDim0)
   Call.assert "tgsja: n == qDim0" (n == qDim0)
   alpha <- Call.newArray1 n
   beta <- Call.newArray1 n
   work <- Call.newArray1 (2*n)
   evalContT $ do
      jobuPtr <- Call.char jobu
      jobvPtr <- Call.char jobv
      jobqPtr <- Call.char jobq
      mPtr <- Call.cint m
      pPtr <- Call.cint p
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      tolaPtr <- Call.float tola
      tolbPtr <- Call.float tolb
      alphaPtr <- Call.ioarray alpha
      betaPtr <- Call.ioarray beta
      uPtr <- Call.ioarray u
      lduPtr <- Call.cint ldu
      vPtr <- Call.ioarray v
      ldvPtr <- Call.cint ldv
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      ncyclePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsja jobuPtr jobvPtr jobqPtr mPtr pPtr nPtr kPtr lPtr aPtr ldaPtr bPtr ldbPtr tolaPtr tolbPtr alphaPtr betaPtr uPtr lduPtr vPtr ldvPtr qPtr ldqPtr workPtr ncyclePtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray alpha
         <*> Call.freezeArray beta
         <*> fmap fromIntegral (peek ncyclePtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgsna.f>
tgsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   Array ZeroInt Bool {- ^ select -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ vl -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int, Int)
tgsna job howmny select a b vl vr mm lwork = do
   let selectDim0 = Call.sizes1 $ Array.shape select
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (vlDim0,vlDim1) = Call.sizes2 $ Array.shape vl
   let (vrDim0,vrDim1) = Call.sizes2 $ Array.shape vr
   let n = selectDim0
   let lda = aDim1
   let ldb = bDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "tgsna: n == aDim0" (n == aDim0)
   Call.assert "tgsna: n == bDim0" (n == bDim0)
   Call.assert "tgsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   dif <- Call.newArray1 mm
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (n+6)
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      difPtr <- Call.ioarray dif
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsna jobPtr howmnyPtr selectPtr nPtr aPtr ldaPtr bPtr ldbPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr difPtr mmPtr mPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray dif
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgsy2.f>
tgsy2 ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ d -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ f -} ->
   Float {- ^ rdsum -} ->
   Float {- ^ rdscal -} ->
   IO (Float, Float, Float, Int, Int)
tgsy2 trans ijob a b c d e f rdsum rdscal = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let (dDim0,dDim1) = Call.sizes2 $ Array.shape d
   let (eDim0,eDim1) = Call.sizes2 $ Array.shape e
   let (fDim0,fDim1) = Call.sizes2 $ MutArray.shape f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsy2: n == cDim0" (n == cDim0)
   Call.assert "tgsy2: m == dDim0" (m == dDim0)
   Call.assert "tgsy2: n == eDim0" (n == eDim0)
   Call.assert "tgsy2: n == fDim0" (n == fDim0)
   iwork <- Call.newArray1 (m+n+2)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      rdsumPtr <- Call.float rdsum
      rdscalPtr <- Call.float rdscal
      iworkPtr <- Call.ioarray iwork
      pqPtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsy2 transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr rdsumPtr rdscalPtr iworkPtr pqPtr infoPtr
      liftIO $ pure (,,,,)
         <*> peek scalePtr
         <*> peek rdsumPtr
         <*> peek rdscalPtr
         <*> fmap fromIntegral (peek pqPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stgsyl.f>
tgsyl ::
   Char {- ^ trans -} ->
   Int {- ^ ijob -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ d -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ e -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ f -} ->
   Int {- ^ lwork -} ->
   IO (Float, Float, Int)
tgsyl trans ijob a b c d e f lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let (dDim0,dDim1) = Call.sizes2 $ Array.shape d
   let (eDim0,eDim1) = Call.sizes2 $ Array.shape e
   let (fDim0,fDim1) = Call.sizes2 $ MutArray.shape f
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   let ldd = dDim1
   let lde = eDim1
   let ldf = fDim1
   Call.assert "tgsyl: n == cDim0" (n == cDim0)
   Call.assert "tgsyl: m == dDim0" (m == dDim0)
   Call.assert "tgsyl: n == eDim0" (n == eDim0)
   Call.assert "tgsyl: n == fDim0" (n == fDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (m+n+6)
   evalContT $ do
      transPtr <- Call.char trans
      ijobPtr <- Call.cint ijob
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      dPtr <- Call.array d
      lddPtr <- Call.cint ldd
      ePtr <- Call.array e
      ldePtr <- Call.cint lde
      fPtr <- Call.ioarray f
      ldfPtr <- Call.cint ldf
      scalePtr <- Call.alloca
      difPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tgsyl transPtr ijobPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr dPtr lddPtr ePtr ldePtr fPtr ldfPtr scalePtr difPtr workPtr lworkPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> peek scalePtr
         <*> peek difPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stpcon.f>
tpcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IO (Float, Int)
tpcon norm uplo diag n ap = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "tpcon: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tpcon normPtr uploPtr diagPtr nPtr apPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stprfs.f>
tprfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
tprfs uplo trans diag n ap b x = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ Array.shape x
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "tprfs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "tprfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tprfs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stptri.f>
tptri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   IOArray ZeroInt Float {- ^ ap -} ->
   IO (Int)
tptri uplo diag n ap = do
   let apDim0 = Call.sizes1 $ MutArray.shape ap
   Call.assert "tptri: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.tptri uploPtr diagPtr nPtr apPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stptrs.f>
tptrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
tptrs uplo trans diag n ap b = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let nrhs = bDim0
   let ldb = bDim1
   Call.assert "tptrs: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      apPtr <- Call.array ap
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.tptrs uploPtr transPtr diagPtr nPtr nrhsPtr apPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stpttf.f>
tpttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   IO (Array ZeroInt Float, Int)
tpttf transr uplo n ap = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "tpttf: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   arf <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttf transrPtr uploPtr nPtr apPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stpttr.f>
tpttr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Int {- ^ lda -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
tpttr uplo n ap lda = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   Call.assert "tpttr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   a <- Call.newArray2 n lda
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.tpttr uploPtr nPtr apPtr aPtr ldaPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray a
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strcon.f>
trcon ::
   Char {- ^ norm -} ->
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Float, Int)
trcon norm uplo diag a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      normPtr <- Call.char norm
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      rcondPtr <- Call.alloca
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trcon normPtr uploPtr diagPtr nPtr aPtr ldaPtr rcondPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,)
         <*> peek rcondPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strevc.f>
trevc ::
   Char {- ^ side -} ->
   Char {- ^ howmny -} ->
   IOArray ZeroInt Bool {- ^ select -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vl -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ vr -} ->
   IO (Int, Int)
trevc side howmny select t vl vr = do
   let selectDim0 = Call.sizes1 $ MutArray.shape select
   let (tDim0,tDim1) = Call.sizes2 $ Array.shape t
   let (vlDim0,vlDim1) = Call.sizes2 $ MutArray.shape vl
   let (vrDim0,vrDim1) = Call.sizes2 $ MutArray.shape vr
   let n = selectDim0
   let ldt = tDim1
   let mm = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trevc: n == tDim0" (n == tDim0)
   Call.assert "trevc: mm == vrDim0" (mm == vrDim0)
   work <- Call.newArray1 (3*n)
   evalContT $ do
      sidePtr <- Call.char side
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.ioarray select
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.ioarray vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.ioarray vr
      ldvrPtr <- Call.cint ldvr
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.trevc sidePtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr mmPtr mPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strexc.f>
trexc ::
   Char {- ^ compq -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Int {- ^ ifst -} ->
   Int {- ^ ilst -} ->
   IO (Int, Int, Int)
trexc compq t q ifst ilst = do
   let (tDim0,tDim1) = Call.sizes2 $ MutArray.shape t
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = tDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trexc: n == qDim0" (n == qDim0)
   work <- Call.newArray1 n
   evalContT $ do
      compqPtr <- Call.char compq
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      ifstPtr <- Call.cint ifst
      ilstPtr <- Call.cint ilst
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.trexc compqPtr nPtr tPtr ldtPtr qPtr ldqPtr ifstPtr ilstPtr workPtr infoPtr
      liftIO $ pure (,,)
         <*> fmap fromIntegral (peek ifstPtr)
         <*> fmap fromIntegral (peek ilstPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strrfs.f>
trrfs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ x -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int)
trrfs uplo trans diag a b x = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (xDim0,xDim1) = Call.sizes2 $ Array.shape x
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   let ldx = xDim1
   Call.assert "trrfs: nrhs == xDim0" (nrhs == xDim0)
   ferr <- Call.newArray1 nrhs
   berr <- Call.newArray1 nrhs
   work <- Call.newArray1 (3*n)
   iwork <- Call.newArray1 n
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      xPtr <- Call.array x
      ldxPtr <- Call.cint ldx
      ferrPtr <- Call.ioarray ferr
      berrPtr <- Call.ioarray berr
      workPtr <- Call.ioarray work
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trrfs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr xPtr ldxPtr ferrPtr berrPtr workPtr iworkPtr infoPtr
      liftIO $ pure (,,)
         <*> Call.freezeArray ferr
         <*> Call.freezeArray berr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strsen.f>
trsen ::
   Char {- ^ job -} ->
   Char {- ^ compq -} ->
   Array ZeroInt Bool {- ^ select -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ t -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ q -} ->
   Int {- ^ lwork -} ->
   Int {- ^ liwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int, Float, Float, Int)
trsen job compq select t q lwork liwork = do
   let selectDim0 = Call.sizes1 $ Array.shape select
   let (tDim0,tDim1) = Call.sizes2 $ MutArray.shape t
   let (qDim0,qDim1) = Call.sizes2 $ MutArray.shape q
   let n = selectDim0
   let ldt = tDim1
   let ldq = qDim1
   Call.assert "trsen: n == tDim0" (n == tDim0)
   Call.assert "trsen: n == qDim0" (n == qDim0)
   wr <- Call.newArray1 n
   wi <- Call.newArray1 n
   work <- Call.newArray1 (maximum[1,lwork])
   iwork <- Call.newArray1 (maximum[1,liwork])
   evalContT $ do
      jobPtr <- Call.char job
      compqPtr <- Call.char compq
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.ioarray t
      ldtPtr <- Call.cint ldt
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      wrPtr <- Call.ioarray wr
      wiPtr <- Call.ioarray wi
      mPtr <- Call.alloca
      sPtr <- Call.alloca
      sepPtr <- Call.alloca
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      iworkPtr <- Call.ioarray iwork
      liworkPtr <- Call.cint liwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsen jobPtr compqPtr selectPtr nPtr tPtr ldtPtr qPtr ldqPtr wrPtr wiPtr mPtr sPtr sepPtr workPtr lworkPtr iworkPtr liworkPtr infoPtr
      liftIO $ pure (,,,,,)
         <*> Call.freezeArray wr
         <*> Call.freezeArray wi
         <*> fmap fromIntegral (peek mPtr)
         <*> peek sPtr
         <*> peek sepPtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strsna.f>
trsna ::
   Char {- ^ job -} ->
   Char {- ^ howmny -} ->
   Array ZeroInt Bool {- ^ select -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ t -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ vl -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ vr -} ->
   Int {- ^ mm -} ->
   Int {- ^ ldwork -} ->
   IO (Array ZeroInt Float, Array ZeroInt Float, Int, Int)
trsna job howmny select t vl vr mm ldwork = do
   let selectDim0 = Call.sizes1 $ Array.shape select
   let (tDim0,tDim1) = Call.sizes2 $ Array.shape t
   let (vlDim0,vlDim1) = Call.sizes2 $ Array.shape vl
   let (vrDim0,vrDim1) = Call.sizes2 $ Array.shape vr
   let n = selectDim0
   let ldt = tDim1
   let m = vlDim0
   let ldvl = vlDim1
   let ldvr = vrDim1
   Call.assert "trsna: n == tDim0" (n == tDim0)
   Call.assert "trsna: m == vrDim0" (m == vrDim0)
   s <- Call.newArray1 mm
   sep <- Call.newArray1 mm
   work <- Call.newArray2 (n+6) ldwork
   iwork <- Call.newArray1 (2*(n-1))
   evalContT $ do
      jobPtr <- Call.char job
      howmnyPtr <- Call.char howmny
      selectPtr <- Call.array select
      nPtr <- Call.cint n
      tPtr <- Call.array t
      ldtPtr <- Call.cint ldt
      vlPtr <- Call.array vl
      ldvlPtr <- Call.cint ldvl
      vrPtr <- Call.array vr
      ldvrPtr <- Call.cint ldvr
      sPtr <- Call.ioarray s
      sepPtr <- Call.ioarray sep
      mmPtr <- Call.cint mm
      mPtr <- Call.alloca
      workPtr <- Call.ioarray work
      ldworkPtr <- Call.cint ldwork
      iworkPtr <- Call.ioarray iwork
      infoPtr <- Call.alloca
      liftIO $ FFI.trsna jobPtr howmnyPtr selectPtr nPtr tPtr ldtPtr vlPtr ldvlPtr vrPtr ldvrPtr sPtr sepPtr mmPtr mPtr workPtr ldworkPtr iworkPtr infoPtr
      liftIO $ pure (,,,)
         <*> Call.freezeArray s
         <*> Call.freezeArray sep
         <*> fmap fromIntegral (peek mPtr)
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strsyl.f>
trsyl ::
   Char {- ^ trana -} ->
   Char {- ^ tranb -} ->
   Int {- ^ isgn -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   IO (Float, Int)
trsyl trana tranb isgn a b c = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ Array.shape b
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let m = aDim0
   let lda = aDim1
   let n = bDim0
   let ldb = bDim1
   let ldc = cDim1
   Call.assert "trsyl: n == cDim0" (n == cDim0)
   evalContT $ do
      tranaPtr <- Call.char trana
      tranbPtr <- Call.char tranb
      isgnPtr <- Call.cint isgn
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.array b
      ldbPtr <- Call.cint ldb
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      scalePtr <- Call.alloca
      infoPtr <- Call.alloca
      liftIO $ FFI.trsyl tranaPtr tranbPtr isgnPtr mPtr nPtr aPtr ldaPtr bPtr ldbPtr cPtr ldcPtr scalePtr infoPtr
      liftIO $ pure (,)
         <*> peek scalePtr
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strti2.f>
trti2 ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
trti2 uplo diag a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trti2 uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strtri.f>
trtri ::
   Char {- ^ uplo -} ->
   Char {- ^ diag -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Int)
trtri uplo diag a = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      infoPtr <- Call.alloca
      liftIO $ FFI.trtri uploPtr diagPtr nPtr aPtr ldaPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strtrs.f>
trtrs ::
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Char {- ^ diag -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ b -} ->
   IO (Int)
trtrs uplo trans diag a b = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let (bDim0,bDim1) = Call.sizes2 $ MutArray.shape b
   let n = aDim0
   let lda = aDim1
   let nrhs = bDim0
   let ldb = bDim1
   evalContT $ do
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      diagPtr <- Call.char diag
      nPtr <- Call.cint n
      nrhsPtr <- Call.cint nrhs
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      bPtr <- Call.ioarray b
      ldbPtr <- Call.cint ldb
      infoPtr <- Call.alloca
      liftIO $ FFI.trtrs uploPtr transPtr diagPtr nPtr nrhsPtr aPtr ldaPtr bPtr ldbPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strttf.f>
trttf ::
   Char {- ^ transr -} ->
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ nt -} ->
   IO (Array ZeroInt Float, Int)
trttf transr uplo a nt = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   arf <- Call.newArray1 nt
   evalContT $ do
      transrPtr <- Call.char transr
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      arfPtr <- Call.ioarray arf
      infoPtr <- Call.alloca
      liftIO $ FFI.trttf transrPtr uploPtr nPtr aPtr ldaPtr arfPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray arf
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/strttp.f>
trttp ::
   Char {- ^ uplo -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   IO (Array ZeroInt Float, Int)
trttp uplo a = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let n = aDim0
   let lda = aDim1
   ap <- Call.newArray1 (n*(n+1)`div`2)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      apPtr <- Call.ioarray ap
      infoPtr <- Call.alloca
      liftIO $ FFI.trttp uploPtr nPtr aPtr ldaPtr apPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray ap
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/stzrzf.f>
tzrzf ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Int {- ^ lwork -} ->
   IO (Array ZeroInt Float, Int)
tzrzf m a lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let n = aDim0
   let lda = aDim1
   tau <- Call.newArray1 m
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.ioarray tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.tzrzf mPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray tau
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorg2l.f>
org2l ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IO (Int)
org2l m a tau = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.org2l mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorg2r.f>
org2r ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IO (Int)
org2r m a tau = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 n
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.org2r mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgbr.f>
orgbr ::
   Char {- ^ vect -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgbr vect m k a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgbr vectPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorghr.f>
orghr ::
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orghr ilo ihi a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   Call.assert "orghr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orghr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgl2.f>
orgl2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IO (Int)
orgl2 m a tau = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orgl2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorglq.f>
orglq ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orglq m a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orglq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgql.f>
orgql ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgql m a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgql mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgqr.f>
orgqr ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgqr m a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgqr mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgr2.f>
orgr2 ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IO (Int)
orgr2 m a tau = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 m
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orgr2 mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgrq.f>
orgrq ::
   Int {- ^ m -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgrq m a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   let k = tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgrq mPtr nPtr kPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgtr.f>
orgtr ::
   Char {- ^ uplo -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ lwork -} ->
   IO (Int)
orgtr uplo a tau lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ MutArray.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let n = aDim0
   let lda = aDim1
   Call.assert "orgtr: n-1 == tauDim0" (n-1 == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      aPtr <- Call.ioarray a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.orgtr uploPtr nPtr aPtr ldaPtr tauPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorm2l.f>
orm2l ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orm2l side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "orm2l: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orm2l sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorm2r.f>
orm2r ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orm2r side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "orm2r: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orm2r sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormbr.f>
ormbr ::
   Char {- ^ vect -} ->
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ k -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormbr vect side trans m k a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.ignore "ormbr: minimum[nq,k] == tauDim0" tauDim0
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      vectPtr <- Call.char vect
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormbr vectPtr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormhr.f>
ormhr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ ilo -} ->
   Int {- ^ ihi -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormhr side trans m ilo ihi a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      iloPtr <- Call.cint ilo
      ihiPtr <- Call.cint ihi
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormhr sidePtr transPtr mPtr nPtr iloPtr ihiPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorml2.f>
orml2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
orml2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.orml2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormlq.f>
ormlq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormlq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormlq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormql.f>
ormql ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormql side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "ormql: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormql sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormqr.f>
ormqr ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormqr side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let k = aDim0
   let lda = aDim1
   let n = cDim0
   let ldc = cDim1
   Call.assert "ormqr: k == tauDim0" (k == tauDim0)
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormqr sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormr2.f>
ormr2 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
ormr2 side trans m a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ormr2 sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormr3.f>
ormr3 ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
ormr3 side trans m l a tau c workSize = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.ormr3 sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormrq.f>
ormrq ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormrq side trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormrq sidePtr transPtr mPtr nPtr kPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormrz.f>
ormrz ::
   Char {- ^ side -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Int {- ^ l -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormrz side trans m l a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let k = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      kPtr <- Call.cint k
      lPtr <- Call.cint l
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormrz sidePtr transPtr mPtr nPtr kPtr lPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormtr.f>
ormtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array (ZeroInt,ZeroInt) Float {- ^ a -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ lwork -} ->
   IO (Int)
ormtr side uplo trans m a tau c lwork = do
   let (aDim0,aDim1) = Call.sizes2 $ Array.shape a
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _aSize = aDim0
   let lda = aDim1
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 (maximum[1,lwork])
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      aPtr <- Call.array a
      ldaPtr <- Call.cint lda
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      lworkPtr <- Call.cint lwork
      infoPtr <- Call.alloca
      liftIO $ FFI.ormtr sidePtr uploPtr transPtr mPtr nPtr aPtr ldaPtr tauPtr cPtr ldcPtr workPtr lworkPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sopgtr.f>
opgtr ::
   Char {- ^ uplo -} ->
   Int {- ^ n -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ tau -} ->
   Int {- ^ ldq -} ->
   IO (Array (ZeroInt,ZeroInt) Float, Int)
opgtr uplo n ap tau ldq = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let tauDim0 = Call.sizes1 $ Array.shape tau
   Call.assert "opgtr: n*(n+1)`div`2 == apDim0" (n*(n+1)`div`2 == apDim0)
   Call.assert "opgtr: n-1 == tauDim0" (n-1 == tauDim0)
   q <- Call.newArray2 n ldq
   work <- Call.newArray1 (n-1)
   evalContT $ do
      uploPtr <- Call.char uplo
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      qPtr <- Call.ioarray q
      ldqPtr <- Call.cint ldq
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.opgtr uploPtr nPtr apPtr tauPtr qPtr ldqPtr workPtr infoPtr
      liftIO $ pure (,)
         <*> Call.freezeArray q
         <*> fmap fromIntegral (peek infoPtr)

-- | <http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sopmtr.f>
opmtr ::
   Char {- ^ side -} ->
   Char {- ^ uplo -} ->
   Char {- ^ trans -} ->
   Int {- ^ m -} ->
   Array ZeroInt Float {- ^ ap -} ->
   Array ZeroInt Float {- ^ tau -} ->
   IOArray (ZeroInt,ZeroInt) Float {- ^ c -} ->
   Int {- ^ workSize -} ->
   IO (Int)
opmtr side uplo trans m ap tau c workSize = do
   let apDim0 = Call.sizes1 $ Array.shape ap
   let tauDim0 = Call.sizes1 $ Array.shape tau
   let (cDim0,cDim1) = Call.sizes2 $ MutArray.shape c
   let _apSize = apDim0
   let _tauSize = tauDim0
   let n = cDim0
   let ldc = cDim1
   work <- Call.newArray1 workSize
   evalContT $ do
      sidePtr <- Call.char side
      uploPtr <- Call.char uplo
      transPtr <- Call.char trans
      mPtr <- Call.cint m
      nPtr <- Call.cint n
      apPtr <- Call.array ap
      tauPtr <- Call.array tau
      cPtr <- Call.ioarray c
      ldcPtr <- Call.cint ldc
      workPtr <- Call.ioarray work
      infoPtr <- Call.alloca
      liftIO $ FFI.opmtr sidePtr uploPtr transPtr mPtr nPtr apPtr tauPtr cPtr ldcPtr workPtr infoPtr
      liftIO $ fmap fromIntegral (peek infoPtr)
